<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C常见知识点</title>
    <url>/2024/04/01/C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1-内存方面"><a href="#1-内存方面" class="headerlink" title="1.内存方面"></a>1.内存方面</h1><h2 id="1-1-堆与栈的区别？"><a href="#1-1-堆与栈的区别？" class="headerlink" title="1.1 堆与栈的区别？"></a>1.1 <strong>堆与栈的区别？</strong></h2><p>（1）栈的空间是系统自动分配和回收，堆的空间是用户手动分配回收（malloc，calloc，realloc，free）</p>
<p>（2）栈的空间较小，堆的空间较大</p>
<p>（3）栈的地址空间往地址向下增长，堆的地址空间是由低地址到高地址</p>
<p>（4）栈的存储效率更高</p>
<h2 id="1-2-字节对齐的理解"><a href="#1-2-字节对齐的理解" class="headerlink" title="1.2 字节对齐的理解"></a>1.2 字节对齐的理解</h2><h3 id="1-2-1-什么是字节对齐？"><a href="#1-2-1-什么是字节对齐？" class="headerlink" title="1.2.1 什么是字节对齐？"></a>1.2.1 什么是字节对齐？</h3><p>字节对齐主要是针对结构体而言的，通常编译器会自动对其成员变量进行对齐，以提高数据存取的效率；</p>
<h3 id="1-2-2-字节对齐的两种方式"><a href="#1-2-2-字节对齐的两种方式" class="headerlink" title="1.2.2 字节对齐的两种方式"></a>1.2.2 字节对齐的两种方式</h3><p>默认对齐方式、指定对齐方式；</p>
<p>默认对齐方式内存分配满足以下三个条件：</p>
<ol>
<li>结构体第一个成员的地址和结构体的首地址相同；</li>
<li>结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节；</li>
<li>结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节。如char是1字节，short是2字节，int是4字节…</li>
</ol>
<p>指定对齐方式使用以下方式声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注：通过#pragma pack(n)改变C编译器的字节对齐方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)         <span class="comment">//安装4字节的对齐方式</span></span></span><br></pre></td></tr></table></figure>
<p>指定对齐方式内存分配满足以下几个条件：</p>
<ol>
<li>结构体第一个成员的地址和结构体的首地址相同</li>
<li>结构体每个成员的地址偏移需要满足：N大于等于该成员的大小，那么该成员的地址偏移需满足默认对齐方式（地址偏移是其成员大小的整数倍）；Ｎ小于该成员的大小，那么该成员的地址偏移是N的整数倍。</li>
<li>结构体总的大小需要时N的整数倍，如果不是需要在结构体的末尾进行填充。</li>
<li>如果N大于结构体成员中最大成员的大小，则N不起作用，仍然按照默认方式对齐。</li>
</ol>
<p>注：在使用#pragma pack设定对齐方式一定要是2的整数幂，也就是（1，2，4，8，16，…），不然不起作用的，仍然按照默认方式对齐。</p>
<h2 id="1-3-内存泄漏和内存溢出是什么？"><a href="#1-3-内存泄漏和内存溢出是什么？" class="headerlink" title="1.3 内存泄漏和内存溢出是什么？"></a>1.3 内存泄漏和内存溢出是什么？</h2><p>（1）<strong>内存溢出：指程序申请内存时，没有足够的内存供申请者使用。</strong>或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错Out Of Memory,即所谓的内存溢出。</p>
<p>（2）<strong>内存泄漏：是指程序在申请内存后，无法释放已申请的内存空间。</strong>一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>
<h2 id="1-4-全局变量和局部变量在内存中有什么不同"><a href="#1-4-全局变量和局部变量在内存中有什么不同" class="headerlink" title="1.4 全局变量和局部变量在内存中有什么不同?"></a>1.4 <strong>全局变量和局部变量在内存中有什么不同?</strong></h2><p>（1）<strong>全局变量</strong>保存在内存的全局存储区中， <strong>占用静态的存储单元</strong> ；</p>
<p>（2）<strong>局部变量</strong>保存在<strong>栈</strong>中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<h2 id="1-5-描述内存分配方式以及它们的区别"><a href="#1-5-描述内存分配方式以及它们的区别" class="headerlink" title="1.5 描述内存分配方式以及它们的区别"></a>1.5 描述内存分配方式以及它们的区别</h2><p>（1）<strong>从静态存储区域分配</strong>。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。<br>（2）<strong>在栈上创建</strong>。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>（3）<strong>从堆上分配，亦称动态内存分配</strong>。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p>
<h1 id="2-存放位置（文件，变量的生命周期）"><a href="#2-存放位置（文件，变量的生命周期）" class="headerlink" title="2.存放位置（文件，变量的生命周期）"></a>2.存放位置（文件，变量的生命周期）</h1><h2 id="2-1-局部变量和全局变量可以重名吗？"><a href="#2-1-局部变量和全局变量可以重名吗？" class="headerlink" title="2.1 局部变量和全局变量可以重名吗？"></a>2.1 局部变量和全局变量可以重名吗？</h2><p>（1）<strong>能，局部变量会屏蔽全局变量。</strong>C++中要用全局变量，需要使用 “::”(域解析符) 。C语言中局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。</p>
<p>（2）对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。</p>
<h2 id="2-2-const关键字"><a href="#2-2-const关键字" class="headerlink" title="2.2 const关键字"></a>2.2 const关键字</h2><h3 id="2-2-1-修饰变量"><a href="#2-2-1-修饰变量" class="headerlink" title="2.2.1 修饰变量"></a>2.2.1 修饰变量</h3><p>const的 常规用法，在变量初次定义时赋初，并用关键字const修饰，<strong>使变量只可访问，不能重新赋值修改变量。</strong></p>
<h3 id="2-2-2-修饰指针"><a href="#2-2-2-修饰指针" class="headerlink" title="2.2.2 修饰指针"></a>2.2.2 修饰指针</h3><p>（1） <strong>限制指针变量修饰</strong> ：指针变量指向的位置不能被修改。定义时，被 const 修饰的指针变量指针只能在定义时初始化，不能定义之后重新指向新的数据。</p>
<p>（2） <strong>限制指针变量指向的数据修饰【指针的解引用】</strong> ：修饰的指针变量指向的变量的值不能被修改，但是该指针可以指向其它空间。</p>
<p>（3） <strong>同时限制指针变量和指针变量指向的变量的值修饰</strong> ：指针变量指向的位置不能被修改，并且指针变量指向变量的值也不能被修改。</p>
<p>（4） <strong>修饰函数形参【指针】</strong> ：函数形参可以利用const关键字进行限制，来防止在函数内部修改指针指向的数据。</p>
<h2 id="2-3-static关键字"><a href="#2-3-static关键字" class="headerlink" title="2.3 static关键字"></a>2.3 static关键字</h2><p>（1）在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>（2）在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>（3） 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p>
<h2 id="2-4-volatile关键字的作用？"><a href="#2-4-volatile关键字的作用？" class="headerlink" title="2.4 volatile关键字的作用？"></a>2.4 volatile关键字的作用？</h2><p>（1）裸机编程时，某变量是指向寄存器中某一特定地址， <strong>添加volatile的变量不进行优化处理</strong> ；</p>
<p>（2）某函数与中断函数共享全局变量时，加上volatile，让编译器不要省略该变量的访问；</p>
<p>（3）多线程中修饰共享全局变量，让编译器不要省略该变量的访问。</p>
<h2 id="2-5-内存布局中有哪些段？"><a href="#2-5-内存布局中有哪些段？" class="headerlink" title="2.5 内存布局中有哪些段？"></a>2.5 <strong>内存布局中有哪些段？</strong></h2><p>文本段(.text)、数据段(.data)、.bss段、堆(heap)、栈(stack)</p>
<p><img src="/2024/04/01/C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/image/1698070866412.png" alt="1698070866412"></p>
<h2 id="2-6-程序的内存分配"><a href="#2-6-程序的内存分配" class="headerlink" title="2.6 程序的内存分配"></a>2.6 程序的内存分配</h2><p>一个由 c/C++编译的程序占用的内存分为以下几个部分</p>
<ol>
<li><strong>栈区（stack）</strong> —由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li><strong>堆区（heap）</strong>一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</li>
<li><strong>全局区（静态区）（static）</strong> —全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li>
<li><strong>文字常量区</strong> —常量字符串就是放在这里的。程序结束后由系统释放。</li>
<li><strong>程序代码区</strong> —存放函数体的二进制代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">例子程序</span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//全局未初始化区:bss区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b ; <span class="comment">//栈</span></span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//栈</span></span><br><span class="line">	<span class="type">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line">	<span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">//123456\\0 在常量区，p3 在栈上。</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">//全局（静态）初始化区</span></span><br><span class="line">	p1 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	p2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">//分配得来得 10 和 20 字节的区域就在堆区。</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p1,<span class="string">&quot;123456&quot;</span>); <span class="comment">//123456\\0 放在常量区，编译器可能会将它与 p3 所向&quot;123456&quot;优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-“引用”与指针的区别"><a href="#2-7-“引用”与指针的区别" class="headerlink" title="2.7 “引用”与指针的区别"></a>2.7 “引用”与指针的区别</h2><p>（1）引用必须被初始化，指针不必。<br>（2）引用初始化以后不能被改变，指针可以改变所指的对象。<br>（3）不存在指向空值的引用，但是存在指向空值的指针。<br>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</p>
<h1 id="3-宏定义"><a href="#3-宏定义" class="headerlink" title="3.宏定义"></a>3.宏定义</h1><h2 id="3-1-h-头文件中的-ifndef-define-endif-的作用"><a href="#3-1-h-头文件中的-ifndef-define-endif-的作用" class="headerlink" title="3.1 .h 头文件中的 ifndef/define/endif 的作用"></a>3.1 .h 头文件中的 ifndef/define/endif 的作用</h2><p>防止该头文件被重复引用。</p>
<h2 id="3-2-include-与-include-“file-h”的区别"><a href="#3-2-include-与-include-“file-h”的区别" class="headerlink" title="3.2 #include 与 #include “file.h”的区别"></a>3.2 #include<file.h> 与 #include “file.h”的区别</file.h></h2><p>前者是从 Standard Library 的路径寻找和引用 file.h，而后者是从当前工作路径搜寻并引用 file.h。</p>
<h2 id="3-3-什么是预编译-何时需要预编译"><a href="#3-3-什么是预编译-何时需要预编译" class="headerlink" title="3.3 什么是预编译,何时需要预编译?"></a>3.3 什么是预编译,何时需要预编译?</h2><p> <strong>预编译又称为预处理,是做些代码文本的替换工作</strong> 。处理#开头的指令,比如拷贝#include 包含的文件代码，#define 宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</p>
<p>c编译系统在对程序进行通常的编译之前，先进行预处理。c 提供的预处理功能主要有以下三种：</p>
<ol>
<li>宏定义</li>
<li>文件包含</li>
<li>条件编译<ol>
<li>总是使用不经常改动的大型代码体。</li>
<li>程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</li>
</ol>
</li>
</ol>
<h2 id="3-4-论述含参数的宏与函数的优缺点"><a href="#3-4-论述含参数的宏与函数的优缺点" class="headerlink" title="3.4 论述含参数的宏与函数的优缺点"></a>3.4 论述含参数的宏与函数的优缺点</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>带参宏</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理时间</td>
<td>编译时</td>
<td>程序运行时</td>
</tr>
<tr>
<td>参数类型</td>
<td>没有参数类型问题</td>
<td>定义实参、形参类型</td>
</tr>
<tr>
<td>处理过程</td>
<td>不分配内存</td>
<td>分配内存</td>
</tr>
<tr>
<td>程序长度</td>
<td>变长</td>
<td>不变</td>
</tr>
<tr>
<td>运行速度</td>
<td>不占运行时间</td>
<td>调用和返回占用时间</td>
</tr>
</tbody>
</table>
</div>
<h1 id="4-语法"><a href="#4-语法" class="headerlink" title="4.语法"></a>4.语法</h1><h2 id="4-1-结构与联合有和区别？"><a href="#4-1-结构与联合有和区别？" class="headerlink" title="4.1 结构与联合有和区别？"></a>4.1 结构与联合有和区别？</h2><p>(1) 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选<br>中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。</p>
<p>(2) 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成<br>员赋值是互不影响的。</p>
<h2 id="4-2-简述数组与指针的区别"><a href="#4-2-简述数组与指针的区别" class="headerlink" title="4.2 简述数组与指针的区别"></a>4.2 简述数组与指针的区别</h2><h3 id="数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。"><a href="#数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。" class="headerlink" title="数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。"></a>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</h3><p>(1) <strong>修改内容上的差别</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *p = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>; <span class="comment">// 编译器不能发现该错误，运行时错误</span></span><br></pre></td></tr></table></figure>
<p>(2) <strong>用运算符 sizeof 可以计算出数组的容量（字节数）。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(p);</span><br></pre></td></tr></table></figure>
<p><strong>p 为指针得到的是一个 指针变量的字节数，而不是 p 所指的内存容量</strong>。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = a;</span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 12 字节</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure>
<p>计算数组和指针的内存容量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">char</span> a[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>通信种类</title>
    <url>/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="一、串口通信"><a href="#一、串口通信" class="headerlink" title="一、串口通信"></a>一、串口通信</h1><p>串口通信属于全双工，串行通信，有同步和异步通信。<br>USART：通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换，既可以同步通信也可以异步通信。<br>UART：通用异步收发器(Universal Asynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能（时钟同步），只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p>
<h2 id="1-1-UART"><a href="#1-1-UART" class="headerlink" title="1.1 UART"></a>1.1 UART</h2><p>8051、STM32等MCU芯片的内部都集成了UART，两个MCU进行串口通信时，可将一个MCU的TX、RX引脚分别与另一个MCU的RX、TX引脚相连</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699363964154.png" alt="1699363964154"></p>
<p>UART进行串口通信使用TTL电平。5V工作电压的MCU，使用0 ~ 0.5V表示逻辑0，2.5V ~ 5V表示逻辑1；3.3V工作电压的MCU，使用0 ~ 0.5V表示逻辑0，2.5V ~ 3.3V表示逻辑1。</p>
<p>UART串口通信是异步，全双工，串行通信，所以通信双方必须事先约定好通信参数，这些通信参数包括：波特率、数据位、校验位、停止位。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699363975769.png" alt="1699363975769"></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364814032.png" alt="1699364814032"></p>
<h3 id="1-起始位、数据位、奇偶校验位、停止位"><a href="#1-起始位、数据位、奇偶校验位、停止位" class="headerlink" title="1.起始位、数据位、奇偶校验位、停止位"></a><strong>1.起始位、数据位、奇偶校验位、停止位</strong></h3><p>串口通信时，收发是一个周期一个周期进行的，每个周期传输n个二进制位。这一个周期就叫做一个通信单元，一个通信单元由：起始位+数据位+奇偶校验位+停止位组成的。</p>
<p>起始位：表示发送方要开始发送一个通信单元，起始位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。</p>
<p>数据位：是一个通信单元中发送的有效信息位，是本次通信真正要发送的有效数据，串口通信一次发送多少位有效数据是可以设定的（可选的有6、7、8、9，一般都是选择8位数据位，因为一般通过串口发送的文字信息都是ASCII码编码，而ASCII码中一个字符刚好编码为8位）。</p>
<p>校验位：是用来校验数据位，以防止数据位出错的。</p>
<p>停止位：是发送方用来表示本通信单元结束标志的，停止位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。常见的有1位停止位、1.5位停止位、2位停止位等，一般使用的是1位停止位。</p>
<h3 id="2-波特率"><a href="#2-波特率" class="headerlink" title="2.波特率"></a><strong>2.波特率</strong></h3><p>波特率，指的是串口通信的速率，也就是每秒钟可以传输多少个二进制位，单位为bit/s。譬如，每秒钟可以传输9600个二进制位，它传输所用的时间</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364286832.png" alt="1699364286832"></p>
<p>也就是传输一个二进制位需要的时间是1/9600秒，也就是104us。</p>
<p>串口通信的波特率不能随意设定，而应该是在一些值中去选择。一般最常见的波特率是9600或115200（低端单片机如51常用9600，高端单片机和嵌入式SOC常用</p>
<p>115200）。波特率不能随意指定，主要是因为：通信双方必须事先设定相同的波特率才能成功通信，如果发送方和接收方按照不同的波特率通信则根本收不到。</p>
<h2 id="1-2-RS232通信"><a href="#1-2-RS232通信" class="headerlink" title="1.2 RS232通信"></a>1.2 RS232通信</h2><p>RS232标准使用+5 V ～ +15 V表示逻辑0，-5V ～ -15 V表示逻辑1。相比TTL电平，RS232电平提高了串口通信的抗干扰能力，增大了串口通信的距离。台式PC一般都带有RS232标准接口，MCU按RS232标准进行串口通信时，需加max232电平转换芯片。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364589028.png" alt="1699364589028"></p>
<h2 id="1-3-RS485通信"><a href="#1-3-RS485通信" class="headerlink" title="1.3 RS485通信"></a>1.3 RS485通信</h2><p>RS485标准使用差分电平表示逻辑0或1，当A与B的电压差为+2v ~ +6v 时表示逻辑1，当A与B的电压差为-2v ~ -6v时表示逻辑0。RS485为半双工通信，即通信节点不能同时进行数据的接收和发送。相比RS232电平，RS485电平使串口通信的抗干扰能力更强，通信距离更远。MCU按RS485标准进行串口通信时，需加max485电平转换芯片。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364633791.png" alt="1699364633791"></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364752080.png" alt="1699364752080"></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699367010762.png" alt="1699367010762"></p>
<h1 id="二、I2C总线（Inter-Integrated-Circuit）"><a href="#二、I2C总线（Inter-Integrated-Circuit）" class="headerlink" title="二、I2C总线（Inter Integrated Circuit）"></a><strong>二、I2C总线（Inter Integrated Circuit）</strong></h1><p>I2C总线是一种同步、双向、半双工的两线式串行接口总线。这里，半双工的含义是指在任意给定的时刻，只有一个方向上是可以通信的。I2C总线最早由Philips半导体公司于20世纪80年代研发面市。I2C最初的设计目标是为微处理器/微控制器系统与电视机外围芯片之间的连接提供简单的方法。</p>
<h2 id="2-1-物理接口"><a href="#2-1-物理接口" class="headerlink" title="2.1 物理接口"></a>2.1 物理接口</h2><h3 id="2-1-1-接线"><a href="#2-1-1-接线" class="headerlink" title="2.1.1 接线"></a>2.1.1 接线</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699365266267.png" alt="1699365266267"></p>
<p>I2C总线由两条总线组成：串行时钟线SCL和串行数据线SDA。</p>
<ul>
<li>SCL线——负责产生同步时钟脉冲。</li>
<li>SDA线——负责在设备间传输串行数据。</li>
</ul>
<h3 id="2-1-2-物理接口示意图"><a href="#2-1-2-物理接口示意图" class="headerlink" title="2.1.2 物理接口示意图"></a>2.1.2 物理接口示意图</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699365946231.png" alt="1699365946231"></p>
<p>I2C的连线总是要通过电阻上拉至输入电压，I2C的连线工作于三种速度：<strong>高速，快速，慢速</strong>。</p>
<p>I2C总线是共享的总线系统，因此可以将多个I2C设备连接到该系统上。连接到I2C总线上的设备既可以用作主设备，也可以用作从设备。主设备负责控制通信，通过对数据传输进行初始化/终止化，来发送数据并产生所需的同步时钟脉冲。从设备则是等待来自主设备的命令，并响应命令接收。主设备和从设备都可以作为发送设备或接收设备。无论主设备是作为发送设备还是接收设备，同步时钟信号都只能由主设备产生。在相同的总线上，I2C支持多个主设备的同时存在。图1-1显示了I2C总线上主设备和从设备的连接关系。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699366167296.png" alt="1699366167296"></p>
<h2 id="2-2-i2c简易时序图"><a href="#2-2-i2c简易时序图" class="headerlink" title="2.2 i2c简易时序图"></a>2.2 i2c简易时序图</h2><ul>
<li>启动条件<br>当SCL为高电平时，SDA从高电平向低电平切换</li>
<li>停止条件<br>当SCL是高电平时，SDA由低电平向高电平切换</li>
<li>地址帧<br>每个从属设备唯一的7位或10位序列，用于主从设备之间的地址识别。</li>
<li>读/写位<br>一位，如果主机是向从机发送数据则为低电平，请求数据则为高电平</li>
<li>ACK/NACK<br>消息中的每个帧后均有一个ACK/NACK位。如果成功接收到地址帧或数据帧，接收设备会返回一个ACK位用于表示确认。</li>
</ul>
<h3 id="2-2-1-启动信号与停止信号的时序图"><a href="#2-2-1-启动信号与停止信号的时序图" class="headerlink" title="2.2.1 启动信号与停止信号的时序图"></a>2.2.1 启动信号与停止信号的时序图</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699366574897.png" alt="1699366574897"></p>
<h3 id="2-2-2-数据位发送"><a href="#2-2-2-数据位发送" class="headerlink" title="2.2.2 数据位发送"></a>2.2.2 数据位发送</h3><p>当SCL为高电平时读取的SDA信号为有效信号，SCL低电平为数据无效，所以通常用来SDA的高低电平的转换。</p>
<p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。进行数据传送时，<strong>在SCL呈现高电平期间，SDA上的电平必须保持稳定，低电平为数据0，高电平为数据1</strong>。<strong>只有在SCL为低电平期间，才允许SDA上的电平改变状态</strong>。逻辑0的电平为低电压，而逻辑1则为高电平。时序如下图所示</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699366722339.png" alt="1699366722339"></p>
<h2 id="2-3-工作原理"><a href="#2-3-工作原理" class="headerlink" title="2.3 工作原理"></a>2.3 工作原理</h2><p>I2C的数据传输是以多个msg的形式进行。每个msg包括：从机二进制地址帧、以及一个或者多个数据帧、开始条件和停止条件，读/写位和数据帧之间的ACK/NACK位：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699365343036.png" alt="1699365343036"></p>
<h2 id="2-4-总线连接"><a href="#2-4-总线连接" class="headerlink" title="2.4 总线连接"></a>2.4 总线连接</h2><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364921358.png" alt="1699364921358"></p>
<p>当总线空闲时，SDA 和SCL 都处于高电平状态，当主机要和某个从机通讯时，会先发送一个开始条件，然后发送从机地址和读写控制位，接下来传输数据（主机发送或者接收数据），数据传输结束时主机会发送停止条件。传输的每个字节为8 位，高位在前，低位在后。</p>
<p>　　　　• 开始条件： SCL 为高电平时，主机将SDA 拉低，表示数据传输即将开始。</p>
<p>　　　　• 从机地址： 主机发送的第一个字节为从机地址，高7 位为地址，<strong>最低位为R/W 读写控制位，1 表示读操作，0 表示写操作</strong>。一般从机地址有7 位地址模式和10 位地址模式两种，如果是10 位地址模式，第一个字节的头7 位是11110XX 的组合，其中最后两位（XX）是10 位地址的两个最高位，第二个字节为10 位从机地址的剩下8 位，如下图所示：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364966732.png" alt="1699364966732"></p>
<p>• 应答信号： 每传输完成一个字节的数据，接收方就需要回复一个ACK（acknowledge）。写数据时由从机发送ACK，读数据时由主机发送ACK。当主机读到最后一个字节数据时，可发送NACK（Notacknowledge）然后跟停止条件。</p>
<p>　　　　• 数据： 从机地址发送完后可能会发送一些指令，依从机而定，然后开始传输数据，由主机或者从机发送，每个数据为8 位，数据的字节数没有限制。</p>
<p>　　　　• 重复开始条件： 在一次通信过程中，主机可能需要和不同的从机传输数据或者需要切换读写操作时，主机可以再发送一个开始条件。</p>
<p>　　　　• 停止条件： 在SDA 为低电平时，主机将SCL 拉高并保持高电平，然后在将SDA 拉高，表示传输结束。</p>
<h2 id="2-5-传输步骤"><a href="#2-5-传输步骤" class="headerlink" title="2.5 传输步骤"></a>2.5 传输步骤</h2><ol>
<li>在SCL线为高电平时，主机通过将SDA线从高电平切换到低电平来启动总线通信。</li>
<li>主机向总线发送要与之通信的从机的7位或10位地址，以及读/写位</li>
<li>每个从机将主机发送的地址与其自己的地址进行比较。如果地址匹配，则从机通过将SDA线拉低一位返回一个ACK位。如果主机的地址与从机的地址不匹配，则从机将SDA线拉高。</li>
<li>主机发送或接收数据帧；</li>
<li>传输完每个数据帧后，接收设备将另一个ACK位返回给发送方，以确认已成功接收到该帧；</li>
<li>随后主机将SCL切换为高电平，然后再将SDA切换为高电平，从而向从机发送停止条件。</li>
</ol>
<h2 id="2-6-I2C优点"><a href="#2-6-I2C优点" class="headerlink" title="2.6 I2C优点"></a>2.6 I2C优点</h2><p>1.仅仅使用两根线</p>
<p>2.支持多个主机和从机</p>
<p>3.硬件比UART更简单</p>
<h2 id="2-7-I2C缺点"><a href="#2-7-I2C缺点" class="headerlink" title="2.7 I2C缺点"></a>2.7 I2C缺点</h2><p><strong>1.数据传输比SPI慢</strong></p>
<p><strong>2.数据帧大小限制为8位</strong></p>
<h1 id="三、SPI总线（Serial-Peripheral-Interface）"><a href="#三、SPI总线（Serial-Peripheral-Interface）" class="headerlink" title="三、SPI总线（Serial Peripheral Interface）"></a>三、<strong>SPI总线（Serial Peripheral Interface）</strong></h1><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola（摩托罗拉）公司推出的一种同步串行接口技术，是一种高速的，全双工，同步的通信总线。SPI的特点就是传输熟读很快。</p>
<h2 id="3-1-硬件接口"><a href="#3-1-硬件接口" class="headerlink" title="3.1 硬件接口"></a>3.1 硬件接口</h2><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699367194316.png" alt="1699367194316"></p>
<p>（1）主设备出、从设备入（Master Out Slave In，MOSI）：由主设备向从设备传输数据的信号线，也称为从设备输入（Slave Input/Slave Data In，SI/SDI）。</p>
<p>（2）主设备入、从设备出（Master In Slave Out，MISO）：由从设备向主设备传输数据的信号线，也称为从设备输出（Slave Output/Slave Data Out，SO/SDO）。</p>
<p>（3）串行时钟（Serial Clock，SCLK）：传输时钟信号的信号线。</p>
<p>（4）从设备选择（Slave Select，SS）：用于选择从设备的信号线，低电平有效。</p>
<p>下图显示了单个主机和单个从机之间的典型SPI连接。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425195202.png" alt="1699425195202"></p>
<h2 id="3-2-通信原理"><a href="#3-2-通信原理" class="headerlink" title="3.2 通信原理"></a>3.2 通信原理</h2><h3 id="3-2-1-采用主-从模式-Master-Slave-的控制方式"><a href="#3-2-1-采用主-从模式-Master-Slave-的控制方式" class="headerlink" title="3.2.1 采用主-从模式(Master-Slave) 的控制方式"></a>3.2.1 采用主-从模式(Master-Slave) 的控制方式</h3><p>SPI 规定了两个 SPI 设备之间通信必须由主设备 (Master) 来控制次设备 (Slave). 一个 Master 设备可以通过提供 Clock 以及对 Slave 设备进行片选 (Slave Select) 来控制多个 Slave 设备, SPI 协议还规定 Slave 设备的 Clock 由 Master 设备通过 SCK 管脚提供给 Slave 设备, Slave 设备本身不能产生或控制 Clock, 没有 Clock 则 Slave 设备不能正常工作。</p>
<h3 id="3-2-2-采用同步方式-Synchronous-传输数据"><a href="#3-2-2-采用同步方式-Synchronous-传输数据" class="headerlink" title="3.2.2 采用同步方式(Synchronous)传输数据"></a>3.2.2 采用同步方式(Synchronous)传输数据</h3><p>Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse), 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过时钟极性 (CPOL) 和 时钟相位 (CPHA) 控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的.</p>
<h3 id="3-2-3-数据交换-Data-Exchanges"><a href="#3-2-3-数据交换-Data-Exchanges" class="headerlink" title="3.2.3 数据交换(Data Exchanges)"></a>3.2.3 数据交换(Data Exchanges)</h3><p>SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个 “发送者(Transmitter)” 或者 “接收者(Receiver)”. 在每个 Clock 周期内, SPI 设备都会发送并接收一个 bit 大小的数据, 相当于该设备有一个 bit 大小的数据被交换了。</p>
<p>一个 Slave 设备要想能够接收到 Master 发过来的控制信号, 必须在此之前能够被 Master 设备进行访问 (Access). 所以, Master 设备必须首先通过 SS/CS pin 对 Slave 设备进行片选, 把想要访问的 Slave 设备选上。</p>
<p>在数据传输的过程中, 每次接收到的数据必须在下一次数据传输之前被采样. 如果之前接收到的数据没有被读取, 那么这些已经接收完成的数据将有可能会被丢弃, 导致 SPI 物理模块最终失效. 因此, 在程序中一般都会在 SPI 传输完数据后, 去读取 SPI 设备里的数据, 即使这些数据(Dummy Data)在我们的程序里是无用的.</p>
<h2 id="3-3-SPI协议总结"><a href="#3-3-SPI协议总结" class="headerlink" title="3.3 SPI协议总结"></a>3.3 SPI协议总结</h2><ol>
<li>三根线（SDO,SDI,SCLK）1对1传输可以省CS.</li>
<li>全双工：这里的全双工可串口还不同，不能同时收发。SCLK由主机控制，从机不能主动给主机发数据。感觉类似半工。</li>
<li>数据发送位数没有要求，而且可以中断发送然后续上。</li>
<li>一个上降沿+上升沿为1个数据。</li>
<li>没有应答机制，也没有硬件校验机制。</li>
<li>可以1主多从，靠CS片选使能。</li>
<li>同步通信。</li>
<li>速度可达几Mbps</li>
</ol>
<p>SPI 协议定义了通信的起始信号、停止信号、数据有效性、时钟同步等。它的通讯时序如下：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426049687.png" alt="1699426049687"></p>
<p>这是一个主机的通信时序，信号线 NSS、SCK、MOSI 都是由主机控制，MISO 是由从机进行控制。其中 MOSI 和 MISO 上的数据仅在 NSS 为低时才有效，并且每个SCK 时钟周期只交换一位数据。</p>
<p>他的每一部分组成分别如下：</p>
<p>（1）起始信号</p>
<p>SPI通信时序图中的①为通信的起始信号，由主机控制NSS从高电平到低电平，从而选择要进行通信的从机，再通过主机产生时钟信号SCK，启动一次数据的传输。如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426093533.png" alt="1699426093533"></p>
<p>（2）停止信号</p>
<p>SPI通信时序图中的⑥为通信的起始信号，由主机控制NSS从低电平到高电平，从而结束一次数据的传输。如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426118135.png" alt="1699426118135"></p>
<p>（3）数据有效性</p>
<p>SPI 在 SCK 时钟的同步下进行数据的准备和采样，如通信时序图的②③④⑤所示。在 NSS 为低的情况时，在 SCK 的上升沿时 MISO 和 MOSI 进行数据准备，SCK 的下降沿时读取 MISO 和 MOSI 上的数据。在 NSS 为高时，MISO 和MOSI 上的数据无效。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426132247.png" alt="1699426132247"></p>
<p>（4）时钟的同步</p>
<p>SPI 的数据传输是需要 SCK 时钟信号严格同步的，每一个 SCK 周期只传输一位数据，这一个周期里要完成数据的准备和采样，且数据的输入和输出是同时进行的。如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426147469.png" alt="1699426147469"></p>
<p>SPI中数据是MSB(高位) 先行或 LSB(低位)先行，在协议中是没有硬性规定，只需通信双方保持统一即可。</p>
<p>注意：SPI 一次数据传输可以是 8 位或 16 位为单位，每次传输的单位数不受限制。</p>
<h2 id="3-4-传输过程"><a href="#3-4-传输过程" class="headerlink" title="3.4 传输过程"></a>3.4 传输过程</h2><ul>
<li>主机先将 <code>NSS</code>信号拉低，这样保证开始接收数据；</li>
<li>当<strong>接收端</strong>检测到时钟的边沿信号时，它将立即读取<strong>数据线</strong>上的信号，这样就得到了一位数据（1 <code>bit</code>）;<br>由于时钟是随数据一起发送的，因此指定 <strong>数据的传输速度并不重要</strong> ，尽管设备将具有可以运行的最高速度（稍后我们将讨论选择合适的时钟边沿和速度）。</li>
<li><strong>主机</strong>发送到<strong>从机</strong>时：主机产生相应的时钟信号，然后数据<strong>一位一位</strong>地将从 <code>MOSI</code>信号线上进行发送到从机；</li>
<li><strong>主机</strong>接收<strong>从机</strong>数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过 <code>MISO</code>信号线发送；</li>
</ul>
<p>具体如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425109015.png" alt="1699425109015"></p>
<blockquote>
<p>注意，SPI是“全双工”（具有单独的发送和接收线路），因此可以在同一时间发送和接收数据，另外SPI的接收硬件可以是一个简单的移位寄存器。这比异步串行通信所需的完整UART要简单得多，并且更加便宜；</p>
</blockquote>
<h2 id="3-5-SPI时钟"><a href="#3-5-SPI时钟" class="headerlink" title="3.5 SPI时钟"></a>3.5 SPI时钟</h2><h3 id="3-5-1-时钟极性-CKP-Clock-Polarity"><a href="#3-5-1-时钟极性-CKP-Clock-Polarity" class="headerlink" title="3.5.1 时钟极性 CKP/Clock Polarity"></a>3.5.1 时钟极性 CKP/Clock Polarity</h3><p>除了配置串行时钟速率（频率）外，SPI主设备还需要配置 <strong>时钟极性</strong> 。</p>
<p>根据硬件制造商的命名规则不同，时钟极性通常写为<strong>CKP</strong>或 <strong>CPOL</strong> 。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据；</p>
<p><strong>CKP</strong>可以配置为1或0。这意味着您可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。您必须参考设备的数据手册才能正确设置CKP和CKE。</p>
<ul>
<li><code>CKP = 0</code>：时钟空闲 <code>IDLE</code>为低电平 <code>0</code>；</li>
<li><code>CKP = 1</code>：时钟空闲 <code>IDLE</code>为高电平 <code>1</code>；</li>
</ul>
<h3 id="3-5-2-时钟相位-CKE-Clock-Phase-Edge"><a href="#3-5-2-时钟相位-CKE-Clock-Phase-Edge" class="headerlink" title="3.5.2 时钟相位 CKE /Clock Phase (Edge)"></a><strong>3.5.2 时钟相位 CKE /Clock Phase (Edge)</strong></h3><p>除配置串行时钟速率和极性外，SPI主设备还应配置时钟相位（或边沿）。根据硬件制造商的不同，时钟相位通常写为<strong>CKE</strong>或 <strong>CPHA</strong> ；</p>
<p>顾名思义，时钟相位/边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；</p>
<ul>
<li><code>CKE = 0</code>：在时钟信号 <code>SCK</code>的第一个跳变沿采样；</li>
<li><code>CKE = 1</code>：在时钟信号 <code>SCK</code>的第二个跳变沿采样；</li>
</ul>
<h3 id="3-5-3-时钟配置总结"><a href="#3-5-3-时钟配置总结" class="headerlink" title="3.5.3 时钟配置总结"></a><strong>3.5.3 时钟配置总结</strong></h3><p>综上几种情况，下图总结了所有时钟配置组合，并突出显示了实际采样数据的时刻；</p>
<blockquote>
<p>其中黑色线为采样数据的时刻；<br>蓝色线为SCK时钟信号；</p>
</blockquote>
<p>具体如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425267948.png" alt="1699425267948"></p>
<h3 id="3-5-4-模式编号"><a href="#3-5-4-模式编号" class="headerlink" title="3.5.4 模式编号"></a><strong>3.5.4 模式编号</strong></h3><p>SPI的时钟极性和相位的配置通常称为  <strong>SPI模式</strong> ，所有可能的模式都遵循以下约定；具体如下表所示；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>SPI Mode</th>
<th>CPOL</th>
<th>CPHA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 [00]</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 [01]</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 [10]</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3 [11]</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，我们还应该仔细检查微控制器数据手册中包含的模式表，以确保一切正常。</p>
<h2 id="3-6-总线结构"><a href="#3-6-总线结构" class="headerlink" title="3.6 总线结构"></a>3.6 总线结构</h2><h3 id="3-6-1-单从机模式"><a href="#3-6-1-单从机模式" class="headerlink" title="3.6.1 单从机模式"></a>3.6.1 单从机模式</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425967885.png" alt="1699425967885"></p>
<h3 id="3-6-2-多从机模式"><a href="#3-6-2-多从机模式" class="headerlink" title="3.6.2 多从机模式"></a>3.6.2 <strong>多从机模式</strong></h3><p>前面说到SPI总线必须有一个主机，可以有多个从机，那么具体连接到SPI总线的方法有以下两种：</p>
<h4 id="多NSS"><a href="#多NSS" class="headerlink" title="多NSS"></a><strong>多NSS</strong></h4><ol>
<li>通常，每个从机都需要一条单独的SS线。</li>
<li>如果要和特定的从机进行通讯，可以将相应的 <code>NSS</code>信号线拉低，并保持其他 <code>NSS</code>信号线的状态为高电平；如果同时将两个 <code>NSS</code>信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条 <code>MISO</code>线上传输数据，最终导致接收数据乱码。</li>
</ol>
<p>具体连接方式如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425587349.png" alt="1699425587349"></p>
<h4 id="菊花链"><a href="#菊花链" class="headerlink" title="菊花链"></a><strong>菊花链</strong></h4><p>在数字通信世界中，在设备信号（总线信号或中断信号）以串行的方式从一 个设备依次传到下一个设备，不断循环直到数据到达目标设备的方式被称为 <strong>菊花链</strong> 。</p>
<ol>
<li>菊花链的最大缺点是因为是信号串行传输，所以一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了；</li>
<li>另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况；</li>
</ol>
<p>具体的连接如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425637860.png" alt="1699425637860"></p>
<blockquote>
<p>其中红线加粗为数据的流向；</p>
</blockquote>
<p>所以最终的数据流向图可以表示为：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425667413.png" alt="1699425667413"></p>
<blockquote>
<p>SCK为时钟信号，8clks表示8个边沿信号；<br>其中D为数据，X为无效数据；</p>
</blockquote>
<p>所以不难发现，菊花链模式充分使用了SPI其移位寄存器的功能，整个链充当通信移位寄存器，每个从机在下一个时钟周期将输入数据复制到输出。</p>
<h2 id="3-7-优缺点"><a href="#3-7-优缺点" class="headerlink" title="3.7 优缺点"></a><strong>3.7 优缺点</strong></h2><h3 id="SPI通讯的优势"><a href="#SPI通讯的优势" class="headerlink" title="SPI通讯的优势"></a><strong>SPI通讯的优势</strong></h3><p>使SPI作为串行通信接口脱颖而出的原因很多；</p>
<ul>
<li>全双工串行通信；</li>
<li>高速数据传输速率。</li>
<li>简单的软件配置；</li>
<li>极其灵活的数据传输，不限于8位，它可以是任意大小的字；</li>
<li>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器/晶振（与UART不同）。不需要收发器（与CAN不同）。</li>
</ul>
<h3 id="SPI的缺点"><a href="#SPI的缺点" class="headerlink" title="SPI的缺点"></a><strong>SPI的缺点</strong></h3><ul>
<li>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；</li>
<li>通常仅支持一个主设备；</li>
<li>需要更多的引脚（与I2C不同）；</li>
<li>没有定义硬件级别的错误检查协议；</li>
<li>与RS-232和CAN总线相比，只能支持非常短的距离；</li>
</ul>
<h1 id="四、Can"><a href="#四、Can" class="headerlink" title="四、Can"></a>四、Can</h1><h2 id="4-1-CAN基础知识"><a href="#4-1-CAN基础知识" class="headerlink" title="4.1 CAN基础知识"></a>4.1 CAN基础知识</h2><h3 id="4-1-1-CAN的一些基本概念"><a href="#4-1-1-CAN的一些基本概念" class="headerlink" title="4.1.1 CAN的一些基本概念"></a>4.1.1 CAN的一些基本概念</h3><p>什么是CAN总线</p>
<p>CAN 是 Controller Area Network 的缩写，是 ISO 国际标准化的串行通信协议。通俗来讲，CAN总线就是一种传输数据的线，用于在不同的ECU之间传输数据。<br>CAN总线有两个ISO国际标准：ISO11898 和 ISO11519。其中：</p>
<p>ISO11898 定义了通信速率为 125 kbps～1 Mbps 的高速 CAN 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米。<br>ISO11519 定义了通信速率为 10～125 kbps 的低速 CAN 通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米。</p>
<blockquote>
<p>Tips: &lt;总线的传输速率&gt;：又称为总线的通信速率，指的是位速率。或称为比特率（和波特率不是一回事），表示的是：单位时间内，通信线路上传输的二进制位的数量，其基本单位是 bps 或者 b/s (bit per second)。</p>
</blockquote>
<h3 id="4-1-2-Can物理层"><a href="#4-1-2-Can物理层" class="headerlink" title="4.1.2 Can物理层"></a>4.1.2 Can物理层</h3><p>与I2C、SPI等具有时钟信号的同步通讯方式不同，CAN通讯并不是以时钟信号来进行同步的，它是一种异步通讯，只具有CAN_High和CAN_Low两条信号线，共同构成一组差分信号线，<strong>以差分信号的形式进行通讯。</strong></p>
<h3 id="4-1-3-总线网络"><a href="#4-1-3-总线网络" class="headerlink" title="4.1.3 总线网络"></a><strong>4.1.3 总线网络</strong></h3><p>CAN物理层的形式主要有两种：</p>
<p>高速模式（125k～1m）</p>
<p>低速模式（10k～125k）</p>
<p>下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426788263.png" alt="1699426788263"></p>
<p>如图中所示，CAN总线包括CAN_H 和 CAN_L 两根线。节点通过<strong>CAN控制器</strong>和<strong>CAN收发器</strong>连接到CAN总线上。</p>
<h3 id="4-1-4-can信号表示"><a href="#4-1-4-can信号表示" class="headerlink" title="4.1.4 can信号表示"></a>4.1.4 can信号表示</h3><p>在CAN总线上，利用CAN_H和CAN_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为<strong>显性电平</strong>和 <strong>隐性电平</strong> 。其中<strong>显性电平</strong>为逻辑 <strong>0</strong> ，<strong>隐性电平</strong>为逻辑 <strong>1</strong> 。</p>
<p>ISO11898标准（125kbps ~ 1Mbps）和ISO11519标准（10kbps ~ 125kbps）中CAN信号的表示分别如下所示：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426829639.png" alt="1699426829639"></p>
<h3 id="4-1-5-can信号传输"><a href="#4-1-5-can信号传输" class="headerlink" title="4.1.5 can信号传输"></a>4.1.5 can信号传输</h3><p><strong>发送过程：</strong></p>
<p>CAN控制器将CPU传来的信号转换为逻辑电平（即<strong>逻辑0-显性电平</strong>或者 <strong>逻辑1-隐性电平</strong> ）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426937008.png" alt="1699426937008"></p>
<p><strong>接收过程：</strong></p>
<p>CAN接收器将CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到CAN控制器，CAN控制器再把该逻辑电平转化为相应的信号发送到CPU上。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426950445.png" alt="1699426950445"></p>
<p>概括的讲：</p>
<ul>
<li>发送方通过 <strong>使总线电平发生变化</strong> ，将其信息传递到CAN总线上。</li>
<li>接收方通过监听总线电平，将总线上的消息读入自己的接收器。</li>
</ul>
<h2 id="4-2-can通信的特点"><a href="#4-2-can通信的特点" class="headerlink" title="4.2 can通信的特点"></a>4.2 can通信的特点</h2><h3 id="4-2-1-多主工作方式"><a href="#4-2-1-多主工作方式" class="headerlink" title="4.2.1 多主工作方式"></a>4.2.1 <strong><strong>多主工作方式</strong></strong></h3><p>所谓多主工作方式，指的是：总线上的所有节点没有主从之分，大家都处于平等的地位。反应在数据传输上，即是：在总线空闲状态，任意节点都可以向总线上发送消息。</p>
<blockquote>
<p><strong>&lt;总线空闲状态&gt;</strong> ：</p>
<p>Tips:</p>
<p>当总线上的上出现 <strong>连续的11位隐性电平</strong> ，那么总线就处于空闲状态。也就是说对于任意一个节点而言，只要它监听到总线上连续出现了11位隐性电平，那么该节点就会认为总线当前处于空闲状态，它就会立即向总线上发送自己的报文。 至于为什么连续出现11位隐性电平，就可以判定+总线处于空闲状态，这个问题可以结合CAN协议的帧结构来进行理解。</p>
</blockquote>
<p>在多主工作方式下：</p>
<ul>
<li><p>最先向总线发送消息的节点获得总线的发送权；</p>
</li>
<li><p>当多个节点同时向总线发送消息时，所发送消息的优先权高的那个节点获得总线的发送权。</p>
<blockquote>
<p>例如：Node_A和Node_B同时向总线发送各自的消息Msg_1和Msg_2，如果Msg_1的优先级比Msg_2高，那么Node_A就获得了总线的发送权。</p>
</blockquote>
</li>
</ul>
<h3 id="4-2-2-非破坏性位仲裁机制"><a href="#4-2-2-非破坏性位仲裁机制" class="headerlink" title="4.2.2 非破坏性位仲裁机制"></a><strong><strong>4.2.2 非破坏性位仲裁机制</strong></strong></h3><p>在CAN协议中，所有的消息都以固定的帧格式发送。当多个节点同时向总线发送消息时，对各个消息的标识符（即ID号）进行 <strong>逐位仲裁</strong> ，如果某个节点发送的消息仲裁获胜，那么这个节点将获取总线的发送权，仲裁失败的节点则立即停止发送并转变为监听（接收）状态。</p>
<blockquote>
<p>例如：Node_A和Node_B同时向总线发送各自的消息Msg_1和Msg_2，那么对Msg_1的ID号ID_1和Msg_2的ID号ID_2进行逐位仲裁，如果仲裁结果是：ID_1的优先级比ID_2高，那么Msg_1在仲裁中获胜，于是发出Msg_1这条报文的节点Node_A就获得了总线的发送权。同时，Msg_2在仲裁中失败，于是Node_B就转换到监听总线电平的状态。</p>
</blockquote>
<p>这种仲裁机制既 <strong>不会造成已发送数据的延迟</strong> ，也<strong>不会破坏已经发送的数据</strong>，所以称为非破坏性仲裁机制。</p>
<p><a href="https://blog.csdn.net/weixin_40528417/article/details/79534483">https://blog.csdn.net/weixin_40528417/article/details/79534483</a></p>
<h3 id="4-2-3-系统的柔性"><a href="#4-2-3-系统的柔性" class="headerlink" title="4.2.3 系统的柔性"></a><strong><strong>4.2.3 系统的柔性</strong></strong></h3><p>CAN总线上的节点 <strong>没有“地址”的概念</strong> ，因此在总线上增加节点时，不会对总线上已有节点的软硬件及应用层造成影响。</p>
<h3 id="4-2-4-通信速度"><a href="#4-2-4-通信速度" class="headerlink" title="4.2.4 通信速度"></a><strong><strong>4.2.4 通信速度</strong></strong></h3><p>在同一条CAN线上，所有节点的通信速度（位速率）必须相同，如果两条不同通信速度总线上的节点想要实现信息交互，必须通过网关。</p>
<blockquote>
<p>例如：汽车上一般有两条CAN总线：500kbps的驱动系统CAN总线和125kbps的舒适系统CAN总线，如果驱动系统CAN总线上的发动机节点要把自己的转速信息发送给舒适系统CAN总线上的转速表节点，那么这两条总线必须通过网关相连。</p>
</blockquote>
<h3 id="4-2-5-数据传输方式"><a href="#4-2-5-数据传输方式" class="headerlink" title="4.2.5 数据传输方式"></a><strong><strong>4.2.5 数据传输方式</strong></strong></h3><p>CAN总线可以实现一对一，一对多以及广播的数据传输方式，这依赖于验收滤波技术。</p>
<h3 id="4-2-6-远程数据请求"><a href="#4-2-6-远程数据请求" class="headerlink" title="4.2.6 远程数据请求"></a><strong><strong>4.2.6 远程数据请求</strong></strong></h3><p>某个节点Node_A可以通过发送“遥控帧”到总线上的方式，请求某个节点Node_B来发送由该遥控帧所指定的报文。</p>
<h3 id="4-2-7-错误检测、错误通知、错误恢复功能"><a href="#4-2-7-错误检测、错误通知、错误恢复功能" class="headerlink" title="4.2.7 错误检测、错误通知、错误恢复功能"></a><strong><strong>4.2.7 错误检测、错误通知、错误恢复功能</strong></strong></h3><ul>
<li>所有的节点都可以检测出错误（错误检测功能）；</li>
<li>检测出错误的节点会立即通知总线上其它所有的节点（错误通知功能）；</li>
<li>正在发送消息的节点，如果检测到错误，会立即停止当前的发送，并在同时不断地重复发送此消息，直到该消息发送成功为止（错误恢复功能）。</li>
</ul>
<h3 id="4-2-8-故障封闭"><a href="#4-2-8-故障封闭" class="headerlink" title="4.2.8 故障封闭"></a><strong><strong>4.2.8 故障封闭</strong></strong></h3><p>节点能够判断错误的类型，判断是暂时性的数据错误（如噪声干扰）还是持续性的数据错误（如节点内部故障），如果判断是严重的持续性错误，那么节点就会切断自己与总线的联系，从而避免影响总线上其他节点的正常工作。</p>
<h2 id="4-3-CAN通信网络结构"><a href="#4-3-CAN通信网络结构" class="headerlink" title="4.3 CAN通信网络结构"></a><strong><strong>4.3 CAN通信网络结构</strong></strong></h2><h3 id="4-3-1-OSI基本参照模型"><a href="#4-3-1-OSI基本参照模型" class="headerlink" title="4.3.1 OSI基本参照模型"></a>4.3.1 OSI基本参照模型</h3><p>实际上，CAN总线网络底层只采用了OSI基本参照模型中的 <strong>数据链路层、传输层</strong> 。而在CAN网络高层仅采用了OSI基本参照模型的<strong>应用层。</strong></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699427783878.png" alt="1699427783878"></p>
<h3 id="4-3-2-CAN协议网络层次"><a href="#4-3-2-CAN协议网络层次" class="headerlink" title="4.3.2 CAN协议网络层次"></a>4.3.2 CAN协议网络层次</h3><p>在CAN协议中，ISO标准只对数据链路层和物理层做了规定。对于数据链路层和物理层的一部分，ISO11898和ISO11519-2的规定是相同，但是在物理层的PMD子层和MDI子层是不同的。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699427842349.png" alt="1699427842349"></p>
<p>在CAN总线，每一层网络中定义的事项如下：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699427852421.png" alt="1699427852421"></p>
<h2 id="4-4-CAN协议数据帧与遥控帧"><a href="#4-4-CAN协议数据帧与遥控帧" class="headerlink" title="4.4 CAN协议数据帧与遥控帧"></a>4.4 CAN协议数据帧与遥控帧</h2><h3 id="4-4-1-CAN-协议中的帧"><a href="#4-4-1-CAN-协议中的帧" class="headerlink" title="4.4.1 CAN 协议中的帧"></a>4.4.1 CAN 协议中的帧</h3><p>在了解<a href="https://so.csdn.net/so/search?q=CAN%E6%80%BB%E7%BA%BF&amp;spm=1001.2101.3001.7020">CAN总线</a>的通信机制之前，首先需要了解CAN协议中五种类型的帧结构：</p>
<ul>
<li>数据帧</li>
<li>遥控帧</li>
<li>错误帧</li>
<li>过载帧</li>
<li>帧间隔</li>
</ul>
<h3 id="4-4-2-数据帧与遥控帧"><a href="#4-4-2-数据帧与遥控帧" class="headerlink" title="4.4.2 数据帧与遥控帧"></a>4.4.2 数据帧与遥控帧</h3><p>在CAN协议中，数据帧和遥控帧有着诸多相同之处，所以，在这里，我们将数据帧和遥控帧放在一起来讲。</p>
<p>顾名思义，所谓数据帧，就是包含了我们要传输的<strong>数据</strong>的帧，其作用当然也就是承载发送节点要传递给接收节点的数据。</p>
<p>而遥控帧的作用可以描述为：请求其它节点发出与本遥控帧具有相同ID号的数据帧。</p>
<blockquote>
<p>比如：在某一个时刻，节点Node_A向总线发送了一个ID号为ID_2的遥控帧，那么就意味着Node_A请求总线上的其他节点发送ID号为ID_2的数据帧。</p>
<p>节点Node_B能够发出ID号为ID_2的数据帧，那么Node_B就会在收到Node_A发出的遥控帧之后，立刻向总线上发送ID号为ID_2的数据帧。</p>
</blockquote>
<p><strong><em>数据帧</em></strong><br> 的帧结构如下图所示，包含七个段： <strong>帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束</strong> 。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428188563.png" alt="1699428188563"></p>
<p><strong><em>遥控帧</em></strong><br> 相比于数据帧，从帧结构上来看，只是 <strong>少了数据段</strong> ，包含六个段：<strong>帧起始、仲裁段、控制段、CRC段、ACK段、帧结束。</strong></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428208177.png" alt="1699428208177"></p>
<p>数据帧和遥控帧都分为<strong>标准帧（CAN2.0A）</strong>和<strong>扩展帧（CAN2.0B）</strong>两种结构。</p>
<p>遥控帧相比于数据帧除了<strong>缺少数据段</strong>之外， <strong>遥控帧的RTR位恒为隐性1，数据帧的RTR位恒为显性0</strong> 。</p>
<h4 id="4-4-2-1-帧起始"><a href="#4-4-2-1-帧起始" class="headerlink" title="4.4.2.1 帧起始"></a><strong><strong>4.4.2.1 帧起始</strong></strong></h4><p>帧的最开始的一位是 <strong>帧起始</strong> ，也叫SOF（Start Of Frame）， <strong>SOF恒为显性位</strong> ，即逻辑 0 。帧起始表示CAN_H 和 CAN_L上有了电位差，也就是说，一旦总线上有了SOF就表示总线上开始有报文了。</p>
<h4 id="4-4-2-2-仲裁段"><a href="#4-4-2-2-仲裁段" class="headerlink" title="4.4.2.2 仲裁段"></a><strong><strong>4.4.2.2 仲裁段</strong></strong></h4><p> <strong>仲裁段是用来判定一帧报文优先级的依据，仲裁段中的ID号也是实现报文过滤机制的基础</strong> 。仲裁段由以下几个部分组成，</p>
<p>数据帧仲裁段：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428441065.png" alt="1699428441065"></p>
<p>遥控帧仲裁段：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428453749.png" alt="1699428453749"></p>
<p>可以看到相比于数据帧仲裁段RTR位恒为显性0，遥控帧仲裁段的RTR位恒为隐性1。</p>
<h5 id="4-4-2-2-1仲裁过程"><a href="#4-4-2-2-1仲裁过程" class="headerlink" title="4.4.2.2.1仲裁过程"></a><strong><strong>4.4.2.2.1仲裁过程</strong></strong></h5><p>在CAN总线通信中，有一种 <strong>回读机制</strong> ：指的是节点在向总线上发送报文的过程中，同时也对总线上的二进制位进行“回读”。通过这种机制，节点就可以判断出<strong>本节点发出的二进制位</strong>与<strong>总线上当前的二进制位</strong>是否一致。</p>
<p>还有一种叫做 <strong>线与机制</strong> ：指的是在总线上， <strong>显性位能够覆盖隐性位</strong> 。</p>
<blockquote>
<p>举个例子：在某一个时刻，节点Node_A向总线发送了一个显性位0，Node_B向总线发送了一个隐性位1，那么在该时刻，总线上的电平为显性0。</p>
</blockquote>
<p>下面将以<strong>标准数据帧</strong>的一个例子来分析CAN总线的 <strong>非破坏性逐位仲裁机制</strong> 。</p>
<p>一条CAN总线上有Node_A 和 Node_B两个节点，在<strong>总线空闲</strong>时，总线上为 <strong>隐性电平</strong> ，就在这个时候Node_A 和 Node_B 这两个节点同时向总线上发送数据，如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428640425.png" alt="1699428640425"></p>
<p>从图中可以看出，在Node_A 和 Node_B 传输数据前，总线处于空闲状态，为隐性电平1，这也就意味着，此时总线上的任意节点都可以向总线发送数据。</p>
<p>在某一时刻，Node_A 和Node_B两个节点同时向总线上发送数据。按照</p>
<p> <strong>线与机制</strong> ，总线上的电位为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>节点/ID号</th>
<th>ID10</th>
<th>ID9</th>
<th>ID8</th>
<th>ID7</th>
<th>ID6</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node-A</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
<tr>
<td>Node-B</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>总线</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>在Node_A和Node_B两个节点向总线发送数据时，他们同时回读总线上的电平。从图中我们可以看到，Node_A 和Node_B的ID10 、ID9、ID8电位相同，因此这两个节点从总线上听到的电位与他们自己发出的电位也相同，这个时候还没有分出胜负。</p>
<p>当Node_B回读总线上的 ID7 这一位时，发现总线上的电平跟它自己发送到总线上的不一样，此时，Node_B知道自己在争夺总线的仲裁中失败了，那么它主动地转换为接收状态，不再发出信息。</p>
<p>于是在此之后，总线上的电平和Node_A发出的电平一致，也就是说，Node_A占据了总线的发送权。</p>
<p>通过上面的分析我们可以看到，在整个仲裁过程中：</p>
<ul>
<li>在Node_A获取总线的发送权之后，Node_A接着发送自己的Msg_A，因此在竞争总线的过程中不会对Msg_A的传输造成延时；</li>
<li>在两个节点竞争总线的过程中，不会破坏Msg_A;</li>
</ul>
<p>正是由于上面的两点，才称之为<strong>非破坏性仲裁机制。</strong></p>
<blockquote>
<p>Tips:</p>
<p>通过上面仲裁过程的分析，我们可以解释CAN总线通信的三个特点：</p>
<p>1）多主控制方式：只要总线空闲，总线上的任意节点都可以向总线上发送数据，直到节点在仲裁中一个个失败，最后只留下一个节点获得总线的发送权。</p>
<p>2）非破坏性仲裁机制：仲裁段逐位总裁，依靠<strong>回读机制、线与机制</strong>得以实现。</p>
<p>3）半双工通信：所谓半双工通信，指的是节点不能在自己发送报文的时候，同时接收其他节点发送来的报文。这是显然的，一个节点正在发送报文时，已经占据了总线的发送权，其他节点肯定不能向总线上发送报文。</p>
</blockquote>
<p>看一个CAN报文发送的实例，CAN总线上有四个节点：Node_A、Node_B、Node_C、Node_D。发送的报文的ID号分别为5、7、3、6.</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428658091.png" alt="1699428658091"></p>
<h5 id="4-4-2-2-2-仲裁段中的RTR，SRR和IDE位"><a href="#4-4-2-2-2-仲裁段中的RTR，SRR和IDE位" class="headerlink" title="4.4.2.2.2 仲裁段中的RTR，SRR和IDE位"></a><strong><strong>4.4.2.2.2 仲裁段中的RTR，SRR和IDE位</strong></strong></h5><p>通过上面标准数据帧的仲裁过程分析，我们已经理解了CAN总线的仲裁机制。但同时也注意到仲裁段除了ID号之外，还有其他的位。</p>
<p><strong><strong>1）RTR位：</strong></strong></p>
<p>Tranmission Request Bit （远程发送请求位）。<strong>在数据帧中，RTR位恒为显性位0，在遥控帧中，恒为隐性1。</strong></p>
<blockquote>
<p>Tips: 这么做的原因是保证数据帧优先级高于遥控帧。比如：在某一时刻t，节点Node_A发出了ID号为ID_2遥控帧报文来请求总线上的其它节点发出ID号为ID_2的数据帧报文。但是就在同一时刻t，节点Node_B发出了ID号为ID_2的数据帧报文。这个时候怎么办呢，显然依靠ID号不能仲裁出这两帧报文（一个遥控帧，一个数据帧，ID号相同）谁能占据总线的发送权，这种情况下，RTR位就起作用了，由于RTR在数据帧中恒为显性0，在遥控帧中恒为隐性1，所以在ID号相同的情况下，一定是数据帧仲裁获胜。这就解释了 <strong>RTR位的作用：在ID号相同的情况下，保证数据帧的优先级高于遥控帧。</strong></p>
</blockquote>
<p><strong><strong>2）SRR位</strong></strong></p>
<p>Substitutes for Remote Requests Bit（替代远程请求位）， <strong>在扩展帧（数据帧或遥控帧）中，SRR恒为隐性位1</strong> ，并且可以发现，扩展帧的隐性SRR位正好对应标准帧的显性RTR位，这就解释了  <strong>SRR位的作用：在前11位ID号相同的情况下，标准数据帧的优先级高于扩展数据帧</strong> ；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428855183.png" alt="1699428855183"></p>
<p><strong><strong>3）IDE位</strong></strong></p>
<p>全称：Identifier Extension Bit（标识符扩展位）。 <strong>在扩展帧中恒为隐性1，在标准帧中，IDE位于控制段，且恒为显性0</strong> 。且扩展帧IDE位和标准帧IDE位位置对应，这就保证了：  <strong>在前11位ID号相同的情况下，标准遥控帧的优先级一定高于扩展遥控帧</strong> 。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428869501.png" alt="1699428869501"></p>
<p><strong>总结：</strong> 在ID号前11位相同的情况下：</p>
<ul>
<li>RTR：保证数据帧优先级高于遥控帧；</li>
<li>SRR ：保证标准数据帧的优先级高于扩展数据帧。</li>
<li>IDE ：保证标准遥控帧的优先级高于扩展遥控帧。</li>
</ul>
<h5 id="4-4-2-2-3-报文过滤"><a href="#4-4-2-2-3-报文过滤" class="headerlink" title="4.4.2.2.3 报文过滤"></a><strong><strong>4.4.2.2.3 报文过滤</strong></strong></h5><p>在CAN总线中<strong>没有地址</strong>的概念，CAN总线是通过<strong>报文ID</strong>来实现收发数据的。CAN节点上都会有一个 <strong>验收滤波ID表</strong> ，其位于CAN节点的验收滤波器中，如果总线上的报文的ID号在某个节点的验收滤波ID表中，那么这一帧报文就能通过该节点验收滤波器的验收，该节点就会接收这一帧报文。</p>
<blockquote>
<p>比如：Node_A发送了一帧ID号为ID_1的报文Msg_1，Node_B的验收滤波ID表中恰好有ID_1，于是乎Msg_1就会被Node_B接收。</p>
<p>Tips:</p>
<p>报文过滤机制体现了CAN通信的两条特点： 1）一对一、组播和广播 2）系统的柔性：正是因为CAN总线上收发报文是基于报文ID实现的，所以总线上添加节点时不会对总线上已有的节点造成影响。</p>
</blockquote>
<h4 id="4-4-2-3-控制段"><a href="#4-4-2-3-控制段" class="headerlink" title="4.4.2.3 控制段"></a><strong><strong>4.4.2.3 控制段</strong></strong></h4><p>数据帧和遥控帧的控制段结构相同：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428891064.png" alt="1699428891064"></p>
<ul>
<li>标准帧中IDE位对应扩展帧中的IDE位，保证在前11位ID号相同的情况下，标准帧的优先级一定高于扩展帧；</li>
<li>然后是保留位r0和r1（扩展帧），保留位r0和r1必须以显性电平发送，但是接受方可以接受显性、隐性及其任意组合的电平；</li>
<li>最后是4个字节的 <strong>DLC</strong> （DLC3、DLC2、DLC1、DLC0）代表数据长度，指示了 <strong>数据段中的字节数</strong> 。对于没有数据段的遥控帧，DLC表示该遥控帧对应的数据帧的数据段的字节数。</li>
</ul>
<h4 id="4-4-2-4-数据段"><a href="#4-4-2-4-数据段" class="headerlink" title="4.4.2.4 数据段"></a><strong><strong>4.4.2.4 数据段</strong></strong></h4><p>数据段可以包含0~8个字节的数据，从MSB（最高位）开始输出。</p>
<h4 id="4-4-2-5-CRC段"><a href="#4-4-2-5-CRC段" class="headerlink" title="4.4.2.5 CRC段"></a><strong><strong>4.4.2.5 CRC段</strong></strong></h4><p>CRC段包含CRC校验序列和CRC界定符</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428900186.png" alt="1699428900186"></p>
<p><strong>CRC校验序列</strong>是根据多项式生成的CRC值， <strong>其计算范围包括：帧起始、仲裁段、控制段和数据段。CRC界定符恒为隐性1</strong> 。</p>
<h4 id="4-4-2-6-ACK段"><a href="#4-4-2-6-ACK段" class="headerlink" title="4.4.2.6 ACK段"></a><strong><strong>4.4.2.6 ACK段</strong></strong></h4><p>ACK段包含<strong>ACK槽</strong>和<strong>ACK界定符</strong>两个位。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428911314.png" alt="1699428911314"></p>
<ul>
<li><strong>发送节点</strong>在ACK段发送 <strong>两个隐性位</strong> ，即发送方发出的报文中ACK槽为隐性1；</li>
<li><strong>接收节点</strong>在接收到正确的报文之后会在ACK槽发送显性位0，通知发送节点正常接收结束。所谓接收到正确的报文指的是接收到的报文没有填充错误、格式错误、CRC错误。</li>
</ul>
<blockquote>
<p>Tips: 我们以标准数据帧为例来分析 <strong>ACK段的工作方式</strong> ：如图所示，Node_A为发送节点，Node_B为接收节点。Node_A在ACK段发送两个隐性位1。Node_B正确接收到这一报文后，在ACK段的ACK槽中填充了一个显性位0。注意，这个时候 <strong>Node_A回读到的总线上的额电平为显性0</strong> ，于是这个时候，Node_A就知道自己发出去的报文至少有一个节点正确接收了。</p>
</blockquote>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428924845.png" alt="1699428924845"></p>
<h4 id="4-4-2-7-帧结束"><a href="#4-4-2-7-帧结束" class="headerlink" title="4.4.2.7 帧结束"></a><strong>4.4.2.7 帧结束</strong></h4><p>帧结束段表示该帧报文的结束，由7个隐性位构成。</p>
<h2 id="4-5-CAN协议错误帧"><a href="#4-5-CAN协议错误帧" class="headerlink" title="4.5 CAN协议错误帧"></a>4.5 CAN协议错误帧</h2><h3 id="4-5-1-错误帧的帧结构"><a href="#4-5-1-错误帧的帧结构" class="headerlink" title="4.5.1 错误帧的帧结构"></a><strong><strong>4.5.1 错误帧的帧结构</strong></strong></h3><p>在发送和接收报文时，总线上的节点如果检测出了错误，那么该节点就会发送错误帧，通知总线上的节点，自己出错了。错误帧由<strong>错误标志</strong>和<strong>错误界定符</strong>两个部分组成。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347241667.png" alt="1701347241667"></p>
<ul>
<li>主动错误标志：6个连续的显性位；</li>
<li>被动错误标志：6个连续的隐性位；</li>
<li>错误界定符：8个连续的隐性位。</li>
</ul>
<p>可以看到在错误标志之后还有0~6位的错误标志重叠，这一段最低有0个位，最多有6个位，关于这一段是怎么形成的，将在下文中解释。</p>
<h3 id="4-5-2-错误检测"><a href="#4-5-2-错误检测" class="headerlink" title="4.5.2 错误检测"></a><strong><strong>4.5.2 错误检测</strong></strong></h3><h4 id="4-5-2-1-位填充原则"><a href="#4-5-2-1-位填充原则" class="headerlink" title="4.5.2.1 位填充原则"></a><strong><strong>4.5.2.1 位填充原则</strong></strong></h4><p>在了解<a href="https://so.csdn.net/so/search?q=CAN%E6%80%BB%E7%BA%BF&amp;spm=1001.2101.3001.7020">CAN总线</a>中的错误检测之前，首先需要了解什么是位填充。CAN协议中规定，当<strong>相同极性的电平持续五位</strong>时，则 <strong>添加一个极性相反的位</strong> 。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347301950.png" alt="1701347301950"></p>
<ul>
<li>对于<strong>发送节点</strong>而言：在发送<strong>数据帧</strong>和<strong>遥控帧</strong>时，对于<strong>SOF~CRC(除去CRC界定符)</strong> 之间的位流，相同极性的电平如果持续5位，那么在下一个位插入一个与之前5位反型的电平；</li>
<li>对于<strong>接收节点</strong>而言：在接收<strong>数据帧</strong>和<strong>遥控帧</strong>时，对于<strong>SOF~CRC(除去CRC界定符)</strong>之间的位流，相同极性的电平如果持续5位，那么需要删除下一位再接收。</li>
</ul>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347321170.png" alt="1701347321170"></p>
<blockquote>
<p>Tips: 注意：填充位的添加和删除是由发送节点和接收节点完成的，CAN-BUS只负责传输，不会操纵信号。</p>
</blockquote>
<h4 id="4-5-2-2-错误的种类"><a href="#4-5-2-2-错误的种类" class="headerlink" title="4.5.2.2 错误的种类"></a><strong><strong>4.5.2.2 错误的种类</strong></strong></h4><p>在CAN总线通信中，一共有五种错误：</p>
<ul>
<li>位错误</li>
<li>ACK错误</li>
<li>填充错误</li>
<li>CRC错误</li>
<li>格式错误</li>
</ul>
<h5 id="4-5-2-2-1-位错误（Bit-Check-Error）"><a href="#4-5-2-2-1-位错误（Bit-Check-Error）" class="headerlink" title="4.5.2.2.1 位错误（Bit Check Error）"></a><strong><strong>4.5.2.2.1 位错误（Bit Check Error）</strong></strong></h5><p>节点将自己发送到总线上的电平与同时从总线上回读到的电平进行比较，如果发现二者不一致，那么这个节点就会检测出一个位错误。</p>
<p>实际上所谓“发出的电平与从总线上回读的电平不一致”，指的就是<strong>节点向总线发出隐性位，却从总线上回读到显性位</strong>或者<strong>节点向总线发出显性位，却从总线上回读到隐性位</strong>这两种情况。</p>
<blockquote>
<p>Tips: 有三种例外情况不属于位错误：</p>
<ul>
<li>在 <strong>仲裁区</strong> ，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示该节点仲裁失败；</li>
<li>在 <strong>ACK槽</strong> ，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示，该节点当前发送的这一帧报文至少被一个其它节点正确接收；</li>
<li><strong>该节点发送被动错误标志</strong> ，节点Node_A向总线发送连续六个隐性位（被动错误标志）却回读到显性位，不认为是位错误。因为被动错误标志是六个连续的隐性位，所以在总线上按照线与机制，有可能这六个连续隐性位被其它节点发送的显性电平“吃掉”；</li>
</ul>
</blockquote>
<h5 id="4-5-2-2-2-ACK错误（Acknowledgment-Error）"><a href="#4-5-2-2-2-ACK错误（Acknowledgment-Error）" class="headerlink" title="4.5.2.2.2 ACK错误（Acknowledgment Error）"></a><strong><strong>4.5.2.2.2 ACK错误（Acknowledgment Error）</strong></strong></h5><p>按照CAN协议的规定，在一帧报文（数据帧或者遥控帧）发出之后，如果接收节点Node_B成功接收了该帧报文，那么接收节点Node_B就要在该帧报文ACK槽对应的时间段内向总线上发送一个显性位来应答发送节点Node_A。这样发送节点Node_A就会在ACK槽时间段内从总线上回读到一个显性位。因此：</p>
<p>当发送节点Node_A在 <strong>ACK槽时间段内没有回读到显性位</strong> ，那么发送节点Node_A就会检测到一个ACK应答错误。这表示没有一个节点成功接收该帧报文。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347344846.png" alt="1701347344846"></p>
<h5 id="4-5-2-2-3-填充错误（Fill-Error）"><a href="#4-5-2-2-3-填充错误（Fill-Error）" class="headerlink" title="4.5.2.2.3 填充错误（Fill Error）"></a><strong><strong>4.5.2.2.3 填充错误（Fill Error）</strong></strong></h5><p>在需要执行<strong>位填充原则</strong>的帧段（数据帧遥控帧的SOF~CRC序列），检测到 <strong>连续六个同性位</strong> ，则检测到一个填充错误。</p>
<h5 id="4-5-2-2-4-CRC错误"><a href="#4-5-2-2-4-CRC错误" class="headerlink" title="4.5.2.2.4 CRC错误"></a><strong><strong>4.5.2.2.4 CRC错误</strong></strong></h5><p>发送节点Node_A在发送数据帧或者遥控帧时，会计算出该帧报文的CRC序列。接收节点Node_B在接收报文时也会执行相同的CRC算法，如果接收节点Node_B计算出的CRC序列值与发送节点Node_A发来的CRC序列值不一致，那么接收节点就检测到一个CRC错误。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347357789.png" alt="1701347357789"></p>
<h5 id="4-5-2-2-5-格式错误"><a href="#4-5-2-2-5-格式错误" class="headerlink" title="4.5.2.2.5 格式错误"></a><strong><strong>4.5.2.2.5 格式错误</strong></strong></h5><p>在一帧报文发送时，如果在必须发送预定值的区域内检测到了非法值，那么就检测到一个格式错误。</p>
<p>CAN报文中，有预定值的区域包括：</p>
<ul>
<li>数据帧和遥控帧的 <strong>CRC界定符、ACK界定符、EOF</strong> ；</li>
<li><strong>错误帧界定符</strong></li>
<li><strong>过载帧界定符</strong></li>
</ul>
<h3 id="4-5-3-错误通知"><a href="#4-5-3-错误通知" class="headerlink" title="4.5.3 错误通知"></a><strong><strong>4.5.3 错误通知</strong></strong></h3><p>上一节中，讲到CAN通信中有五种错误，并且介绍了在什么情况下能够检测到这几种错误，在检测到错误之后，检测到错误的节点就要发送错误帧到总线上来通知总线上的其他节点。错误帧有的带有 <strong>主动错误标志</strong> ，有的带有 <strong>被动错误标志</strong> ，而且错误标志重叠部分的字节数也不一样，那么问题就来了：</p>
<ul>
<li>什么情况下发送带有主动错误标志的错误帧；</li>
<li>什么情况下发送带有被动错误标志的错误帧；</li>
<li>在哪个时间点发送错误帧；</li>
<li>错误标志重叠部分是怎样形成的；</li>
</ul>
<h3 id="4-5-3-1-节点错误状态"><a href="#4-5-3-1-节点错误状态" class="headerlink" title="4.5.3.1 节点错误状态"></a><strong><strong>4.5.3.1 节点错误状态</strong></strong></h3><p>按照CAN协议的规定，CAN总线上的节点始终处于以下三种状态之一。</p>
<ul>
<li>主动错误状态</li>
<li>被动错误状态</li>
<li>总关闭状态</li>
</ul>
<p>当满足一定的条件时，节点可以从一种状态转换为另外一种状态。</p>
<blockquote>
<p>Tips: 需要注意的是：</p>
<ul>
<li>处于 <strong>主动错误状态</strong> ，表示该节点具备发出<strong>主动错误标志</strong>的能力;</li>
<li>处于 <strong>被动错误状态</strong> ，表示节点具备发出<strong>被动错误标志</strong>的能力。</li>
</ul>
</blockquote>
<p>1）主动错误状态</p>
<ul>
<li>节点处于主动错误状态 <strong>可以正常通信</strong> ；</li>
<li>处于主动错误状态的节点（可能是接收节点也可能是发送节点）在检测出错误时， <strong>发出主动错误标志</strong> 。</li>
</ul>
<p>2）被动错误状态</p>
<ul>
<li>节点处于被动错误状态 <strong>可以正常通信</strong> ；</li>
<li>处于被动错误状态的节点（可能是接收节点也可能是发送节点）在检测出错误时， <strong>发出被动错误标志</strong> 。</li>
</ul>
<blockquote>
<p>Tips: 注意：这里说处于主动错误状态或被动错误状态的节点仍然可以正常通信，这里的<strong>正常通信</strong>指的是：节点仍然能够从总线上接收报文，也能够竞争总线获胜后向总线上发送报文。但是不代表接收的报文一定正确也不代表一定能正确的发送报文。</p>
</blockquote>
<p>3）总线关闭状态</p>
<ul>
<li>节点处于总线关闭状态，那么该节点<strong>不能收发</strong>报文；</li>
<li>处于总线关闭状态的节点，只能一直等待，在满足一定条件的时候，再次进入到 <strong>主动错误状态</strong> 。</li>
</ul>
<h3 id="4-5-3-2-错误状态的转换"><a href="#4-5-3-2-错误状态的转换" class="headerlink" title="4.5.3.2 错误状态的转换"></a><strong><strong>4.5.3.2 错误状态的转换</strong></strong></h3><p>现在我们知道：</p>
<ul>
<li>处于主动错误状态的节点在检测到错误时会发送带有主动错误标志的错误帧；</li>
<li>处于被动错误状态的节点在检测到错误时会发送带有被动错误标志的错误帧。</li>
</ul>
<p>那么一个CAN节点在什么情况下处于主动错误状态，什么情况下处于被动错误状态呢？</p>
<p>根据CAN协议的规定，在CAN节点内，有两个计数器： <strong>发送错误计数器（TEC）和接收错误计数器（REC）</strong> 。</p>
<blockquote>
<p>Tips: 需要注意的是：这两个计数器计的不是收发报文的数量，也不是收发错误帧的数量。TEC和RCE计数值的变化，是根据下表的规定来进行的</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347372565.png" alt="1701347372565"></p>
</blockquote>
<p>CAN节点错误状态的转换，就是基于这两个计数器来进行的。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347382135.png" alt="1701347382135"></p>
<p>可以看出，节点错误状态的转换就是一个<strong>“量变”到“质变”的过程：</strong></p>
<h4 id="1-主动错误状态"><a href="#1-主动错误状态" class="headerlink" title="1) 主动错误状态"></a><strong>1) 主动错误状态</strong></h4><p><strong>最开始TCE和REC都小于127时，就处于主动错误状态。</strong></p>
<p>在这一状态下，节点检测到一个错误就会发送带有<strong>主动错误标志</strong>的 <strong>错误帧</strong> ，因为主动错误标志是 <strong>连续六个显性位</strong> ，所以这个时候主动错误标志将会“覆盖”掉总线上其它节点的发送，而之前在CAN总线上传输的报文就被这“六个连续显性位”破坏掉了。</p>
<p> <strong>如果发出主动错误帧的节点是发送节点</strong> ，这个情况下就相当于：刚刚发送的那一帧报文我发错了，现在我破坏掉它（发送主动错误帧），你们不管收到什么都不算数；</p>
<p> <strong>如果发出主动错误帧的节点是接收节点</strong> ，这个情况就相当于：刚刚我收报文的时候发现了错误，不管你们有没有发现这个错误，我现在主动站出来告诉大家这个错误，并把这一帧报文破坏掉（发送主动错误帧），刚才你们收到的东西不管对错都不算数了。</p>
<blockquote>
<p>Tips: 处于主动错误状态，说明这个节点目前是比较可靠的，出现错误的原因可能不是它本身的问题，即刚刚检测到的错误可能不仅仅只有它自己遇到，正是因为这一点，整个总线才相信它报告的错误，允许它破坏掉发送中的报文，也就是将这一次的发送作废。</p>
</blockquote>
<h4 id="2）被动错误状态"><a href="#2）被动错误状态" class="headerlink" title="2）被动错误状态"></a><strong><strong>2）被动错误状态</strong></strong></h4><p>在这一状态下，节点Node_A检测到一个错误就会发送带有被动错误标志的错误帧，因为被动错误标志是连续六个隐性位，所以这个时候总线上正在传输的报文位流不会受到该被动错误帧的影响，其它的节点该发送的发送，该接收的接收，没人搭理这个发送被动错误帧的节点Node_A。</p>
<p>如果发出被动错误帧的节点Node_A为报文的发送节点，那么在发送被动错误帧之后，刚刚正在发送的报文被破坏，并且Node_A不能在错误帧之后随着<strong>连续发送</strong>刚刚发送失败的那个报文。随之而来的是 <strong>帧间隔</strong> ，并且连带着8位隐性位的 <strong>“延迟传送”</strong>段；这样总线电平就呈现出连续11位隐性位，总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争。此时如果Node_A能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。这种机制的目的正是为了让其它正常节点（处于主动错误）优先使用总线。</p>
<blockquote>
<p>Tips: 处于 <strong>被动错误状态</strong> ，说明这个节点目前是不太可靠的，出现错误的原因可能是它本身的问题，即刚刚检测到的错误可能仅仅只有它自己遇到，正是因为这一点，整个总线才不信任它报告的错误，从而只允许它发送六个连续的隐性位，这样它才不会拖累别人。</p>
</blockquote>
<h4 id="3）总线关闭状态"><a href="#3）总线关闭状态" class="headerlink" title="3）总线关闭状态"></a><strong><strong>3）总线关闭状态</strong></strong></h4><p>如果一个处于被动错误状态的节点，仍然多次发送被动错误帧，那么势必导致 <strong>TEC ＞ 255</strong> ，这样就处于 <strong>总线关闭状态</strong> 。</p>
<p>在总线关闭状态下的节点Node_A不能向总线上发送报文，也不能从总线上接收报文，整个节点脱离总线。等到检测到128次11个连续的隐性位时，TEC和REC置0，重新回到主动错误状态。</p>
<p>按照我的理解这个所谓“检测到128次11个连续隐性位”其实就是让这个节点隔离一段时间冷静下，因为它一旦处于总线关闭状态，就不会和总线有任何的联系，这个时候只要它计算时间等于达到传送128次11个连续隐性位所用的时间，就可以重新连到总线上。</p>
<blockquote>
<p>Tips: 处于总线关闭状态说明，这个节点目前挂掉了，总线先把它踢开，这样它才不会拖累别人，等到它冷静一段时间之后再回到总线上。</p>
</blockquote>
<h3 id="4-5-3-3-错误帧的发送"><a href="#4-5-3-3-错误帧的发送" class="headerlink" title="4.5.3.3 错误帧的发送"></a><strong><strong>4.5.3.3 错误帧的发送</strong></strong></h3><p>在检测到错误之后，什么时候发送错误帧呢？</p>
<p>按照CAN协议的规定：</p>
<ul>
<li>位错误、填充错误、格式错误、ACK错误。 <strong>在错误产生的那一位的下一位开始发送错误帧</strong> 。</li>
<li>CRC错误 <strong>紧随ACK界定符后的位发送错误帧</strong> 。</li>
</ul>
<p>例子1：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347403665.png" alt="1701347403665"></p>
<p>（1）发送节点Node_A发送一个显性位，但是却从总线上听到一个隐形位，于是Node_A节点就会检测到一个位错误；</p>
<p>（2）Node_A检测到位错误之后，立即在下一位开始发送主动错误帧：6个连续显性位的主动错误标志+8个连续隐性位的错误界定符；</p>
<p>（3）对应Node_A发出的主动错误标志，总线上电平为6个连续显性位；</p>
<p>（4）接收节点Node_B和Node_C从总线上听到连续6个显性位，那么就会检测到一个填充错误，于是这两个节点都会发送主动错误帧；</p>
<p>（5）对应Node_B和Node_C发出的主动错误标志，总线电平又有6个连续显性电平，对应Node_B和Node_C发出的错误界定符，总线电平有8个连续的隐性电平。</p>
<p>（6）在间歇场之后，Node_A节点重新发送刚刚出错的报文。</p>
<p>例子2：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347408782.png" alt="1701347408782"></p>
<p>从上图中可以看出错误帧之中，错误标志重叠部分是怎样形成的，这个例子中，位错误的错误标志与填充错误的错误标志重叠两位，剩下的部分还有四位：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347420579.png" alt="1701347420579"></p>
<h2 id="4-6-CAN协议过载帧和帧间隔"><a href="#4-6-CAN协议过载帧和帧间隔" class="headerlink" title="4.6 CAN协议过载帧和帧间隔"></a><strong><strong>4.6 CAN协议过载帧和帧间隔</strong></strong></h2><h3 id="4-6-1-过载帧"><a href="#4-6-1-过载帧" class="headerlink" title="4.6.1 过载帧"></a><strong><strong>4.6.1 过载帧</strong></strong></h3><p>过载帧是<strong>接收节点</strong>向总线上其它节点报告自身<strong>接收能力达到极限</strong>的帧。上面这句话可以这样理解：接收节点Node_A接收报文的能力达到极限了，于是Node_A就会发出过载帧来告诉总线上的其它节点（包括发送节点），我接收节点Node_A已经没有能力处理你们发来的报文了。</p>
<p>过载帧包括：<strong>过载标志</strong>和<strong>过载界定符</strong>两个部分</p>
<ul>
<li><strong>过载标志</strong> ：连续6个显性位；</li>
<li><strong>过载界定符</strong> ：连续8个隐性位。</li>
<li>与错误帧类似，过载帧中有 <strong>过载帧重叠部分</strong> ，且形成过载重叠标志的原因与形成错误帧中的错误重叠标志的原因是相同的</li>
</ul>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347603850.png" alt="1701347603850"></p>
<p>对于过载帧的帧结构我们可以这样理解：接收节点Node_A达到接收极限时，就会发出过载帧到总线上，显然，过载标志的6个连续显性位会屏蔽掉总线上其它节点的发送，也就是说这个时候Node_A通过发送过载帧的方式来破坏其它节点的发送，这样在Node_A发送过载帧期间，其它节点就不能成功发送报文，于是就相当于把其它节点的发送推迟了，也就是说Node_A在其发送过载帧的这段时间得以“休息”。</p>
<p>有三种情况会引起过载帧：</p>
<ul>
<li>接收节点自身原因。接收节点由于某种原因需要延迟接收下一个数据帧或者遥控帧。</li>
<li>在帧间隔的间歇段的第一位和第二位检测到一个显性位（正常的间歇段都是隐性位）<br>帧间隔的间隔段本应是三个连续的隐性位，如果接收节点Node_A在间隔段检测到显性位，那么就意味着此时有报文发向接收节点Node_A，但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</li>
<li>CAN节点在<strong>错误界定符</strong>或<strong>过载界定符</strong>的第八位(最后一位)听到一个 <strong>显性位0</strong> ，节点会发送一个过载帧，且错误计数器不会增加。<br>接收节点Node_A在错误界定符和过载界定符的最后一位听到显性位，也意味着有报文发向Node_A，但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</li>
</ul>
<h3 id="4-6-2-帧间隔"><a href="#4-6-2-帧间隔" class="headerlink" title="4.6.2 帧间隔"></a><strong><strong>4.6.2 帧间隔</strong></strong></h3><p>帧间隔是用来隔离数据帧（或者遥控帧）的，也就是说，数据帧（或者遥控帧）通过插入<strong>帧间隔</strong>可以将本帧与先行帧（数据帧、遥控帧、错误帧、过载帧）分隔开来。</p>
<blockquote>
<p>Tips: 过载帧和错误帧的前面不能插入帧间隔。</p>
</blockquote>
<p>帧间隔有两种不同的形式：</p>
<p>主动错误状态的帧间隔：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347621761.png" alt="1701347621761"></p>
<p>被动错误状态的帧间隔：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347626515.png" alt="1701347626515"></p>
<p> <strong>间隔段</strong> ：连续三个隐性位；间隔段期间，所有节点不允许发送数据这或遥控帧，只要在这期间监听到显性位，接收节点就会发送过载帧。</p>
<p> <strong>空闲段</strong> ：连续隐性位，个数不一定，0个或者多个都可以。总线空闲的时间是任意长的，只要总线空闲，节点就可以竞争总线。</p>
<p> <strong>暂停段</strong> ：只有处于被动错误状态的节点在发送帧间隔的时候，才会在帧间隔中插入8个连续隐性位的暂停段。</p>
<p>暂停段，又叫做延迟传送段，为什么节点处于被动状态时会有这样一段呢。原因如下:首先，考虑主动错误状态的节点Node_A，发送主动错误标志之后，随之就要重新发送刚刚发送失败的报文，但是为了间隔开与前面刚刚发送的错误帧，<strong>总线在错误帧之后就会插入３个隐形位的帧间隔，在这３个隐形位期间，其它的节点不足以判定总线空闲（需要连续11个隐性位才能判定），所以Node_A仍然占据着总线的控制权，于是在帧间隔之后，Node_A能够接着发送报文。</strong>现在Node_A转入到被动错误状态了，说明它已经不是很可靠了，这个时候如果没有延迟传送段，在Node_A发出被动错误标志之后，它仍然能够在3位的帧间隔之后立即重新发送报文，这是不符合我们对被动错误状态的处理要求的当然也是不符合CAN协议的，于是乎对于发送出被动错误标志的节点，总线在帧间隔中加入了８个连续隐性位的延迟传送段，这样的3+8=11个连续隐性位。就能让Node_A在这个帧间隔期间失去对总线的控制权，从而优先保证其它正常(处于主动错误状态)节点能够使用总线，而不必等着一个已经不可靠的Node_A占据总线。</p>
<h2 id="4-7-CAN通信的位定时与同步"><a href="#4-7-CAN通信的位定时与同步" class="headerlink" title="4.7 CAN通信的位定时与同步"></a><strong><strong>4.7 CAN通信的位定时与同步</strong></strong></h2><h3 id="4-7-1-位定时"><a href="#4-7-1-位定时" class="headerlink" title="4.7.1 位定时"></a><strong><strong>4.7.1 位定时</strong></strong></h3><h4 id="4-7-1-1-比特率和波特率"><a href="#4-7-1-1-比特率和波特率" class="headerlink" title="4.7.1.1 比特率和波特率"></a><strong><strong>4.7.1.1 比特率和波特率</strong></strong></h4><p>1）</p>
<p> <strong>位速率</strong> :又叫做 <strong>比特率（bit rata）</strong> 、 <strong>信息传输率</strong> ，表示的是单位时间内，总线上传输的 <strong>信息量</strong> ，即 <strong>每秒能够传输的二进制位的数量</strong> ，单位是bit per second。</p>
<p>2）</p>
<p> <strong>波特率</strong> ：又叫做 <strong>传码率</strong> 、 <strong>信号传输率</strong> ，表示的是单位时间内传输的码元的数量，当两相调制时，一个码元用一个二进制位表示，此时波特率在数值上和比特率是一样的，<a href="https://so.csdn.net/so/search?q=CAN%E6%80%BB%E7%BA%BF&amp;spm=1001.2101.3001.7020">CAN总线</a>正是两项调制这种情况。</p>
<blockquote>
<p>Tips: <strong>比特率</strong>和<strong>波特率</strong>并不是一回事儿，这一定一定要牢记。</p>
</blockquote>
<h4 id="4-7-1-2-位时间"><a href="#4-7-1-2-位时间" class="headerlink" title="4.7.1.2 位时间"></a><strong><strong>4.7.1.2 位时间</strong></strong></h4><h5 id="4-7-1-2-1-位时间的概念"><a href="#4-7-1-2-1-位时间的概念" class="headerlink" title="4.7.1.2.1 位时间的概念"></a><strong><strong>4.7.1.2.1 位时间的概念</strong></strong></h5><p> <strong>位时间</strong> ：表示的是一个二进制位在总线上传输时所需要的时间。</p>
<p>所以：位速率 = 1 / 位时间</p>
<p>首先了解以下CAN总线系统中的两个时钟：<strong>晶振时钟周期</strong>和<strong>CAN时钟周期</strong></p>
<ul>
<li><strong>晶振时钟周期</strong> ：是由单片机振荡器的晶振频率决定的，指的是 <strong>振荡器每震荡一次所消耗的时间长度</strong> ，也是整个系统中最小的时间单位。</li>
<li><strong>CAN时钟周期</strong> ：CAN时钟是由系统时钟分频而来的一个时间长度值，实际上就是 <strong>一个时间份额Tq</strong> 。可以按照下面的公式计算：</li>
</ul>
<script type="math/tex; mode=display">
CAN时钟周期=2×晶振时钟周期×BRP</script><p>  <img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348103686.png" alt="1701348103686"></p>
<p>其中BRP叫做波特率预分频值（baudrate prescaler）。</p>
<h5 id="4-7-1-2-2-位时间的分段"><a href="#4-7-1-2-2-位时间的分段" class="headerlink" title="4.7.1.2.2 位时间的分段"></a><strong>4.7.1.2.2 位时间的分段</strong></h5><p>如上文所述，在CAN的位定时中，一个CAN时钟周期称为一个<strong>时间量子</strong> —  <strong>Tq</strong> 。<br>如下图所示：位时间分为四个段： <strong>同步段、传播段、相位缓冲段1、相位缓冲段2</strong> ，总共8~25个时间量子（Tq）。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348213567.png" alt="1701348213567"></p>
<p>1） <strong>同步段</strong> （Synchronization Segment）：</p>
<ul>
<li>长度固定，1个时间量子Tq；</li>
<li>一个位的传输从同步段开始；</li>
<li>同步段用于同步总线上的各个节点，一个位的跳边沿在此时间段内。</li>
</ul>
<p>2） <strong>传播段</strong> （Propagation Segment）：</p>
<ul>
<li>传播段用于补偿报文在总线和节点上传输时所产生的时间延迟；</li>
<li>传播段时长 ≥ 2 × 报文在总线和节点上传输时产生的时间延迟 ；</li>
<li>传播段时长可编程（1~8个时间量子Tq）。</li>
</ul>
<p>3） <strong>相位缓冲段1</strong> （Phase Buffer Segment1）：</p>
<ul>
<li>用于补偿节点间的晶振误差；</li>
<li>允许通过重同步对该段加长；</li>
<li>在这个时间段的末端进行总线状态的采样；</li>
<li>长度可编程（1~8个时间量子Tq）</li>
</ul>
<p>4） <strong>相位缓冲段2</strong> （Phase Buffer Segment2）：</p>
<ul>
<li>用于补偿节点间的晶振误差；</li>
<li>允许通过重同步对该段缩短；</li>
<li>长度可编程（1~8个时间量子Tq）</li>
</ul>
<p>于是</p>
<script type="math/tex; mode=display">
tBit=tSS+tPS+tPBS1+tPBS2</script><p>tBit:位时间</p>
<p>tSS:同步段时间</p>
<p>tPS:传播段时间</p>
<p>tPBS1:时间段1</p>
<p>tPBS2:时间段2</p>
<h3 id="4-7-2-CAN的同步机制"><a href="#4-7-2-CAN的同步机制" class="headerlink" title="4.7.2 CAN的同步机制"></a><strong><strong>4.7.2 CAN的同步机制</strong></strong></h3><p>在CAN通信中，有两种同步机制：<strong>硬同步</strong>与 <strong>重同步</strong> 。</p>
<h4 id="4-7-2-1-同步的规则"><a href="#4-7-2-1-同步的规则" class="headerlink" title="4.7.2.1 同步的规则"></a><strong><strong>4.7.2.1 同步的规则</strong></strong></h4><p>☆<strong>一个位时间</strong>内只允许 <strong>一种同步方式</strong> ，要么硬同步要么重同步；</p>
<p>☆ 任何一个从“隐性”到“显性”的<strong>下降沿</strong>都可以用于同步；</p>
<p>☆<strong>硬同步</strong>发生在报文的 <strong>SOF位</strong> ，所有接收节点调整各自当前位的同步段，使其位于发送的SOF位内；</p>
<p>☆<strong>重同步</strong>发生在一个报文 <strong>SOF位之外的其它段</strong> ，当下降沿落在了同步段之外时发生重同步；</p>
<p>☆ 在SOF到仲裁场发送的时间段内，如果有多个节点同时发送报文，那么这些发送节点对跳变沿不进行重同步</p>
<h4 id="4-7-2-2-硬同步"><a href="#4-7-2-2-硬同步" class="headerlink" title="4.7.2.2 硬同步"></a><strong><strong>4.7.2.2 硬同步</strong></strong></h4><p>硬同步发生在 <strong>SOF位</strong> ，所有<strong>接收节点</strong>调整各自 <strong>当前位的同步段</strong> ，<strong>调整宽度不限</strong></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348277220.png" alt="1701348277220"></p>
<p>（1）发送节点Node_A在发送SOF位时，SOF位的下降沿在SS段；</p>
<p>（2）这个时候接收节点Node_B发现自己当前位的SS段和发送节点SOF位的SS段不同步。也就是说当Node_A产生SOF位SS段时，Node_B的当前位的SS段已经在5个Tq之前产生了；</p>
<p>（3）于是接收节点Node_B强行将自己当前位的SS段拉到与SOF位的SS段同步。</p>
<h4 id="4-7-2-3-重同步"><a href="#4-7-2-3-重同步" class="headerlink" title="4.7.2.3 重同步"></a><strong><strong>4.7.2.3 重同步</strong></strong></h4><p>重同步发生在一个报文SOF位之外的其它位场内，当接收节点Node_B当前位的下降沿落在了发送节点Node_A当前位的同步段之外时发生重同步。</p>
<p>重同步会导致<strong>相位缓冲段1的延长</strong>或者 <strong>相位缓冲段2的缩短</strong> ，从而保证采样点的准确。</p>
<h5 id="4-7-2-3-1-PBS1延长"><a href="#4-7-2-3-1-PBS1延长" class="headerlink" title="4.7.2.3.1 PBS1延长"></a><strong><strong>4.7.2.3.1 PBS1延长</strong></strong></h5><p>发的晚（慢），收的早（块），导致PBS1延长。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348305070.png" alt="1701348305070"></p>
<p>如上图所示：</p>
<p>（1）发送节点Node_A比接收节点Node_B的时间慢了，也就是说Node_A当前位的ss段产生的时候，Node_B 当前位的ss段已经在2个Tq之前产生了；</p>
<p>（2）所以这个时候接收节点Node_B就将PBS1延长2个Tq的时间；</p>
<p>（3）于是这个时候Node_A当前位的采样点就和Node_B的采样点同步了。</p>
<h5 id="4-7-2-3-2-PBS2缩短"><a href="#4-7-2-3-2-PBS2缩短" class="headerlink" title="4.7.2.3.2 PBS2缩短"></a><strong><strong>4.7.2.3.2 PBS2缩短</strong></strong></h5><p>发的早（快），收的晚（慢），导致PBS2缩短。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348322758.png" alt="1701348322758"></p>
<p>如上图所示： </p>
<p>（1）发送节点Node_A当前位的SS段诞生2Tq时长之后，接收节点Node_B的当前位才产生SS段； </p>
<p>（2）于是，接收节点Node_B当前位的PBS2段缩短， </p>
<p>（3）这样就会导致接收节点Node_B的下一位能够提前2个Tq，从而Node_B的下一位采样点和Node_A下一位的采样点能够同步。</p>
<h5 id="4-7-2-3-3-同步跳转宽度"><a href="#4-7-2-3-3-同步跳转宽度" class="headerlink" title="4.7.2.3.3 同步跳转宽度"></a><strong><strong>4.7.2.3.3 同步跳转宽度</strong></strong></h5><p>在重同步时，有个 <strong>同步跳转宽度</strong> （SJW，Synchro Jump Width）的概念，表示的是 <strong>PBS1和PBS2重同步时允许跳转的最大宽度</strong> 。 同步跳转宽度必须满足以下几个条件：</p>
<ul>
<li>SJW必须小于PBS1和PBS2的最小值</li>
<li>SJW最大值不能超过4</li>
</ul>
<h3 id="4-7-3-位定时参数的确定"><a href="#4-7-3-位定时参数的确定" class="headerlink" title="4.7.3 位定时参数的确定"></a><strong><strong>4.7.3 位定时参数的确定</strong></strong></h3><p>位定时的参数主要涉及以下几个：</p>
<p>（1） <strong>位速率</strong> ：单位为bps、Kbps、Mbps</p>
<script type="math/tex; mode=display">
1Mbps=1000Kbps=1000000bps</script><p>（2）  <strong>位时间</strong> ：tBit，单位一般为纳秒(ns)</p>
<script type="math/tex; mode=display">
tBit=1/位速率</script><p>（3）  <strong>时间量子Tq</strong> ：</p>
<script type="math/tex; mode=display">
Tq=1/NBT</script><p>NBT 表示的是一个位时间tBit内包含Tq的个数。</p>
<p>（4）<strong>传输延迟时间tPTS</strong></p>
<p>CAN报文在CAN总线上的传输时，物理延迟包含两个部分：</p>
<ul>
<li>在CAN-BUS上传输造成的延迟</li>
<li>在节点上传输造成延迟</li>
</ul>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348371887.png" alt="1701348371887"></p>
<p>按照CAN通信协议的规定，补偿给传播延迟的时间长度要至少等于实际实际传播延迟时长的2倍，即：</p>
<script type="math/tex; mode=display">
tPTS≥2×tdel=2×(tdel+tBus)</script><p> <strong>需要注意的是</strong> ：</p>
<blockquote>
<p>Tips: 在CAN总线通信系统中是以时间量子Tq来度量时间的，所以如果延迟补偿时间tPTS = 3.1Tq，那么这个时候要取：tPTS = 4Tq。</p>
</blockquote>
<p>（5）<strong>相位缓冲段</strong> 相位缓冲段的时间长度分为两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (NBT-1-tPTS_Tq)/2==偶数</span><br><span class="line">    PBS1_Tq = PBS2_Tq = (NBT-1-tPTS_Tq)/2</span><br><span class="line">else</span><br><span class="line">    PBS1_Tq = (NBT-1-tPTS_Tq)/2</span><br><span class="line">    PBS2_Tq = PBS1_Tq + 1</span><br></pre></td></tr></table></figure>
<p>(6) <strong>同步跳转宽度</strong></p>
<script type="math/tex; mode=display">
SJW=min(PBS1_Tq,4)</script><p>(7)<strong>验证晶振误差Df</strong></p>
<p>CAN总线的晶振误差必须同时满足下面三个条件：</p>
<script type="math/tex; mode=display">
Df<=SJW(2×10×NBT)</script><script type="math/tex; mode=display">
Df<=min(PBS1_Tq,PBS2_Tq)2×(13×NBT−PBS2_Tq)</script><script type="math/tex; mode=display">
Df≤1.58%</script><h3 id="4-7-4-例子"><a href="#4-7-4-例子" class="headerlink" title="4.7.4 例子"></a><strong><strong>4.7.4 例子</strong></strong></h3><p>以下面的例子来讲述位定时参数的确定方法：</p>
<p>MCU晶振16MHz，位速率1Mbps，总线长度20m，单位总线延迟5ns/m，物理接口的发送接收延迟150ns</p>
<p>（1）晶振时钟周期：T=1s/16MHz = 62.5ns</p>
<p>（2）位时间 ：tBit = 1/1Mbps = 1000ns</p>
<p>（3）BPR和NBT：考虑到 T = 125ns，tBit = 1000ns，所以BPR只能取值为1，才能满足NBT∈[8,25],于是预分频数BPR=1；</p>
<p>（4）CAN时钟周期Tq = 2 × 62.5 × 1 = 125ns</p>
<p>（5）NBT = 8</p>
<p>（6）传输延迟时间tPTS</p>
<script type="math/tex; mode=display">
tPTS=2×（20×5+150）=500ns</script><p>所以</p>
<script type="math/tex; mode=display">
tPTS_Tq=tPTSTq=500125=4</script><p>于是NBT=8个Tq的长度中需要有4个Tq用于补偿传播延迟，于是还剩下4个Tq，</p>
<p>SS同步段长度固定占据1个Tq，还剩3个Tq，于是PBS1分配一个Tq，PBS2分配2个Tq。</p>
<p>（7）同步跳转宽度</p>
<script type="math/tex; mode=display">
SJW=min{PBS1,4}=1</script><p>（8）晶振误差</p>
<script type="math/tex; mode=display">
Df<=SJW(2×10×NBT)=1(2×10×8)=0.00625</script><script type="math/tex; mode=display">
Df<=min(PBS1_Tq,PBS2_Tq)2×(13×NBT−PBS2_Tq)</script><script type="math/tex; mode=display">
=12×(13×8−2)=0.00490</script>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式通讯协议</tag>
      </tags>
  </entry>
  <entry>
    <title>基础通信知识</title>
    <url>/2024/04/03/%E5%9F%BA%E7%A1%80%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="串行与并行"><a href="#串行与并行" class="headerlink" title="串行与并行"></a>串行与并行</h1><h2 id="1-串行通信"><a href="#1-串行通信" class="headerlink" title="1. 串行通信"></a>1. 串行通信</h2><p>位通过单根线一一发送，下图显示了二进制（01000011）中字母“C”的串行传输。<br>当时钟线为高电平时，接收数据位，高电平为1，低电平为0。</p>
<p><img src="/2024/04/03/%E5%9F%BA%E7%A1%80%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/image/1699358426009.png" alt="1699358426009"></p>
<h2 id="2-并行通信"><a href="#2-并行通信" class="headerlink" title="2. 并行通信"></a>2. 并行通信</h2><p>数据位在导线中同时传输，下图显示了二进制（01000011）中字母“C”的并行传输：<br>的当时钟线为高电平时，8个数据位同时接受数据，高电平为1，低电平为0<br><img src="/2024/04/03/%E5%9F%BA%E7%A1%80%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/image/1699358552501.png" alt="1699358552501"><br>所以UART、SPI、I2C都是串口通信，因为它们都是通过一根线作为数据线传输数据。</p>
<h1 id="单工、全双工与半双工"><a href="#单工、全双工与半双工" class="headerlink" title="单工、全双工与半双工"></a>单工、全双工与半双工</h1><h2 id="1-单工"><a href="#1-单工" class="headerlink" title="1. 单工"></a>1. 单工</h2><p>发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息。基于这种情况，数据信号从一端传送到另外一端，信号流是单方向的。</p>
<h2 id="2-全双工："><a href="#2-全双工：" class="headerlink" title="2. 全双工："></a>2. 全双工：</h2><p>通信的任意时刻，线路上存在A到B和B到A的双向信号传输。 全双工通信允许数据同时在两个方向上传输，又称为双向同时通信，即通信的双方可以同时发送和接收数据。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送，全双工方式无需进行方向的切换。</p>
<p>简单来说，比如我们在打电话时，我们可以在同一时间说话，这就是全双工通信。</p>
<h2 id="3-半双工"><a href="#3-半双工" class="headerlink" title="3. 半双工"></a>3. 半双工</h2><p>可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行。在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输。因此，也可以将半双工通信理解为一种切换方向的单工通信。</p>
<p>UART和SPI都是全双工通信方式，因为他们的数据线都有两根，即可以在同一时间A发数据给B，B也可以在这个时间发数据给A。如I2C通信，因为他只有一根数据线，所以他不能在同一时间双向传输数据。</p>
<h1 id="同步通信和异步通信"><a href="#同步通信和异步通信" class="headerlink" title="同步通信和异步通信"></a>同步通信和异步通信</h1><p>同步是阻塞模式，异步是非阻塞模式。</p>
<h2 id="1-同步通信"><a href="#1-同步通信" class="headerlink" title="1. 同步通信"></a>1. 同步通信</h2><p>发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。</p>
<p>在同步传输中，数据传输是按照定时信号进行的。发送方和接收方都需要遵守同样的时序规则，以确保数据能够正确地传输。发送方按照固定的时间间隔发送数据，接收方则按照相同的时间间隔接收数据。由于同步传输需要一定的时序同步，因此在高速传输和长距离传输时，同步传输具有较好的抗干扰能力和可靠性。(同步就是通信双方按照一定时序规则收发数据，常用于高速、长距离通信)</p>
<h2 id="2-异步通信"><a href="#2-异步通信" class="headerlink" title="2. 异步通信"></a>2. 异步通信</h2><p>发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p>
<p>在异步传输中，数据传输没有固定的时间间隔。发送方和接收方可以按照自己的节奏进行数据传输，发送方发送数据时不需要等待接收方的响应。因此，异步传输的速度相对较慢，但可以在低速传输和知短距离传输时使用，例如串口通信。(异步就是通信双方想发送就发送，常用于低速短距离通信，如串口通信)</p>
<p>所以SPI和I2C都是同步通信，因为他们都有时钟线，UART是异步通信方式，他只有两个数据线，发送完数据不会确认你是否接收到。</p>
<h1 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h1><p>波特率BR是单位时间传输的数据位数</p>
<p>单位：bps1bps=1bit/s。</p>
<p>采用异步串行，互相通信甲乙双方必须具有相同的波特率，否则无法成功地完成数据通信；</p>
<p>而在同步串行中，发送和接收数据是由同步时钟触发发送器和接收器而实现的。</p>
<p><strong>注：同步通信中数据传输的同步时钟频率就是波特率：而在异步通信中，时钟频率可为波特率的整数倍。</strong></p>
<p>注意：关于通信协议，我们通常需要考虑四个点：</p>
<p>1.有无clock</p>
<p>2.一次传多少数据位</p>
<p>3.是否支持同时收发</p>
<p>4.是否需要回复ack</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式通讯协议</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32启动流程</title>
    <url>/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/luobeihai/article/details/117595762">STM32启动过程分析___initial_sp-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_39400113/article/details/116051401">STM32三种BOOT启动模式详解(全网最全)_果果小师弟的博客-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/123291856">STM32第二章-启动过程详解 - 知乎 (zhihu.com)</a></p>
<h1 id="优秀链接："><a href="#优秀链接：" class="headerlink" title="优秀链接："></a>优秀链接：</h1><p><a href="https://www.emoe.xyz/stm32-boot-modeboot-filelinkerscript-analyze/">STM32 启动模式、启动文件和链接脚本分析 - Emoe-Studio</a></p>
<p><a href="https://gaoyichao.com/Xiaotu/?book=stm32&amp;title=STM32%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">无处不在的小土-STM32的启动过程 (gaoyichao.com)</a></p>
<p><a href="https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter14/chapter14.html">13. 启动文件详解 — [野火]STM32 HAL库开发实战指南——基于野火F4系列开发板 文档 (embedfire.com)</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/375425">STM32的启动过程 — startup_xxxx.s文件解析（MDK和GCC双环境）-云社区-华为云 (huaweicloud.com)</a></p>
<p><a href="https://xie.infoq.cn/article/bb7ca59b25e72f6e854e9e81f">STM32的启动过程 — startup_xxxx.s文件解析（MDK和GCC双环境）_stm32_矜辰所致_InfoQ写作社区</a></p>
<p><a href="https://fivecakes.com/p/650793a15f109b070f00d57a">STM32学习笔记（程序下载与启动流程） (fivecakes.com)</a></p>
<h1 id="STM32-启动模式、启动文件和链接脚本分析"><a href="#STM32-启动模式、启动文件和链接脚本分析" class="headerlink" title="STM32 启动模式、启动文件和链接脚本分析"></a>STM32 启动模式、启动文件和链接脚本分析</h1><p>参考文章：</p>
<p><a href="https://www.emoe.xyz/stm32-boot-modeboot-filelinkerscript-analyze/">STM32 启动模式、启动文件和链接脚本分析 - Emoe-Studio</a></p>
<h1 id="1-启动模式"><a href="#1-启动模式" class="headerlink" title="1 启动模式"></a>1 启动模式</h1><p>几乎每一块刚出场的MCU或其他控制芯片，都在其内部非易失存储器ROM中烧录了最基础的代码，<strong>CPU搬运并运行第一条代码的默认位置</strong>就在ROM的地址空间中，因此，我们可以看到，代码的执行与ROM相关，与硬件紧密联系。</p>
<p>对于Cortex-M系列核心的ARM芯片来说，硬件复位后，首先进行的是以下步骤（以STM32为例，其他厂商MCU部分流程可能会不同）：</p>
<ol>
<li>CPU 内的时序逻辑电路（程序代码下载到内部FLASH为例，FLASH首地址 <code>0x0800 0000</code>）将PC指针寄存器直接复位到零地址，且根据锁存的 <strong>Boot引脚的电平</strong> （启动模式），将不同存储区的首地址映射到零地址处；</li>
<li>硬件从地址0x0取出主堆栈指针（Top of Stack，Set the initial SP），存入SP指针中；</li>
<li><p>硬件从主堆栈指针后取出复位向量的地址（Set the initial PC == Reset_Handler），存入PC指针中；</p>
<p><strong>PC指针寄存器直接复位到零地址</strong> ，随后从中断向量表表头的 <code>RESET</code>向量表处获取 <strong>下一步跳转的地址</strong> （后续程序代码的PC指针寄存器的初始值） <strong>CPU会从PC指针寄存器指向的地址空间取出指令执行程序，而取完MSP后，一般会执行的第一段代码为复位中断服务程序 Reset_Handler</strong> 。</p>
</li>
</ol>
<p>一般情况下（以STM32G474RE+GCC为例），复位程序会根据SDK提供的初始化汇编脚本，（目录为 <code>/Core/Startup/startup_stm32g474retx.s</code>）,初始化存放在片上SRAM中的bss节（初值为0或者没有设置初值的变量）和data节（初值非0）,以及其他SDK代码运行所需节的变量，随后执行 <code>/Core/Src/system_stm32g4xx.c</code>中的SystemInit函数对核心功能（如FPU）进行使能,之后对 <code>Newlib</code>初始化后跳转进入main函数。</p>
<p> <img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431410456.png" alt="1701431410456"></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431418126.png" alt="1701431418126"></p>
<h2 id="1-1-启动模式选择"><a href="#1-1-启动模式选择" class="headerlink" title="1.1 启动模式选择"></a>1.1 启动模式选择</h2><p>我们可以看到STM32的存储器架构中，无论是厂家内置的的内部引导Rom（<code>BootROM of System Flash</code>，<code>Rom Code</code>）中的引导加载程序（<code>BootLoader</code>）还是Code Flash内的用户应用程序，亦或者是应用于SRAM中的调试代码， <strong>其地址都不在 <code>0x0000 0000</code>上</strong> ，而通过地址映射，可以将三种不同（亦或更多）的存储空间地址映射到 <code>0x0000 0000</code>地址处，也即 <strong>启动模式选择</strong> 。对于STM32和部分其他厂商的MCU来说， <strong>通过 <code>Boot</code>引脚的选择（只在上电时检测，复位后重新锁存）来确定存储空间的映射是最常见可靠的一种方式</strong> ，可以实现将CodeFlash、System Flash或SRAM的首地址映射到 <code>0x0000 0000</code>，实现程序从不同的存储器位置启动。</p>
<blockquote>
<p>注：启动模式只决定程序烧录的位置，复位后，需要重新锁存Boot引脚的选择。STM32上电复位以后，代码区都是从 <code>0x0000 0000</code>开始的，启动模式只是将各自存储空间的地址映射到 <code>0x0000 0000</code>。</p>
<p>相比F1，F4的启动方式，H7的启动方式更灵活些，只需一个boot引脚即可。但是一个引脚只能区分出两个状态，为了解决这个问题，H7专门配套了两个option bytes选项字节来解决此问题。</p>
</blockquote>
<p>以STM32的Cortex-M核心MCU为例，启动时PC指针会固定跳转到0地址处，可以将System Boot、Internal Flash亦或者Internal SRAM的地址映射到0地址处，更有甚者，我们可以映射External Flash、External RAM到0地址处。这需要外部Boot引脚的电平引脚的配比来实现，有时也需要硬件的XIP功能以及二次引导代码的支持（放在Internal Flash起始处，并映射到0地址）。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431458729.png" alt="1701431458729"></p>
<p>STM32的三种基本启动模式：</p>
<ol>
<li>主闪存存储器(<code>Main Flash</code>)启动：从STM32内置的Flash启动(<code>0x0800 0000</code>–<code>0x0807 FFFF</code>)，一般我们使用 <code>JTAG</code>或者 <code>SWD</code>调试接口下载程序时，就是直接写入到Flash里面，重启后也直接从这启动程序。以 <code>0x0800 0000</code> 对应的内存为例，则该块内存既可以通过 <code>0x0000 0000</code> 操作也可以通过 <code>0x0800 0000</code> 操作，且都是操作的同一块内存。</li>
<li>系统存储器(<code>System Memory</code>)启动：从系统存储器启动(<code>0x1FFF F000</code> – <code>0x1FFF F7FF</code>)，这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的 <code>ISP</code>程序中，提供了串口下载程序的固件，可以通过这个 <code>ISP</code>程序将用户程序下载到系统的Flash中。以 <code>0x1FFF FFF0</code>对应的内存为例，则该块内存既可以通过 <code>0x0000 0000</code> 操作也可以通过 <code>0x1FFF FFF0</code>操作，且都是操作的同一块内存。</li>
<li>片上SRAM启动：从内置SRAM启动(<code>0x2000 0000</code>–<code>0x3FFF FFFF</code>)，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。SRAM 只能通过 <code>0x2000 0000</code>进行操作，与上述两者不同。<strong>从SRAM 启动时，需要在应用程序初始化代码中重新设置向量表的位置。（ST在SystemInit函数中预先提供了重定向中断向量表的操作，声明对应的宏即可自动重定向）</strong></li>
</ol>
<p>表. F1/F4等系列MCU的启动模式选择<br><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431473545.png" alt="1701431473545"><br>表.H7的启动模式选择</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>BOOT引脚</th>
<th>BOOT选项寄存器</th>
<th>BOOT区域</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>BOOT_ADD0[15:0]</td>
<td>启动地址由BOOT_ADD0定义，默认值是0x0800，对应Flash首地址0x0800 0000。</td>
</tr>
<tr>
<td>1</td>
<td>BOOT_ADD1[15:0]</td>
<td>启动地址由BOOT_ADD1定义，默认值是0x1FF0，对应系统bootloader的首地址0x1FF0 0000。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>BOOT_ADD0和BOOT_ADD1对应32位地址到高16位，这点要特别注意。通过这两个选项字节，所有0x0000 0000到0x3FFF 0000的存储器地址都可以设置，包括：</p>
<ol>
<li>所有Flash地址空间；</li>
<li>所有RAM地址空间，ITCM，DTCM和SRAM。</li>
</ol>
<p>设置了选项字节后， <strong>掉电不会丢失</strong> ，下次上电或者复位后，会根据BOOT引脚状态从BOOT_ADD0，或BOOT_ADD1所设置的地址进行启动。</p>
</blockquote>
<h2 id="1-2-为什么STM32的Flash地址要设置到0x0800-0000"><a href="#1-2-为什么STM32的Flash地址要设置到0x0800-0000" class="headerlink" title="1.2 为什么STM32的Flash地址要设置到0x0800 0000"></a>1.2 为什么STM32的Flash地址要设置到0x0800 0000</h2><p>ARM官方回复：<a href="https://developer.arm.com/documentation/ka001328/latest">Documentation – Arm Developer</a></p>
<p>翻译成中文，ARM官方的回答的意思如下：</p>
<blockquote>
<p>复位后，Cortex-M3内核只能从0x0地址启动，但通过写向量偏移寄存器VTOR（<code>0xE000 ED08</code>），可以在程序执行过程中重定位中断向量表。</p>
<p>Cortex-M3内核的启动顺序与传统ARM内核不同，在地址0x0提取的第一个参数为SP的初始值，第二个参数（位于 <code>0x0000 0004</code>）为复位中断服务程序地址，即程序代码的起始地址。另一件需要注意的事是Cortex-M3的中断向量表入口是地址值，而不是像传统ARM内核的分支指令。此外，创建一个 <code>bit[0]</code>大小的表项（？）还会在与该向量对应的中断处理程序的第一条指令上产生INVESTATE错误。</p>
</blockquote>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431525272.png" alt="1701431525272"></p>
<h3 id="1-2-1-背景知识"><a href="#1-2-1-背景知识" class="headerlink" title="1.2.1 背景知识"></a>1.2.1 背景知识</h3><p>从上文我们可以知道，M3，M4内核芯片上电复位后，要固定从0x0000 0000地址读取中断向量表，获取复位中断服务程序的入口地址后，进入复位中断服务程序，其中 <strong>0x0000 0000是栈顶地址（MSP），0x0000 0004存的是复位中断服务程序地址</strong> 。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431566615.png" alt="1701431566615"></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431535502.png" alt="1701431535502"></p>
<h3 id="1-2-2-问题解释"><a href="#1-2-2-问题解释" class="headerlink" title="1.2.2 问题解释"></a>1.2.2 问题解释</h3><p>既然ARM规定了M3，M4内核要从地址 <code>0x0000 0000</code>读取中断向量表，而STM32设置Flash地址到 <code>0x0800 0000</code>怎么办？</p>
<p>STM32支持内存重映射功能，将<strong>地址 <code>0x0800 0000</code>开始的内容重映射</strong>到首地址 <code>0x0000 0000</code>中，这样就解决了从 <code>0x0000 0000</code>读取中断向量表的问题。</p>
<p>图示，以STM32F407IGT6为例，0x0000 0000和0x0800 0000开始的程序对比，并没有什么不同：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431673276.png" alt="1701431673276"></p>
<h3 id="1-2-3-怎么保证0x08000-0000首地址存的就是中断向量表，不可以随意设置吗？"><a href="#1-2-3-怎么保证0x08000-0000首地址存的就是中断向量表，不可以随意设置吗？" class="headerlink" title="1.2.3 怎么保证0x08000 0000首地址存的就是中断向量表，不可以随意设置吗？"></a>1.2.3 怎么保证0x08000 0000首地址存的就是中断向量表，不可以随意设置吗？</h3><p>保证中断向量表存到0x0800 0000，这个涉及到分散加载（链接脚本）的一个小知识，以MDK为例，如果大家看xxx.S启动文件，里面通过 <code>AREA</code>定义了一个名叫 <code>RESET</code>的段，这段存的就是中断向量表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br></pre></td></tr></table></figure>
<p>这个名字很重要，MDK对应的xxx.sct分散加载（GCC下的链接脚本也将中断向量表放在 <code>.text</code>段的开头）里面通过下面这句将这个 <code>RESET</code>段放在了 <code>0x0800 0000</code>优先存储。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; *************************************************************</span><br><span class="line">; *** Scatter-Loading Description File generated by uVision ***</span><br><span class="line">; *************************************************************</span><br><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00200000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00200000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM2 0x24000000 0x00080000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GCC的实现方式类似，是在链接脚本内SECTIONS部分开头部位定义了.isr_vector段用于存放中断向量表，这样链接器进行链接时按顺序安置变量就会将其放在 <code>0x0800 0000</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* The startup code into &quot;FLASH&quot; Rom type memory */</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector)) /* Startup code */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样我们就解决了 <code>0x0800 0000</code>首地址存储中断向量表，一旦程序开始运行后，我们就可以随意设置中断向量表的位置了。比如想将中断向量表存到内部SRAM，我们就可以操作寄存器 <code>SCB-&gt;VTOR</code> 重新安排，然后将 <code>0x0800 0000</code>的内容复制到设置的地址内即可。</p>
<h3 id="1-2-4-设置到0x0800-0000这么麻烦，为什么不直接使用0x0000-0000？"><a href="#1-2-4-设置到0x0800-0000这么麻烦，为什么不直接使用0x0000-0000？" class="headerlink" title="1.2.4 设置到0x0800 0000这么麻烦，为什么不直接使用0x0000 0000？"></a>1.2.4 设置到0x0800 0000这么麻烦，为什么不直接使用0x0000 0000？</h3><p>回到这一个小节问题的本身，为什么不直接使用0x0000 0000？</p>
<p>因为STM32不仅可以从内部Flash启动，还可以从系统存储器（可以实现串口ISP，USB DFU等程序下载方式，这个程序是ST固化好的程序代码）和从内部SRAM启动，我们将内部Flash安排到0x0000 0000显然是不行的。这样会导致系统存储器或者内部SRAM无法重映射到0x0000 0000了。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431690508.png" alt="1701431690508"></p>
<h3 id="1-2-5-了解了M3和M4，M7是怎么个执行情况呢？"><a href="#1-2-5-了解了M3和M4，M7是怎么个执行情况呢？" class="headerlink" title="1.2.5 了解了M3和M4，M7是怎么个执行情况呢？"></a>1.2.5 了解了M3和M4，M7是怎么个执行情况呢？</h3><p>M7内核比较灵活，改变了固定从0x0000 0000地址读取中断向量表，以STM32H7为例，可以从 0x0000 0000 到 0x3FFF 0000 所有地址进行启动，并且专门安排了个选项字节来配置。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431708678.png" alt="1701431708678"></p>
<blockquote>
<p>H7里面没有传统风格的重映射，它的首地址0x0000 0000安排给ITCM RAM空间使用。</p>
</blockquote>
<p>以下，我们结合正点原子的MiniPRO STM32H750开发板 HAL库例程的 实验 1 跑马灯实验中，取出的 <code>MSP</code>和 <code>PC</code>的值是多少，方法如图。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431726276.png" alt="1701431726276"></p>
<p>由图可以知道地址 <code>0x0800 0000</code>的值是 <code>0x2400 0BD8</code>，地址 <code>0x0800 0004</code>的值是 <code>0x0800 0339</code>，即 堆栈指针SP = <code>0x2400 0BD8</code>程序计数器指针PC = <code>0x0800 0339</code>（即复位中断服务程序 <code>Reset_Handler</code>的入口地址），因为 <strong>CM7内核是小端模式，所以字节之间倒着读</strong> 。</p>
<blockquote>
<p>注意，这与传统的ARM架构不同，其实也和绝大多数其它架构MCU不同。 <strong>传统的ARM架构总是从0地址开始执行第一条指令</strong> ，它们的 <code>0</code>地址处总是一条跳转指令。而在CM3内核中，<code>0</code>地址处提供 <code>MSP</code>的初始值，然后是向量表（ <strong>向量表在启动之后还可以被移至其它位置</strong> ）。向量表中的数值是32位的地址，而不是跳转指令。向量表的第一个条目指向复位后应执行的第一条指令，就是 <code>Reset_Handler</code>这个函数。</p>
</blockquote>
<p>下面继续以跑马灯实验为例，代码从地址 <code>0x0800 0000</code>开始被执行，讲解系统启动，初始化堆栈、<code>MSP</code>和 <code>PC</code>后的内存情况。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431742369.png" alt="1701431742369"></p>
<p>因为CM7使用的是 <strong>向下生长的满栈</strong> ，所以 <strong>MSP的初始值必须是堆栈内存的末地址加1（MSP是栈顶指针）</strong> 。举例来说，如果你的栈区域在 <code>0x2400 03D8</code>~<code>0x2400 0BD4</code>，2KB大小）之间，那么 <code>MSP</code>的初始值就必须是 <code>0x2400 0BD8</code>。</p>
<p><strong>向量表跟随在MSP的初始值之后,也就是第2个表目。</strong></p>
<p><code>r15</code>是程序计数器，在汇编代码中，可以使用名字 <code>PC</code>来访问它。 <strong>MCU主要执行Thumb指令(指令长度更短，节约空间)</strong> 。 <strong>此外，读PC时返回的值是当前指令的地址+4</strong> 。比如说：</p>
<p>正因为上述原因，使用 <code>0x0800 0339</code>来表达地址 <code>0x0800 0338</code>。 <strong>当 <code>0x0800 0339</code>处的指令得到执行后，就正式开始了程序的执行（即去到C的世界）</strong> 。所以在此之前 <strong>初始化 <code>MSP</code>是必需的</strong> ，因为可能第1条指令还没执行就会被 <code>NMI</code>或是其它异常打断。<strong><code>MSP</code>初始化好后就已经为它们的服务例程准备好了堆栈。</strong></p>
<h1 id="2-STM32-启动文件分析（基于GCC）"><a href="#2-STM32-启动文件分析（基于GCC）" class="headerlink" title="2 STM32 启动文件分析（基于GCC）"></a>2 STM32 启动文件分析（基于GCC）</h1><p>参考链接：<a href="https://sourceware.org/binutils/docs/as.html#Word">Using as (sourceware.org)</a>，需要注意的是我们的主要内容参考 <code>ELF</code>格式。</p>
<blockquote>
<p>GCC下启动文件实现的功能与在MDK环境下启动文件实现的功能并无本质上的区别，此处结合startup_stm32h750xx.s进行说明。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  * @file      startup_stm32h750xx.s</span><br><span class="line">  * @author    MCD Application Team</span><br><span class="line">  * @brief     STM32H750xx Devices vector table for GCC based toolchain. </span><br><span class="line">  *            This module performs:</span><br><span class="line">  *                - Set the initial SP</span><br><span class="line">  *                - Set the initial PC == Reset_Handler,</span><br><span class="line">  *                - Set the vector table entries with the exceptions ISR address</span><br><span class="line">  *                - Branches to main in the C library (which eventually</span><br><span class="line">  *                  calls main()).</span><br><span class="line">  *            After Reset the Cortex-M processor is in Thread mode,</span><br><span class="line">  *            priority is Privileged, and the Stack is set to Main.</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  * @attention</span><br><span class="line">  *</span><br><span class="line">  * Copyright (c) 2018 STMicroelectronics.</span><br><span class="line">  * All rights reserved.</span><br><span class="line">  *</span><br><span class="line">  * This software component is licensed by ST under BSD 3-Clause license,</span><br><span class="line">  * the &quot;License&quot;; You may not use this file except in compliance with the</span><br><span class="line">  * License. You may obtain a copy of the License at:</span><br><span class="line">  *                        opensource.org/licenses/BSD-3-Clause</span><br><span class="line">  *</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>
<h2 id="2-1-常见的GNU汇编伪代码-指令"><a href="#2-1-常见的GNU汇编伪代码-指令" class="headerlink" title="2.1 常见的GNU汇编伪代码/指令"></a>2.1 常见的GNU汇编伪代码/指令</h2><p>以下为GNU汇编伪代码与ARM汇编伪代码的对应关系，但实际上他们并不完全相同。</p>
<p>具体的可以参考<a href="https://sourceware.org/binutils/docs/as.html#Word">Using as (sourceware.org)</a>。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431830176.png" alt="1701431830176"></p>
<p>以下为启动文件的作用说明，基本按照从上往下的格式进行描述。</p>
<h2 id="2-2-基本说明"><a href="#2-2-基本说明" class="headerlink" title="2.2 基本说明"></a>2.2 基本说明</h2><p><code>startup_stm32h750xx.s</code>的开头部分是基本说明。</p>
<ol>
<li>表示使用统一的 <code>ARM/Thumb</code>汇编语法。<a href="https://sourceware.org/binutils/docs/as/ARM_002dInstruction_002dSet.html#ARM_002dInstruction_002dSet">ARM-Instruction-Set (Using as) (sourceware.org)</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.syntax unified COPY</span><br></pre></td></tr></table></figure>
<ol>
<li>表示指定所需的核心版本为 <code>cortex-m7</code>。<a href="https://sourceware.org/binutils/docs/as.html#ARC-Syntax">Syntax</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.cpu cortex-m7COPY</span><br></pre></td></tr></table></figure>
<ol>
<li>选择要组装的浮点单元为 <code>softvfp</code>，软浮点（<code>Soft-float</code>），浮点单元即 <code>VFP</code>(<code>vector floating-point</code>)。<a href="https://sourceware.org/binutils/docs/as.html#ARM-Directives">ARM Machine Directives</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.fpu softvfpCOPY</span><br></pre></td></tr></table></figure>
<ol>
<li>选择 <code>THUMB</code>指令集，执行与 <code>.code 16</code>相同的操作，使 <code>thumb</code>模式等价于 <code>.code 16;gcc -mthumb</code>。<a href="https://sourceware.org/binutils/docs/as.html#ARM-Directives">ARM Machine Directives</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.thumbCOPY</span><br></pre></td></tr></table></figure>
<ol>
<li>定义两个全局符号，这两个符号对链接文件可见， <code>g_pfnVectors</code>为中断向量表，<code>Default_Handler</code>为默认中断。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global  g_pfnVectors                   /* 定义两个全局符号，这两个符号对链接文件可见， g_pfnVectors为中断向量表 */  </span><br><span class="line">.global  Default_Handler                /* Default_Handler为默认中断 */ COPY</span><br></pre></td></tr></table></figure>
<ol>
<li><code>.word</code>表示了在当前位置放一个 <code>word</code>型的值，可以理解为一个变量或者数据定义，这个变量同样对对 <code>.ld</code>（链接文件）可见。</li>
<li>定义的变量包括 <code>_sidata, _sdata, _edata, _sbss, _ebss</code>，分别用于表示带初始化值的 <code>.data</code>段起始地址，<code>.data</code>段的起始地址和结束地址，<code>.bss</code>段的起始地址和结束地址。</li>
<li>注释中 <code>SystemInit_ExtMemCtl</code>表示配置外部RAM。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* start address for the initialization values of the .data section. </span><br><span class="line">defined in linker script */   </span><br><span class="line">.word  _sidata          </span><br><span class="line">/* start address for the .data section. defined in linker script */  </span><br><span class="line">.word  _sdata</span><br><span class="line">/* end address for the .data section. defined in linker script */</span><br><span class="line">.word  _edata</span><br><span class="line">/* start address for the .bss section. defined in linker script */</span><br><span class="line">.word  _sbss</span><br><span class="line">/* end address for the .bss section. defined in linker script */</span><br><span class="line">.word  _ebss</span><br><span class="line">/* stack used for SystemInit_ExtMemCtl; always internal RAM used */COPY</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Reset-Handler复位中断服务程序"><a href="#2-3-Reset-Handler复位中断服务程序" class="headerlink" title="2.3 Reset_Handler复位中断服务程序"></a>2.3 Reset_Handler复位中断服务程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  This is the code that gets called when the processor first</span><br><span class="line"> *          starts execution following a reset event. Only the absolutely</span><br><span class="line"> *          necessary set is performed, after which the application</span><br><span class="line"> *          supplied main() routine is called. </span><br><span class="line"> * @param  None</span><br><span class="line"> * @retval : None</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    .section  .text.Reset_Handler</span><br><span class="line">  .weak  Reset_Handler</span><br><span class="line">  .type  Reset_Handler, %function</span><br><span class="line">Reset_Handler:  </span><br><span class="line">  ldr   sp, =_estack      /* set stack pointer */</span><br><span class="line"></span><br><span class="line">/* Copy the data segment initializers from flash to SRAM */  </span><br><span class="line">  movs  r1, #0</span><br><span class="line">  b  LoopCopyDataInitCOPY</span><br></pre></td></tr></table></figure>
<ol>
<li>开头注释表明：这部分代码在芯片第一次启动或复位后，需要执行的一些必要的操作，在此之后启动main()函数执行；</li>
<li><code>.section .text.Reset_Handler</code>这里表示定义的是 <code>.text</code>节中的 <code>Reset_Handler</code>节；</li>
<li><code>.weak</code>将 <code>Reset_Handler</code>设置为弱属性，如果符号不存在，将创建它们。(弱定义，如果有其他强定义则用强定义替代)，即当我们在程序内定义一个 <code>Reset_Handler</code>函数时，这部分将不起作用；</li>
<li><code>.type</code>将符号 <code>Reset_Handler</code>的类型设置为函数名；</li>
<li><code>Reset_Handler</code>函数的主要作用是：<code>ldr</code>指令用于从内存中将一个32位的字读取到指令中的目标寄存器中，即将 <code>_estack</code>栈底赋值给 <code>SP</code>，将 <code>R1</code>寄存器赋值为0，<code>B</code>指令跳转至 <code>CopyDataInit</code>函数，通过函数名可以看出，这里是对数据进行初始化。</li>
</ol>
<h2 id="2-4-将-data段从-FLASH移动到-RAM，将-bss段清零"><a href="#2-4-将-data段从-FLASH移动到-RAM，将-bss段清零" class="headerlink" title="2.4 将 .data段从 FLASH移动到 RAM，将 .bss段清零"></a>2.4 将 <code>.data</code>段从 <code>FLASH</code>移动到 <code>RAM</code>，将 <code>.bss</code>段清零</h2><p>参考链接：<a href="https://community.arm.com/support-forums/f/architectures-and-processors-forum/5941/could-you-explain-bcc-command-to-me">Could you explain BCC command to me? – Architectures and Processors forum – Support forums – Arm Community</a></p>
<p><a href="https://blog.csdn.net/weixin_41608556/article/details/120801250?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-120801250-blog-17934511.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-120801250-blog-17934511.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=1">(3条消息) 汇编指令 BCC/BLO_瑞欧莱的博客-CSDN博客_blo指令</a></p>
<p><a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/condition-codes-1-condition-flags-and-codes">Condition Codes 1: Condition flags and codes – Architectures and Processors blog – Arm Community blogs – Arm Community</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CopyDataInit:</span><br><span class="line">  ldr  r3, =_sidata         // _sidata为.data段中初始化值的起始地址</span><br><span class="line">  ldr  r3, [r3, r1]</span><br><span class="line">  str  r3, [r0, r1]</span><br><span class="line">  adds  r1, r1, #4</span><br><span class="line"></span><br><span class="line">LoopCopyDataInit:</span><br><span class="line">  ldr  r0, =_sdata          // _sdata为.data段的起始地址</span><br><span class="line">  ldr  r3, =_edata          // _edata为.data段的结束地址</span><br><span class="line">  adds  r2, r0, r1</span><br><span class="line">  cmp  r2, r3               // R2-R3 &lt; 0，C清零， R2-R3 ≥ 0， C置位</span><br><span class="line">  bcc  CopyDataInit         //  Branch if Carry Clear，判断C位</span><br><span class="line">  ldr  r2, =_sbss</span><br><span class="line">  b  LoopFillZerobss</span><br><span class="line">/* Zero fill the bss segment. */  </span><br><span class="line">FillZerobss:</span><br><span class="line">  movs  r3, #0</span><br><span class="line">  str  r3, [r2], #4</span><br><span class="line"></span><br><span class="line">LoopFillZerobss:</span><br><span class="line">  ldr  r3, = _ebss</span><br><span class="line">  cmp  r2, r3</span><br><span class="line">  bcc  FillZerobssCOPY</span><br></pre></td></tr></table></figure>
<p><code>ARM</code>汇编语言中有16个可能的条件分支，包括“always”（实际上是一个无条件分支）和“never”（从未使用过，但存在于未来可能的架构扩展中）。下表给出了完整的分支指令集：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>BRANCH</strong></th>
<th><strong>CONDITION TEST</strong></th>
<th><strong>MEANING</strong></th>
<th><strong>USES</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>No test</td>
<td>Unconditional</td>
<td>Always take the branch</td>
</tr>
<tr>
<td>BAL</td>
<td>No test</td>
<td>Always</td>
<td>Always take the branch</td>
</tr>
<tr>
<td>BEQ</td>
<td>Z=1</td>
<td>Equal</td>
<td>Comparison equal or zero result</td>
</tr>
<tr>
<td>BNE</td>
<td>Z=0</td>
<td>Not equal</td>
<td>Comparison not equal or non-zero result</td>
</tr>
<tr>
<td>BCS</td>
<td>C=1</td>
<td>Carry set</td>
<td>Arithmetic operation gave carry out</td>
</tr>
<tr>
<td>BCC</td>
<td>C=1</td>
<td>Carry clear</td>
<td>Arithmetic operation did not produce a carry</td>
</tr>
<tr>
<td>BHS</td>
<td>C=1</td>
<td>Higher or same</td>
<td>Unsigned comparison gave higher or same result</td>
</tr>
<tr>
<td>BLO</td>
<td>C=0</td>
<td>Lower</td>
<td>Unsigned comparison gave lower result</td>
</tr>
<tr>
<td>BMI</td>
<td>N=1</td>
<td>Minus</td>
<td>Result is minus or negative</td>
</tr>
<tr>
<td>BPL</td>
<td>N=0</td>
<td>Plus</td>
<td>Result is positive (plus) or zero</td>
</tr>
<tr>
<td>BVS</td>
<td>V=1</td>
<td>Overflow Set</td>
<td>Signed integer operation: overflow occurred</td>
</tr>
<tr>
<td>BVC</td>
<td>V=0</td>
<td>Overflow Clear</td>
<td>Signed integer operation: no overflow occurred</td>
</tr>
<tr>
<td>BHI</td>
<td>((NOT C) OR Z) =0 {C set and Z clear}</td>
<td>Higher</td>
<td>Unsigned comparison gave higher</td>
</tr>
<tr>
<td>BLS</td>
<td>((NOT C) OR Z) =1 {C set or Z clear}</td>
<td>Lower or same</td>
<td>Unsigned comparison gave lower or same</td>
</tr>
<tr>
<td>BGE</td>
<td>(N EOR V) =0 {(N and V) set or (N and V) clear}</td>
<td>Greater or Equal</td>
<td>Signed integer comparison gave greater than or equal</td>
</tr>
<tr>
<td>BLT</td>
<td>(N EOR V) =1 {(N set and V clear) or (N clear and V set)}</td>
<td>Less Than</td>
<td>Signed integer comparison gave less than</td>
</tr>
<tr>
<td>BGT</td>
<td>(Z OR (N EOR V)) =0 {((N and V) set or clear) and Z clear}</td>
<td>Greater Than</td>
<td>Signed integer comparison gave greater than</td>
</tr>
<tr>
<td>BLE</td>
<td>(Z OR (N EOR V)) =1 {(N set and V clear) or (N clear and V set) or Z set}</td>
<td>Less or Equal</td>
<td>Signed integer comparison gave less than or equal</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><code>LoopCopyDataInit</code>函数的主要作用是：将 <code>_sdata</code>赋值给 <code>R0</code>，将 <code>_edata</code>赋值给 <code>R3</code>，将 <code>R0</code>和 <code>R1</code>的相加结果给 <code>R2</code>，注意 <code>R1</code>这里是0（FLASH的0起始地址），<code>cmp</code>比较 <code>R2</code>与 <code>R3</code>，<code>bcc</code>进行无进位转移，如果 <code>R2&lt;R3</code>，表示有初始化值需要从 <code>FLASH</code>复制到 <code>RAM</code>，则进入 <code>CopyDataInit</code>函数，否则则将 <code>R2</code>置为 <code>_sbss</code>并跳转至 <code>LoopFillZerobss</code>。</li>
<li><code>CopyDataInit</code>函数的主要作用是将 <code>.data</code>段的初始化值从 <code>FLASH</code>复制到 <code>RAM</code>，先将 <code>_sidata</code>赋值给 <code>R3</code>，将 <code>R3+R1</code>的地址单元的值存入 <code>R3</code>，将 <code>R3</code>的值存入 <code>R0+R1</code>的地址单元，然后将 <code>R1</code>的值加4（复位函数的入口地址）。</li>
<li><code>LoopFillZerobss</code>函数的主要作用是将 <code>.bss</code>段清零，此时 <code>R2</code>为 <code>_sbss</code>，将 <code>_ebss</code>赋值给 <code>R3</code>，<code>cmp</code>比较 <code>R2</code>与 <code>R3</code>，<code>bcc</code>进行无进位转移，如果 <code>R2&lt;R3</code>，则有 <code>.bss</code>段的值需要初始化，调用 <code>FillZerobss</code>函数。</li>
<li><code>FillZerobss</code>函数的主要作用就将 <code>.bss</code>段清零，将0赋值给 <code>R3</code>，然后将 <code>R3</code>的值存入 <code>R2+4</code>的地址单元中。</li>
</ol>
<blockquote>
<p>其实大家发现没有，<code>LoopCopyDataInit</code>函数和 <code>LoopFillZerobss</code>函数好像都只调用了一次，但明明名字里带了Loop（循环），那他们是怎么实现循环的呢？这就涉及到汇编的又一个知识点：<strong>语句是顺序执行</strong>的，而我们摘出来的四个函数的顺序是 <code>CopyDataInit</code>➡<code>LoopCopyDataInit</code>➡<code>FillZerobss</code>➡<code>LoopFillZerobss</code>，也就是说程序运行的步骤其实如下图所示。</p>
</blockquote>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431871750.png" alt="1701431871750"></p>
<h2 id="2-5-调用-SystemInit并转入到C的世界"><a href="#2-5-调用-SystemInit并转入到C的世界" class="headerlink" title="2.5 调用 SystemInit并转入到C的世界"></a>2.5 调用 <code>SystemInit</code>并转入到C的世界</h2><blockquote>
<p>此处使用的是GCC下RTT的启动文件，以 <code>entry()</code>函数作为C语言的入口。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Call the clock system intitialization function.*/</span><br><span class="line">  bl  SystemInit   </span><br><span class="line">/* Call static constructors */</span><br><span class="line">/* bl __libc_init_array */</span><br><span class="line">/* Call the application&#x27;s entry point.*/</span><br><span class="line">  bl  entry</span><br><span class="line">  bx  lr  </span><br><span class="line">.size  Reset_Handler, .-Reset_HandlerCOPY</span><br></pre></td></tr></table></figure>
<ol>
<li><code>bl __libc_init_array</code>指用了C++代码，需要 <code>__libc_init_array</code> 来初始化一些东西， 在C++中，全局变量和静态变量的构造函数需要在main函数执行前执行，这些构造函数会放在 <code>init_array</code>表中，<code>__libc_init_array</code>函数有调用这些函数的代码；</li>
<li>跳转 <code>main</code>函数，当 <code>main</code>函数执行退出后执行 <code>BX LR</code>跳转回 <code>LR</code>寄存器，这时候就从 <code>main</code>函数跳出来了；</li>
<li><code>.size Reset_Handler, .-Reset_Handler</code>（ELF格式下隐含标识一个段的结束的意思）该指令设置为与符号名称关联的大小，表示 <code>Reset_Handler</code>函数结束。</li>
</ol>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431888303.png" alt="1701431888303"></p>
<h2 id="2-6-默认中断服务函数"><a href="#2-6-默认中断服务函数" class="headerlink" title="2.6 默认中断服务函数"></a>2.6 默认中断服务函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  This is the code that gets called when the processor receives an </span><br><span class="line"> *         unexpected interrupt.  This simply enters an infinite loop, preserving</span><br><span class="line"> *         the system state for examination by a debugger.</span><br><span class="line"> * @param  None   </span><br><span class="line"> * @retval None   </span><br><span class="line">*/</span><br><span class="line">    .section  .text.Default_Handler,&quot;ax&quot;,%progbits</span><br><span class="line">Default_Handler:</span><br><span class="line">Infinite_Loop:</span><br><span class="line">  b  Infinite_Loop</span><br><span class="line">  .size  Default_Handler, .-Default_HandlerCOPY</span><br></pre></td></tr></table></figure>
<ol>
<li>注释说明如果处理器收到一个未预料的中断，将会进入这个死循环中，即 <code>Default_Handler</code>（此处不同于MDK，GCC环境下，先跳转到 <code>Default_Handler</code>再跳转到相应的中断服务函数）；</li>
<li><code>.section .text.Default_Handler</code>这里表示定义的是 <code>.text</code>段中的 <code>Reset_Handler</code>段，ax表示权限，ax是 allocation execute的缩写，表示该节区可分配并且可执行，<code>progbits</code>是 <code>type</code>，表示此段包含数据，详细定义为 <code>.section section_name [, “flags”[, %type[,flag_specific_arguments]]]&lt;span&gt; &lt;/span&gt;</code>。</li>
</ol>
<h2 id="2-7-中断向量表和中断服务函数"><a href="#2-7-中断向量表和中断服务函数" class="headerlink" title="2.7 中断向量表和中断服务函数"></a>2.7 中断向量表和中断服务函数</h2><ol>
<li>注释部分，表明中断向量表需要在物理地址 <code>0x00000000</code>的位置上，如果是IAP当然可以通过程序后续配置调整地址大小，但是第一次启动必然要从0开始；</li>
<li><code>section .isr_vector,&quot;a&quot;,%progbits</code>定义中断向量段和它的类型，a表示可分配，<code>%progbits</code>表示段内包含数据；</li>
<li><code>.type g_pfnVectors, %object</code>段符号名为 <code>g_pfnVectors</code>，<code>%object</code>表示符号为数据对象；</li>
<li><code>.size g_pfnVectors, .-g_pfnVectors</code>表示 <code>g_pfnVectors</code>的大小是从当前位置-定义位置；</li>
<li><code>word _estack</code>在当前位置放置一个word型的值，这个值为 <code>_estack</code>（这个值是栈顶的值，存在flash的0偏移地址处），后面同理；</li>
<li><code>.thumb_set NMI_Handler,Default_Handler</code>等效于.set指令，因为它创建了一个符号，该符号是另一个符号的别名（可能尚未定义）。 该指令还具有添加的属性，因为它以 <code>.thumb_func</code>指令相同的方式将别名符号标记为thumb函数入口点。即 <code>NMI_Handler</code>默认用 <code>Default_Handler</code>替代，但同时 <code>NMI_Handler</code>还是个若引用，因此当我们在程序里定义了这个中断服务函数的时候，就会替代这里。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/******************************************************************************</span><br><span class="line">*</span><br><span class="line">* The minimal vector table for a Cortex M. Note that the proper constructs</span><br><span class="line">* must be placed on this to ensure that it ends up at physical address</span><br><span class="line">* 0x0000.0000.</span><br><span class="line">* </span><br><span class="line">*******************************************************************************/</span><br><span class="line">   .section  .isr_vector,&quot;a&quot;,%progbits          // 将下面的代码组合成名为.isr_vector的段，&quot;a&quot;表示此段是可以分配的，%progbits表示此段包含数据</span><br><span class="line">  .type  g_pfnVectors, %object                  // 段符号名为g_pfnVectors，%object表示符号为数据对象</span><br><span class="line">  .size  g_pfnVectors, .-g_pfnVectors           // g_pfnVectors的大小为从位置计数器的值-g_pfnVectors</span><br><span class="line"></span><br><span class="line">g_pfnVectors:</span><br><span class="line">  .word  _estack                                // 在当前位置放置一个word型的值，这个值为_estack，这个值是栈顶的值，存在flash的0偏移地址处</span><br><span class="line">  .word  Reset_Handler</span><br><span class="line"></span><br><span class="line">  .word  NMI_Handler</span><br><span class="line">  .word  HardFault_Handler</span><br><span class="line">  .word  MemManage_Handler</span><br><span class="line">  .word  BusFault_Handler</span><br><span class="line">  .word  UsageFault_Handler</span><br><span class="line">  .word  0</span><br><span class="line">  .word  0</span><br><span class="line">  .word  0</span><br><span class="line">  .word  0</span><br><span class="line">  .word  SVC_Handler</span><br><span class="line">  .word  DebugMon_Handler</span><br><span class="line">  .word  0</span><br><span class="line">  .word  PendSV_Handler</span><br><span class="line">  .word  SysTick_Handler</span><br><span class="line"></span><br><span class="line">  /* External Interrupts */</span><br><span class="line">  .word     WWDG_IRQHandler                   /* Window WatchDog              */                                </span><br><span class="line">  .word     PVD_AVD_IRQHandler                /* PVD/AVD through EXTI Line detection */</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  .word     0                                 /* Reserved                   */  </span><br><span class="line">  .word     WAKEUP_PIN_IRQHandler             /* Interrupt for all 6 wake-up pins */</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">*</span><br><span class="line">* Provide weak aliases for each Exception handler to the Default_Handler. </span><br><span class="line">* As they are weak aliases, any function with the same name will override </span><br><span class="line">* this definition.</span><br><span class="line">* </span><br><span class="line">*******************************************************************************/</span><br><span class="line">   .weak      NMI_Handler</span><br><span class="line">   .thumb_set NMI_Handler,Default_Handler</span><br><span class="line">   // 等效于.set指令，创建了一个符号，该符号是另一个符号的别名（可能尚未定义）。 该指令还具有添加的属性，因为它以.thumb_func指令相同的方式将别名符号标记为thumb函数入口点。即NMI_Handler默认用Default_Handler替代，但同时NMI_Handler还是个若引用，因此当我们在程序里定义了这个中断服务函数的时候，就会替代这里。</span><br><span class="line"></span><br><span class="line">   .weak      HardFault_Handler</span><br><span class="line">   .thumb_set HardFault_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">   .weak      MemManage_Handler</span><br><span class="line">   .thumb_set MemManage_Handler,Default_Handler</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   .weak      SAI4_IRQHandler    </span><br><span class="line">   .thumb_set SAI4_IRQHandler,Default_Handler </span><br><span class="line"></span><br><span class="line">   .weak      WAKEUP_PIN_IRQHandler    </span><br><span class="line">   .thumb_set WAKEUP_PIN_IRQHandler,Default_Handler </span><br><span class="line"></span><br><span class="line">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/     COPY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-STM32链接脚本分析（基于GCC）"><a href="#3-STM32链接脚本分析（基于GCC）" class="headerlink" title="3 STM32链接脚本分析（基于GCC）"></a>3 STM32链接脚本分析（基于GCC）</h1><blockquote>
<p>需要注意的是，我们这里只介绍stm32在gcc中常用的关键字和命令，实际上 <code>Linker Scripts</code>所拥有的关键字和命令远远不止这些，如果我们真的想要去了解可以看一下以下这份文件：<a href="https://sourceware.org/binutils/docs/ld/index.html">Top (LD) (sourceware.org)</a></p>
<p>MDK、IAR、GCC三种编译器的链接脚本分别为link.sct（一般也称为分散加载文件）、link.icf、link.lds。</p>
</blockquote>
<p>链接脚本一般可以通过<strong>文本编辑器或链接脚本编辑器</strong>来进行操作。以下为在RT-Thread GCC环境下的文本编辑器和链接脚本编辑器。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431901125.png" alt="1701431901125"><br><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701431919611.png" alt="1701431919611"></p>
<p> <strong>编译的整个过程分为：预处理、编译、汇编和链接。</strong> 链接器的主要作用是将多个 <code>object(.o)</code>文件或 <code>archive(.a)</code>文件的内容重定位 <code>(relocate)</code>并将 <code>Symbol Reference</code>信息一并输出到二进制文件 <code>(Binary)</code>或其他可执行文件 <code>(.exe)</code>中。链接是编译产生二进制文件的最后一个步骤，在执行的过程中依照 <code>Link Command Language文件</code>描述的方式去产生二进制文件，<code>LD</code>文件支持<a href="[BFD (LD">不同的二进制格式</a> (sourceware.org)](<a href="https://sourceware.org/binutils/docs/ld/BFD.html#BFD))。">https://sourceware.org/binutils/docs/ld/BFD.html#BFD))。</a></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432005455.png" alt="1701432005455"></p>
<p>在我们的STM32中，常见的节定义有：</p>
<ol>
<li><code>.text</code>节：代码节，用来存放 <strong>代码</strong> 及一些  <strong>只读常量</strong> ，一般是只读的区域；</li>
<li><code>.data</code>节：数据节，用来存放全局初始化变量，以及全局或局部  <strong>静态变量</strong> ；</li>
<li><code>.bss</code>节：BSS 节，用来存放所有  <strong>未初始化的数据</strong> ，用 <code>0</code> 来初始化。</li>
</ol>
<p>一般而言，我们可以这么理解RAM和Flash（ROM）的关系， <strong>RAM 相当于内存，Flash（ROM）相当于硬盘</strong> 。</p>
<ul>
<li><strong>Flash（ROM）</strong> （烧录程序所占的Flash大小） = <code>text</code> + <code>data</code>。</li>
<li><strong>RAM</strong> （运行时占用的RAM大小） = <code>data</code> + <code>bss</code>。</li>
</ul>
<p>编译器会将程序分为好几个部分，分别存到MCU不同的存储区，对于RT-Thead来说，MCU在上电后，如果选择的是默认从 Flash 启动，启动之后会将 <code>RW</code> 节（等同于 <code>.bss</code>节+<code>.data</code>节， <strong>也就是说下面这张图里右侧应该是 <code>RW-data</code>和 <code>ZI</code>节</strong> ）中的 <code>RW-data</code>（初始化的全局变量，等同于 <code>.data</code>节）搬运到 RAM 中，但不会搬运 <code>RO</code>节（等同于 <code>.text</code>节），即 CPU 的执行代码从 Flash 中读取，另外根据编译器给出的 <code>ZI</code> 地址和大小分配出 <code>ZI</code>节（等同于 <code>.bss</code>节），并将这块 RAM 区域清零。</p>
<blockquote>
<p>其中动态内存堆为未使用的 RAM 空间，应用程序申请和释放的内存块都来自该空间。</p>
</blockquote>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432011203.png" alt="1701432011203"></p>
<p>而链接器和链接脚本文件的作用正是 <strong>把各个对象文件或对象库的各种输入段进行重新组合，存入输出段，生成可执行文件（输出文件）</strong> （即生成相应的可执行映像文件）。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432017423.png" alt="1701432017423"></p>
<p>下面是一些可能更合适的解释。</p>
<p>以下描述出于<a href="https://sourceware.org/binutils/">GNU Binutils (sourceware.org)</a>：</p>
<blockquote>
<p>Every link is controlled by a linker script. This script is written in the linker command language.</p>
<p>The main purpose of the linker script is to describe how the sections in the input files should be mapped into the output file, and to control the memory layout of the output file. Most inker scripts do nothing more than this.</p>
</blockquote>
<p>以下描述出于《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养 (豆瓣) (douban.com)</a>》：</p>
<blockquote>
<p>如果把整个链接过程比作一台计算机，那么ld链接器就是计算机的 <code>CPU</code>，所有的目标文件、库文件就是输入，链接结果输出的可执行文件就是输出，而链接控制脚本正是这台计算机的“程序”，它控制CPU的运行，以“程序”要求的方式将输入加工成所须要的输出结果。链接控制脚本“程序”使用一种特殊的语言写成，即 <code>ld</code>的链接脚本语言，这种语言并不复杂，只有为数不多的几种操作。无论是输出文件还是输入文件，它们的主要的数据就是 <strong>文件中的各种段</strong> ，我们把输入文件中的段称为 <strong>输入节（Input Sections）</strong> ，输出文件中的段称为 <strong>输出节（Output Sections）</strong> 。简单来讲， <strong>控制链接过程无非是控制输入节如何变成输出节</strong> ，比如哪些输入节要合并一个输出节，哪些输入节要丢弃；指定输出节的名字、装载地址、属性，等等。（一般链接脚本名都以 <code>lds</code>作为扩展名 <code>ld script</code>）。</p>
</blockquote>
<p>在研究链接脚本之间，最好对程序的编译和链接需要有一定的了解。</p>
<p>以下，基于STM32H750XBHx的一个链接脚本文件作分析，其他的芯片大同小异，可以根据参阅<a href="https://sourceware.org/binutils/docs/ld/index.html">Top (LD) (sourceware.org)</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * linker script for STM32H750XBHx with GNU ld</span><br><span class="line"> */COPY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-0-基本概念"><a href="#3-0-基本概念" class="headerlink" title="3.0 基本概念"></a>3.0 基本概念</h2><p>链接脚本将输入文件合并为单个输出文件（<code>.exe</code>，<code>.bin</code>，<code>.elf</code>等等）。输出文件和每个输入文件采用的是一种被称为<strong>目标文件格式</strong>的特殊数据格式。</p>
<p> <strong>每个文件都是一个目标文件</strong> 。 <strong>输出文件通常被称为可执行文件，但也可以称为目标文件</strong> 。</p>
<p>此外， <strong>每个目标文件都有一个节列表（<code>a list of sections</code>）</strong> ，有时我们将 <strong>输入文件的一个节称为输入节（<code>input section</code>，如何将输入文件映射到内存布局中）</strong> ，类似地， <strong>输出文件的一个节称为输出节（<code>input section</code>，最终的可执行文件在内存中是如何布局的）</strong> 。</p>
<p> <strong>目标文件的每个节都有一个节名和节大小</strong> 。大多数节也有一个相关的数据块，称为 <strong>节内容</strong> 。一个节可以被标记为 <strong>可加载的</strong> ，这意味着当输入文件运行时，节内容应该被加载到内容中。没有内容的节可以是 <strong>可分配的</strong> ，这意味着内存中的一个区域应该被留出，但不应该在该内存区域加载特别的内容（在某些情况下，内存必须被清零）。既可以<strong>不加载也可以不分配</strong>的节，通常包含了某种调试信息（<code>debugging information</code>）。</p>
<p>每个可加载或可分配的输出节都有两个地址。第一个是 <strong><code>VMA</code>或虚拟内存地址</strong> ，这是运行输出文件时，节将具有的地址。第二个是 <strong><code>LMA</code>或加载内存地址</strong> ，这是将加载节的地址。在大多数情况下，这两个地址是相同的（如PC机上）。一个不同的情况是，当一个数据节被加载到 <code>ROM</code>中，然后在程序启动时被复制到 <code>RAM</code>（这种技术通常用于初始化基于 <code>ROM</code>的系统的全局变量，如MCU上）。在这种情况下，<code>ROM</code>的地址为 <code>LMA</code>，而 <code>RAM</code>的地址为 <code>VMA</code>。</p>
<p>通过使用带有 <code>-h</code>选项的 <code>objdump</code>程序，可以查看目标文件中的节。</p>
<p>每个目标文件也有一个符号列表，称为符号表（<code>symbol table</code>）。符号可以是定义的，也可以是未定义的。每个符号都有一个名称，每个定义的符号都有地址等信息。如果将一个 <code>C</code>或 <code>C++</code>程序<strong>编译</strong>成一个目标文件，那么每一个定义的函数和全局变量或静态变量都将获得一个定义的符号。输入文件中引用的每个未定义函数或全局变量都将成为一个未定义的符号。</p>
<p>可以使用 <code>nm</code>程序或通过带有 <code>-t</code>选项的 <code>objdump</code>程序来查看目标文件中的符号。</p>
<blockquote>
<p>关于LMA和VMA可以参考这个链接：<a href="https://github.com/cisen/blog/issues/887">详解LMA &amp; VMA 【转】 · Issue #887 · cisen/blog (github.com)</a></p>
<p><a href="https://www.embeddedrelated.com/showthread/comp.arch.embedded/77071-1.php">VMA vs LMA? (embeddedrelated.com)</a></p>
</blockquote>
<h2 id="3-1-常用特殊符号"><a href="#3-1-常用特殊符号" class="headerlink" title="3.1 常用特殊符号"></a>3.1 常用特殊符号</h2><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1 ."></a>3.1.1 <code>.</code></h3><p>位置计数器，如果没有使用其他方式来定义输出节（<code>output section</code>）的地址，地址就会被设置为位置计数器的值。</p>
<p>位置计数器按输出节的大小递增，在 <code>&quot;SECTION&quot;</code>命令的开头，位置计数器的值为 <code>&quot;0&quot;</code>。</p>
<h3 id="3-1-2"><a href="#3-1-2" class="headerlink" title="3.1.2 *"></a>3.1.2 <code>*</code></h3><p>与任何文件名匹配的通配符，<code>*(.text)</code> 表示所有输入文件中的 <code>.text</code>输入节。</p>
<h2 id="3-2-常用关键字"><a href="#3-2-常用关键字" class="headerlink" title="3.2 常用关键字"></a>3.2 常用关键字</h2><h3 id="3-2-1-MEMORY"><a href="#3-2-1-MEMORY" class="headerlink" title="3.2.1 MEMORY"></a>3.2.1 <code>MEMORY</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">  &#123;</span><br><span class="line">    name [(attr)] : ORIGIN = origin, LENGTH = len</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>链接器默认配置允许分配所有可用的内存</strong> ，通过 <code>MEMORY</code>命令可以重载相应的内存。</p>
<p> <strong><code>MEMORY</code>命令描述了目标的内存块的位置和大小</strong> ，可以使用 <code>MEMORY</code>命令来描述哪些内存区域可以使用，哪些内存区域应该避免使用。可以给特定的内存区域分配节。链接器基于内存区域设置节地址，如果区域趋于饱和将会产生警告信息。链接器不会为了适应可用区域而打乱节的顺序。</p>
<p><strong>一个链接脚本可能包含多个 <code>MEMORY</code>命令，但所有定义的内存块都被视为是在单个 <code>MEMORY</code>命令中定义的。</strong></p>
<p><code>NAME</code>是链接脚本用来引用相应内存区域的名字。区域名称在链接脚本外部没有任何意义。区域名被存储在一个独立的名字空间，且不会与符号名，文件名，或者节名起冲突。每个内存区域必须在 <code>MEMORY</code>命令中有一个不同的名字。但是你此后可以使用 <code>REGION_ALIAS</code>命令为已存在的内存区域添加别名。</p>
<p><code>ATTR</code>字符是一个可选的属性列表，用来决定是否为一个脚本中没有显式指定映射的输入节使用一个特定的内存区域。就像 <code>SECTIONS</code>中进行过的说明，如果不为一个输入节指定一个输出节，链接器将会创建一个与输入节同名的输出节。如果定义了区域属性，链接器会使用他们来决定创建的输出节存放的内存区域。</p>
<p><code>ATTR</code>字符串只能使用下面的字符组成：</p>
<ol>
<li><code>&quot;R&quot;</code>只读节</li>
<li><code>&quot;W&quot;</code>读写节</li>
<li><code>&quot;X&quot;</code>可执行节</li>
<li><code>&quot;A&quot;</code>可分配节</li>
<li><code>&quot;I&quot;</code>已初始化节</li>
<li><code>&quot;L&quot;</code>类似于 <code>&quot;I&quot;</code></li>
<li><code>&quot;!&quot;</code>反转其后面的所有属性</li>
</ol>
<p>如果一个未映射的节与除 <code>&quot;!&quot;</code>外任意列出的属性匹配，它会被放置在内存区域中。<code>&quot;!&quot;</code>属性翻转对后面字符的测试，一个未映射的节与 <code>&quot;!&quot;</code>后列出的任意属性不匹配时，它才会被放置在内存中。因此属性 <code>&quot;RW!X&quot;</code>将匹配任何具有 <code>&quot;R&quot;</code>或 <code>&quot;W&quot;</code>属性但不具有 <code>&quot;X&quot;</code>属性的未映射的节。</p>
<p><code>ORIGIN</code>是一个表达式，代表了内存区域的起始地址。表达式的结果必须等价于一个常量并且不能含有任何符号。关键字 <code>ORIGIN</code>缩短为 <code>org</code>或者 <code>o</code>（但不能写成 <code>ORG</code>）。</p>
<p><code>LEN</code>是一个表达式，用来表示内存区域的字节数大小。类似于 <code>ORIGIN</code>表达式，表达式的结果必须等价于一个常量并且不能含有任何符号。关键字 <code>LENGTH</code>可以被缩写为 <code>len</code>或者 <code>l</code>。</p>
<p>以下是一个实例，我们指定了两个内存区域可以分配：一个从 <code>&quot;0&quot;</code>开始，分配256KB，一个从 <code>&quot;0x40000000&quot;</code>，分配4MB。</p>
<p>链接器会将每个非显式映射到具体内存区域的节放入 <code>rom</code>内存区域中，并且这些节必须是只读的或可执行的。链接器会将其他未显式映射到具体内存区域的节放入 <code>ram</code>内存区域中，并且这些节是不可只读且不可执行的。</p>
<p><strong>一旦定义了内存区域，就可以使用使用 <code>&gt;region</code>指令输出节属性来指导链接器将特定的输出节放入具体的内存区域中。</strong></p>
<p>例如，如果有一个内存区域名为 <code>mem</code>，则可以在输出节定义中使用 <code>&gt;mem</code>。如果没有为输出节指定地址，链接器会将地址设置为内存区域中的下一个可用地址。如果指向内存区域的组合输出节对相应内存区域来说太大了的话，链接器会发出错误消息。</p>
<p>可以通过 <code>ORIGIN(memory)</code>和 <code>LENGTH(memory)</code>函数来获取一个表达式中内存的起始地址和内存长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_fstack = ORIGIN(ram) + LENGTH(ram) - 4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-ENTRY"><a href="#3-2-2-ENTRY" class="headerlink" title="3.2.2 ENTRY"></a>3.2.2 <code>ENTRY</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(symbol)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在一个程序中最先被执行的指令称为入口点（<code>entry point</code>）。</p>
<p>使用 <code>ENTRY</code>命令可以设置入口点。</p>
<p>设置入口点的方式不止 <code>ENTRY</code>命令一种，链接器会按照顺序，尝试以下几种方式来设置入口点，并在其中一个成功时停止：</p>
<ol>
<li><code>-e</code>入口命令行选项；</li>
<li>链接脚本中的 <code>ENTRY(symbol)</code>命令；</li>
<li>目标特定符号的值（如果已经定义），对绝大多数目标来说，符号为 <code>start</code>，但对PE-和基于BeOS的系统来说，可能需要检查可能的输入符号列表，并与找到的第一个符号匹配；</li>
<li>代码节的第一个字节的地址，如果存在并且正在创建一个可执行文件，代码节通常是 <code>.text</code>，但也可以是其他符号；</li>
<li>地址0x0。</li>
</ol>
<h3 id="3-2-3-SECTION"><a href="#3-2-3-SECTION" class="headerlink" title="3.2.3 SECTION"></a>3.2.3 <code>SECTION</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  sections-command</span><br><span class="line">  sections-command</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>SECTION</code>命令告知链接器如何将输入节的内容映射到输出节中，以及如何在内存放放置输出节。</p>
<p>每个 <code>sections-command</code>可以是以下的其中之一：</p>
<ul>
<li><code>ENTRY</code>命令（see <a href="https://sourceware.org/binutils/docs/ld/Entry-Point.html">Entry command</a>）</li>
<li>符号赋值语句(see <a href="https://sourceware.org/binutils/docs/ld/Assignments.html">Assigning Values to Symbols</a>)</li>
<li>输出节的描述</li>
<li>覆盖描述（<code>overlay description</code>）</li>
</ul>
<p>其中，为了方便在这些命令中使用位置计数器 <code>.</code>，可以在 <code>SECTION</code>命令中使用 <code>ENTRY</code>命令和符号赋值语句。因为可以在输出文件的布局中有意义的位置使用这些名，使得链接脚本更容易理解。</p>
<h4 id="3-2-3-1-输出节描述"><a href="#3-2-3-1-输出节描述" class="headerlink" title="3.2.3.1 输出节描述"></a>3.2.3.1 输出节描述</h4><p>对于一个输出节的完整描述如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section [address] [(type)] :</span><br><span class="line">  [AT(lma)]</span><br><span class="line">  [ALIGN(section_align) | ALIGN_WITH_INPUT]</span><br><span class="line">  [SUBALIGN(subsection_align)]</span><br><span class="line">  [constraint]</span><br><span class="line">  &#123;</span><br><span class="line">    output-section-command</span><br><span class="line">    output-section-command</span><br><span class="line">    …</span><br><span class="line">  &#125; [&gt;region] [AT&gt;lma_region] [:phdr :phdr …] [=fillexp] [,]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大多数输出节并不需要用到绝大多数可选的节属性（参数）。</p>
<p> <strong>语法要求</strong> ：</p>
<ul>
<li>节周围的空格是必须的，以保证节名明确无误；</li>
<li>冒号和大括号是必需的；</li>
<li>如果使用了 <code>fillexp</code>，并且后一个 <code>sections-command</code>像是表达式的延续，那么结尾处的逗号 <code>&quot;,&quot;</code>可能是需要的；</li>
<li>换行符和其他空格是可选的。</li>
</ul>
<p>每个 <code>output-section-command</code> 可以是以下的其中之一：</p>
<ul>
<li>符号赋值语句(see <a href="https://sourceware.org/binutils/docs/ld/Assignments.html">Assigning Values to Symbols</a>)</li>
<li>输入节描述（see <a href="https://sourceware.org/binutils/docs/ld/Input-Section.html">Input Section Description</a>）</li>
<li>直接包含的数据值（see <a href="https://sourceware.org/binutils/docs/ld/Output-Section-Data.html">Output Section Data</a>）</li>
<li>特定的输出节 <strong>关键字</strong> (see <a href="https://sourceware.org/binutils/docs/ld/Output-Section-Keywords.html">Output Section Keywords</a>)</li>
</ul>
<h4 id="3-2-3-2-输出节名（必选）"><a href="#3-2-3-2-输出节名（必选）" class="headerlink" title="3.2.3.2 输出节名（必选）"></a>3.2.3.2 输出节名（必选）</h4><p><code>section</code>是输出节的名字，<code>section</code>必须满足输出的格式要求。在只支持有限数量的节的格式中，例如 <code>a.out</code>，节名必须是该格式支持的名称之一（例如，<code>a.out</code>只支持 <code>.text</code>，<code>.bss</code>和 <code>.data</code>这三种名称）。如果输出格式支持任意数量的节，包含数字而不是名称（Oasys就是如此），节名则应作为带引号的数字字符串提供。节名可以由任意字符序列组成，但必须包含任何异常字符（如逗号 <code>&quot;,&quot;</code>）的名称必须使用引号。</p>
<p>输出节名 <code>&quot;/DISCARD/&quot;</code>是特殊的。<a href="https://sourceware.org/binutils/docs/ld/Output-Section-Discarding.html">Output Section Discarding</a></p>
<h4 id="3-2-3-3-输出节地址（可选）"><a href="#3-2-3-3-输出节地址（可选）" class="headerlink" title="3.2.3.3 输出节地址（可选）"></a>3.2.3.3 输出节地址（可选）</h4><p><code>address</code>是输出节的 <code>VMA</code>（虚拟存储器地址）的一个表达式。该地址是可选的，但如果提供了该地址，那输出地址将完全按照指定的设置。</p>
<p>如果未指定输出地址，那么将按照几种的启发式（对照的）方法中的为该部分选择一个输出地址，该地址将进行调整，以符合输出节的对齐要求，对齐要求是输出节中包含的任何输入部分的最严格对齐方式。</p>
<p>设置输出节地址的启发式方法如下：</p>
<ul>
<li>如果为该节设置了输出内存区域，则将其添加至该区域，其地址为该区域内的下一个空闲地址；</li>
<li>如果 <code>MEMORY</code>命令已经用于创建内存区域列表，那么选择与该节有匹配的属性的第一个区域来容纳该节，该节的输出地址将是该区域中的下一个空闲地址；<a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">MEMORY Command</a></li>
<li>如果没有指定内存区域，或者没有匹配该节的内存区域，那么输出地址将基于位置计数器的当前值。</li>
</ul>
<p>例如，一下两条命令只有微妙的不同，第一条命令会设置 <code>.text</code>的输出节的地址到位置计数器的当前值，第二条指令会将 <code>.text</code>的输出节的地址设置为位置计数器的当前值，该值与任何 <code>.text</code>输入节中的最严格对齐方式的地方对齐。（The second will set it to the current value of the location counter aligned to the strictest alignment of any of the ‘.text’ input sections.）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text . : &#123; *(.text) &#125;</span><br><span class="line"></span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>地址可以是任意表达式（ <a href="https://sourceware.org/binutils/docs/ld/Expressions.html">Expressions in Linker Scripts</a>）。比如，如果想要将一个节对齐到0x10字节边界上，使节地址的最低四位为0，可以执行以下操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text ALIGN(0x10) : &#123; *(.text) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ALIGN</code>返回向上对齐到指定值的当前位置计数器。如果节为非空，则为节指定地址会改变位置计数器的值。（空节会被忽略）</p>
<h4 id="3-2-3-4-输入节描述（必选）output-section-command"><a href="#3-2-3-4-输入节描述（必选）output-section-command" class="headerlink" title="3.2.3.4 输入节描述（必选）output-section-command"></a>3.2.3.4 输入节描述（必选）output-section-command</h4><p><strong>最常见的 <code>output-section-command</code>命令是输入节描述。输入节描述是最基本的链接脚本操作。</strong></p>
<p><strong>通过输出节告知链接器如何在内存中布局程序。可以使用输入节描述来告知链接器如何将输入的文件映射到内存布局中。</strong></p>
<h5 id="3-2-3-4-1-输入节基础（Input-Section-Basics）"><a href="#3-2-3-4-1-输入节基础（Input-Section-Basics）" class="headerlink" title="3.2.3.4.1 输入节基础（Input Section Basics）"></a>3.2.3.4.1 输入节基础（Input Section Basics）</h5><p>一个输入节描述包括了一个可选的文件名以及其后的括号中的节名列表。</p>
<p>文件名和节名可以是通配符模式，我们可以在 <a href="https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html">Input Section Wildcard Patterns</a>中进一步描述。</p>
<p>最常用的输入节描述是在输出节中包含具有特定名称的所有输入端，例如，包含所有 <code>.text</code>节部分，可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(.text)</span><br><span class="line"></span><br><span class="line">//*表示与任何文件名匹配的通配符。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了排除与文件名通配符的匹配的文件列表，可以使用 <code>EXCLUDE_FILE</code>命令来匹配除了 <code>EXCLUDE_FILE</code>列表中指定的文件以外的所有文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXCLUDE_FILE (*crtend.o *otherfile.o) *(.ctors)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将导致包含除 <code>crtend.o</code>和 <code>otherfile.o</code>之外所有文件中的所有 <code>.ctors</code>节。</p>
<p>结果与之前的示例相同。如果节列表包含不止一个节，那么使用 <code>EXCLUDE_FILE</code>的两种语法会非常有用，如下描述。</p>
<p>包含超过一个节的方式有两种。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(.text .rdata)</span><br><span class="line">*(.text) *(.rdata)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>他们之间的区别 <strong>在于 <code>.text</code>与 <code>.rdata</code>的输入节出现在输出节中的顺序</strong> 。在第一个示例中，他们会混合在一起，出现的顺序与链接器输入过程中被发现的顺序相同。在第二个示例中，所有的 <code>.text</code>输入节会先出现，然后才是 <code>.rdata</code>。</p>
<p>对多个节使用 <code>EXCLUDE_FILE</code>命令，如果排除在节列表内，则排除仅适用于下一个紧跟的节，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(EXCLUDE_FILE (*somefile.o) .text .rdata)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会导致除 <code>somefile.o</code>外的所有文件中的 <code>.text</code>节会被包含，而包含 <code>somefile.o</code>在内的所有文件中的 <code>.rdata</code>节也会被包含。排除来自某个文件（<code>somefile.o</code>）中的 <code>.rdata</code>节，示例可以修改为以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(EXCLUDE_FILE (*somefile.o) .text EXCLUDE_FILE (*somefile.o) .rdata)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者，在选择输入文件前，将 <code>EXCLUDE_FILE</code>命令放在节列表外，将导致排除适用于所有节。示例可以修改为以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXCLUDE_FILE (*somefile.o) *(.text .rdata)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以指定一个文件名来包含一个具体文件中的节。如果一个或更多个文件中包含需要存放在内存中特定区域中的特殊数据，可以采取这种方式。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data.o(.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了根据输入节的节标志来细化包含的节，可以使用 <code>INPUT_SECTION_FLAGS</code> 命令。</p>
<p>下面是一个为 <code>ELF</code>节使用节标题标志的简单实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  .text : &#123; INPUT_SECTION_FLAGS (SHF_MERGE &amp; SHF_STRINGS) *(.text) &#125;</span><br><span class="line">  .text2 :  &#123; INPUT_SECTION_FLAGS (!SHF_WRITE) *(.text) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本例中，输出节 <code>.text</code>由任意与名称 <code>*(.text)</code>匹配的输入节组成，该输入节的节标题标志 <code>SHF_MERGE</code>和 <code>SHF_STRINGS</code>已设置。输出节 <code>.text2</code>由任意与名称 <code>*(.text)</code>匹配的输入节组成，其节标题标志 <code>SHF_WRITE</code>已被清除。</p>
<blockquote>
<p>以下还有一些部分此处不做解释，对我们这里的内容没有太大影响。</p>
<p>可以看这个链接：<a href="https://sourceware.org/binutils/docs/ld/Input-Section-Basics.html">Input Section Basics (LD) (sourceware.org)</a></p>
</blockquote>
<h5 id="3-2-3-4-2-输入节通配符模式"><a href="#3-2-3-4-2-输入节通配符模式" class="headerlink" title="3.2.3.4.2 输入节通配符模式"></a>3.2.3.4.2 输入节通配符模式</h5><p>在一个输入节描述中，文件名或节名都可以是通配符模式。</p>
<p>在以上许多示例中，可以看到 <code>*</code>的文件名是一个简单的文件名通配符模式，通配符模式与在Unix Shell中使用的模式类似。</p>
<hr>
<p><strong><code>*</code></strong></p>
<p>匹配任意数量的字符。</p>
<p><strong><code>?</code></strong></p>
<p>匹配任意单个字符。</p>
<p><strong><code>[chars]</code></strong></p>
<p>匹配任意字符的单个实例，<code>-</code>字符可用于指定字符范围，如 <code>[a-z]</code>可以匹配任意小写字母。</p>
<p><strong><code>\</code></strong></p>
<p>引用（用引号······扩起？）以下字符。</p>
<hr>
<blockquote>
<p>中间还有一些部分此处不做解释，对我们这里的内容没有太大影响。</p>
<p>可以看这个链接：<a href="https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html">Input Section Wildcards (LD) (sourceware.org)</a></p>
</blockquote>
<p>如果对输入节的去向感到困惑，可以使用链接器选项 <code>-M</code>来生成映射文件（<code>.map</code>），映射文件精确地显示了如何将输入节映射到输出节。</p>
<p>以下的示例和在哪个，显示了通配符模式如何对文件进行分区。此链接器脚本指示链接器放置所有的 <code>.text</code>节到 <code>.text</code>，所有的 <code>.bss</code>节到 <code>.bss</code>。链接器会将所有文件中以大写字母开头的 <code>.data</code>节放置在 <code>.DATA</code>中。对于其他文件，链接器将放置 <code>.data</code>节到 <code>.data</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  .text : &#123; *(.text) &#125;</span><br><span class="line">  .DATA : &#123; [A-Z]*(.data) &#125;</span><br><span class="line">  .data : &#123; *(.data) &#125;</span><br><span class="line">  .bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-4-3-通用符号（common-symbols）输入节"><a href="#3-2-3-4-3-通用符号（common-symbols）输入节" class="headerlink" title="3.2.3.4.3 通用符号（common symbols）输入节"></a>3.2.3.4.3 通用符号（common symbols）输入节</h5><p>通用符号需要特殊的符号，因为在许多目标文件格式中，通用符号并没有特定的输入节。<strong>链接器将通用符号视为位于名为 <code>COMMON</code>的输入节中。</strong></p>
<p>可以将文件名与 <code>COMMON</code>节一起使用，就像使用其他输入节一样，可以使用此选项将特定文件中的通用符号放置在一个节中，而其他输入文件的通用符号则放置在另一节中。</p>
<p>在绝大多数情况下，输入文件的通用符号放置在输出文件的 <code>.bss</code>节中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss &#123; *(.bss) *(COMMON) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些目标文件格式具有多种类型的通用符号。例如，<code>MIPS ELF</code>目标文件格式区分标准通用符号和小型通用符号。在这种情况下，链接器会为其他类型的通用符号使用不同的特殊节名。在 <code>MIPS ELF</code>的情况下，链接器使用 <code>COMMON</code>作为标准通用符号，使用 <code>scommon</code>作为小型通用符号。这允许将不同类型的通用符号映射到不同位置的内存中。</p>
<p>有时，可以在旧的链接器脚本中看到 <code>[COMMON]</code>，这种符号已经过时，相当于 <code>*(COMMON)</code>。</p>
<h5 id="3-2-3-4-4-输入节和垃圾收集（Input-Section-and-Garbage-Collection）"><a href="#3-2-3-4-4-输入节和垃圾收集（Input-Section-and-Garbage-Collection）" class="headerlink" title="3.2.3.4.4 输入节和垃圾收集（Input Section and Garbage Collection）"></a>3.2.3.4.4 输入节和垃圾收集（Input Section and Garbage Collection）</h5><p>当链接过程垃圾收集（<code>--gc-sections</code>）被使用时，标记不应删除的节通常很有用。这是通过使用 <code>KEEP()</code>包围输入节的通配符入口来实现的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KEEP(*(.init))</span><br><span class="line">KEEP(SORT_BY_NAME(*)(.ctors))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-4-5-输入节例程"><a href="#3-2-3-4-5-输入节例程" class="headerlink" title="3.2.3.4.5 输入节例程"></a>3.2.3.4.5 输入节例程</h5><p>以下示例是一个完整的链接器脚本。</p>
<p>这个脚本告知链接器从文件 <code>all.o</code>中读取所有的节，并将他们放置在从地址 <code>0x10000</code>节开始的输出节 <code>outputa</code>的开始处。在相同的输出节内，紧跟的是来自 <code>foo.o</code>文件中的所有 <code>.input1</code>节。来自 <code>foo.o</code>文件中的所有 <code>.input2</code>节存入输出节 <code>outputb</code>中，后面的是来自 <code>foo1.o</code>文件中的所有 <code>.input1</code>节。所有的来自任意文件的剩余的 <code>.input1</code>节和 <code>.input2</code>节被写入到输出节 <code>outputc</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  outputa 0x10000 :</span><br><span class="line">    &#123;</span><br><span class="line">    all.o</span><br><span class="line">    foo.o (.input1)</span><br><span class="line">    &#125;</span><br><span class="line">  outputb :</span><br><span class="line">    &#123;</span><br><span class="line">    foo.o (.input2)</span><br><span class="line">    foo1.o (.input1)</span><br><span class="line">    &#125;</span><br><span class="line">  outputc :</span><br><span class="line">    &#123;</span><br><span class="line">    *(.input1)</span><br><span class="line">    *(.input2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果输出节和输入节的名称相同，并可以用C标识符表示，那么链接器将自动发现 <code>PROVIDE</code>的两个符号：<code>__start_SECNAME</code>和 <code>__stop_CNAME</code>，其中 <code>SECNAME</code>是节的名称。它们分别知识输出节的起始地址和结束地址。</p>
<blockquote>
<p>注：大多数节名不能表示为C标识符，因为他们包含 <code>&quot;.&quot;</code>字符。</p>
</blockquote>
<h4 id="3-2-3-5-输出节数据（可选，Output-Section-Data）"><a href="#3-2-3-5-输出节数据（可选，Output-Section-Data）" class="headerlink" title="3.2.3.5 输出节数据（可选，Output Section Data）"></a>3.2.3.5 输出节数据（可选，<a href="https://sourceware.org/binutils/docs/ld/Output-Section-Data.html">Output Section Data</a>）</h4><p>暂不解释。</p>
<h4 id="3-2-3-6-输出节关键字（可选，Output-Section-Keywords）"><a href="#3-2-3-6-输出节关键字（可选，Output-Section-Keywords）" class="headerlink" title="3.2.3.6 输出节关键字（可选，Output Section Keywords）"></a>3.2.3.6 输出节关键字（可选，<a href="https://sourceware.org/binutils/docs/ld/Output-Section-Keywords.html">Output Section Keywords</a>）</h4><p>暂不解释。</p>
<h4 id="3-2-3-7-输出节丢弃（可选，Output-Section-Discarding）"><a href="#3-2-3-7-输出节丢弃（可选，Output-Section-Discarding）" class="headerlink" title="3.2.3.7 输出节丢弃（可选，Output Section Discarding）"></a>3.2.3.7 输出节丢弃（可选，<a href="https://sourceware.org/binutils/docs/ld/Output-Section-Discarding.html">Output Section Discarding</a>）</h4><p>暂不解释。</p>
<h4 id="3-2-3-8-输出节属性（可选，Output-Section-Attributes）"><a href="#3-2-3-8-输出节属性（可选，Output-Section-Attributes）" class="headerlink" title="3.2.3.8 输出节属性（可选，Output Section Attributes）"></a>3.2.3.8 输出节属性（可选，<a href="https://sourceware.org/binutils/docs/ld/Output-Section-Attributes.html">Output Section Attributes</a>）</h4><p>一个完整的输出节描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section [address] [(type)] :</span><br><span class="line">  [AT(lma)]</span><br><span class="line">  [ALIGN(section_align) | ALIGN_WITH_INPUT]</span><br><span class="line">  [SUBALIGN(subsection_align)]</span><br><span class="line">  [constraint]</span><br><span class="line">  &#123;</span><br><span class="line">    output-section-command</span><br><span class="line">    output-section-command</span><br><span class="line">    …</span><br><span class="line">  &#125; [&gt;region] [AT&gt;lma_region] [:phdr :phdr …] [=fillexp]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的内容已经描述了 <code>section</code>，<code>address</code>和 <code>output-section-command</code>，下面对其他内容进行描述。</p>
<h5 id="3-2-3-8-1-输出节类型（type）"><a href="#3-2-3-8-1-输出节类型（type）" class="headerlink" title="3.2.3.8.1 输出节类型（type）"></a>3.2.3.8.1 输出节类型（<code>type</code>）</h5><p>每一个输出节都有一个类型，也就是关键字 <code>type</code>，定义了以下类型：</p>
<ol>
<li><code>NOLOAD</code>：该节被标记为 <strong>不可加载</strong> ，以保证在程序运行过程中不会被加载到内存中。</li>
<li><code>READONLY</code>：该节被标记为 <strong>只读</strong> 。</li>
<li><code>DESCT</code>：</li>
<li><code>COPY</code>：</li>
<li><code>INFO</code>：</li>
<li><code>OVERLAY</code>：这些类型名用于向后（<code>backward</code>）兼容，很少使用，具有相同的效果，即该节应标记为 <strong>不可分配</strong> ，程序运行过程中也不会为该节分配内存。</li>
<li><code>TYPE = type</code>：设置节类型为整型 <code>type</code>。在生成 <code>ELF</code>输出文件，类型名称 <code>SHT_PROGBITS</code>，<code>SHT_STRTAB</code>，<code>SHT_NOTE</code>， <code>SHT_NOBITS</code>，<code>SHT_INIT_ARRAY</code>, <code>SHT_FINI_ARRAY</code>，和 <code>SHT_PREINIT_ARRAY</code>也可以用于 <code>type</code>。用户有责任确保节类型的任意特殊要求得到满足。</li>
<li><p><code>READONLY ( TYPE = type )</code>：这个语句形式通过 <code>type</code>将 <code>READONLY</code>类型和类型指定结合在一起。</p>
<p><strong>链接器通常按照映射到输出节的输入节的属性设置输出节的属性，可以通过使用节类型来重载这个过程。</strong> 例如，在以下的脚本示例中，<code>ROM</code>节位于内存地址 <code>0</code>处，且不需要在程序运行过程中被载入。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  ROM 0 (NOLOAD) : &#123; … &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-8-2-输出节-LMA"><a href="#3-2-3-8-2-输出节-LMA" class="headerlink" title="3.2.3.8.2 输出节 LMA"></a>3.2.3.8.2 输出节 <code>LMA</code></h5><p>每个节都有一个虚拟地址（<code>VMA</code>）和一个加载地址（<code>LMA</code>）（ <a href="https://sourceware.org/binutils/docs/ld/Basic-Script-Concepts.html">Basic Linker Script Concepts</a>）。<code>VMA</code>可以参考 <a href="https://sourceware.org/binutils/docs/ld/Output-Section-Address.html">Output Section Address</a> ，也可以参考 <code>1.3.3</code>节。 <strong><code>LMA</code>通常由 <code>AT</code>和 <code>AT&gt;</code>关键字指定。</strong> 是否指定 <code>LMA</code>是可选的。</p>
<p><code>AT</code>关键字将表达式作为参数，这指定了节的确切加载地址。<code>AT&gt;</code>关键字以内存区域的名称作为参数（<a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">MEMORY Command</a>），节的加载地址设置为区域内下一个空闲地址，按节的对齐要求对齐。</p>
<p>如果未为可分配部分指定 <code>AT</code>和 <code>AT&gt;</code>，链接器会使用以下的启发式方法来决定 <code>LMA</code>：</p>
<ol>
<li>如果该节具有特定的 <code>VMA</code>地址，那么这也用作 <code>LMA</code>地址；</li>
<li>如果该节不可分配，那么其 <code>LMA</code>被设置为 <code>VMA</code>；</li>
<li>否则，如果可以找到与当前节兼容的存储器区域，并且该区域包含至少一个节，则 <code>LMA</code>被设置为使得 <code>VMA</code>和 <code>LMA</code>之间的差异与定位区域中的最后一个节的 <code>VMA</code>和 <code>LMA</code>之间的差异相同；（Otherwise if a memory region can be found that is compatible with the current section, and this region contains at least one section, then the LMA is set so the difference between the VMA and LMA is the same as the difference between the VMA and LMA of the last section in the located region.）</li>
<li>如果没有声明内存区域，则使用在上一步中覆盖整个地址空间的默认区域；</li>
<li>如果没有找到合适的区域，或者没有找到先前的节，那么 <code>LMA</code>被设置为等于 <code>VMA</code>。</li>
</ol>
<p>这个功能旨在使构建 <code>ROM</code>映像更容易。例如，以下链接器脚本创建三个输出节：一个名为 <code>.text</code>的节，开始于 <code>0x1000</code>，一个名为 <code>.mdata</code>的节，在 <code>.text</code>节的末尾加载，即使它的 <code>VMA</code>是 <code>0x2000</code>，一个名为 <code>.bss</code>的节，保存地址 <code>0x3000</code>处的未初始化数据。符号 <code>_data</code>由值 <code>0x2000</code>定义，表明了位置计数器保存 <code>VMA</code>的值，而不是 <code>LMA</code>的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">  &#123;</span><br><span class="line">  .text 0x1000 : &#123; *(.text) _etext = . ; &#125;</span><br><span class="line">  .mdata 0x2000 :</span><br><span class="line">    AT ( ADDR (.text) + SIZEOF (.text) )</span><br><span class="line">    &#123; _data = . ; *(.data); _edata = . ;  &#125;</span><br><span class="line">  .bss 0x3000 :</span><br><span class="line">    &#123; _bstart = . ;  *(.bss) *(COMMON) ; _bend = . ;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与使用此链接器脚本生成的程序一起使用的运行时间的初始化代码将包括以下内容，以将初始化数据从 <code>ROM</code>映像中复制到它运行时间的地址。注意此代码如何利用链接器脚本定义的符号。</p>
<h5 id="3-2-3-8-3-强制输出对齐（ALIGN）"><a href="#3-2-3-8-3-强制输出对齐（ALIGN）" class="headerlink" title="3.2.3.8.3 强制输出对齐（ALIGN）"></a>3.2.3.8.3 强制输出对齐（<code>ALIGN</code>）</h5><p>可以使用 <code>ALIGN</code>指令来增加一个输出节的对齐方式。作为替代方案，可以使用 <code>ALIGN_WITH_INPUT</code>属性来强制在整个输出节中的 <code>VMA</code>和 <code>LMA</code>之间的差异保持不变。</p>
<h5 id="3-2-3-8-4-强制输入对齐（SUBALIGN）"><a href="#3-2-3-8-4-强制输入对齐（SUBALIGN）" class="headerlink" title="3.2.3.8.4 强制输入对齐（SUBALIGN）"></a>3.2.3.8.4 强制输入对齐（<code>SUBALIGN</code>）</h5><p>可以使用 <code>SUBALIGN</code>在输出节中强制输入节对齐。指定的值将覆盖输入节给定的任何对齐方式，无论是较大还是较小。</p>
<h5 id="3-2-3-8-5-输出节约束（constraint）"><a href="#3-2-3-8-5-输出节约束（constraint）" class="headerlink" title="3.2.3.8.5 输出节约束（constraint）"></a>3.2.3.8.5 输出节约束（<code>constraint</code>）</h5><p>通过分别使用关键字 <code>ONLY_IF_RO</code>和 <code>ONLY_IF_RW</code>，可以指定仅当输出节的所有输入节都是只读的或所有输入部分是读写的时才创建输出节。</p>
<h5 id="3-2-3-8-6-输出节区域（-gt-region）"><a href="#3-2-3-8-6-输出节区域（-gt-region）" class="headerlink" title="3.2.3.8.6 输出节区域（&gt;region）"></a>3.2.3.8.6 输出节区域（<code>&gt;region</code>）</h5><p>可以使用 <code>&gt;region</code>将节分配给先前定义的内存区域。See <a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">MEMORY Command</a>.</p>
<p>此处有一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123; rom : ORIGIN = 0x1000, LENGTH = 0x1000 &#125;</span><br><span class="line">SECTIONS &#123; ROM : &#123; *(.text) &#125; &gt;rom &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-8-7-输出节Phdr（-phdr）"><a href="#3-2-3-8-7-输出节Phdr（-phdr）" class="headerlink" title="3.2.3.8.7 输出节Phdr（:phdr）"></a>3.2.3.8.7 输出节Phdr（<code>:phdr</code>）</h5><p>可以使用 <code>:phdr</code>将节分配给之前定义的程序节。See <a href="https://sourceware.org/binutils/docs/ld/PHDRS.html">PHDRS Command</a>.</p>
<p>如果一个节被分配给一个或多个部分，则所有后续分配的节也将分配给那些部分，除非它们显式使用了 <code>:phdr</code>修饰符。可以使用 <code>:NONE</code>告诉链接器不要将节任何部分中。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHDRS &#123; text PT_LOAD ; &#125;</span><br><span class="line">SECTIONS &#123; .text : &#123; *(.text) &#125; :text &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-8-8-输出节填充（-fillexp）"><a href="#3-2-3-8-8-输出节填充（-fillexp）" class="headerlink" title="3.2.3.8.8 输出节填充（=fillexp）"></a>3.2.3.8.8 输出节填充（<code>=fillexp</code>）</h5><p>可以使用 <code>=fillexp</code>设置整个节的填充方式，<code>fillexp</code>是一个表达式（see <a href="https://sourceware.org/binutils/docs/ld/Expressions.html">Expressions in Linker Scripts</a>）。输出节中任何其他未指定的内存区域（例如，由于输入节需要对齐而留下的间隙）将填充该值，必要时重复该值。如果填充表达式是一个简单的十六进制表达式，即以 <code>0x</code>开头的十六进制数字字符串，并且后面没有 <code>k</code>或 <code>M</code>，则可以使用任意长的十六进制序列来指定填充方式；前导的零也成为方式的一部分。对于其他所有情况，包括额外的括号或一个一元的 <code>+</code>，填充方式是表达式值的四个最低有效字节。在所有情况下，数字都是大端结构。</p>
<p>此外，也可以使用 <code>output section commands</code>中的 <code>FILL&lt;span&gt; &lt;/span&gt;</code>命令更改填充值。（see <a href="https://sourceware.org/binutils/docs/ld/Output-Section-Data.html">Output Section Data</a>）</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123; .text : &#123; *(.text) &#125; =0x90909090 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-9-覆盖说明（可选，Overlay-Description）"><a href="#3-2-3-9-覆盖说明（可选，Overlay-Description）" class="headerlink" title="3.2.3.9 覆盖说明（可选，Overlay Description）"></a>3.2.3.9 覆盖说明（可选，Overlay Description）</h4><p>一个覆盖描述提供了一种简单的方式，来描述作为单个存储器映像的一部分被加载但将在同一存储器地址运行的节。在运行时，某种类型的覆盖管理器会根据需要将覆盖的部分从运行时的内存地址复制进去或复制出来，可能只需要简单地操作寻址位。例如当内存的某个区域比另一个区域快时，这种方法就会很有用。</p>
<p>使用 <code>Overlay</code>命令来描述覆盖。<code>Overlay</code>命令在 <code>SECTIONS</code>命令中使用，与输出节描述类似。<code>Overlay</code>命令的完整语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OVERLAY [start] : [NOCROSSREFS] [AT ( ldaddr )]</span><br><span class="line">  &#123;</span><br><span class="line">    secname1</span><br><span class="line">      &#123;</span><br><span class="line">        output-section-command</span><br><span class="line">        output-section-command</span><br><span class="line">        …</span><br><span class="line">      &#125; [:phdr…] [=fill]</span><br><span class="line">    secname2</span><br><span class="line">      &#123;</span><br><span class="line">        output-section-command</span><br><span class="line">        output-section-command</span><br><span class="line">        …</span><br><span class="line">      &#125; [:phdr…] [=fill]</span><br><span class="line">    …</span><br><span class="line">  &#125; [&gt;region] [:phdr…] [=fill] [,]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了 <code>Overlay</code>（关键字）外，所有的内容都是可选的，并且每个节都必须有一个名称（如 <code>secname1</code>和 <code>secname2</code>）。<code>Overlay</code>结构中的节定义与通常的 <code>SECTIONS</code>结构中的定义相同(see <a href="https://sourceware.org/binutils/docs/ld/SECTIONS.html">SECTIONS Command</a>)，除了一点，<code>Overlay</code>中的节不能定义地址和内存区域。</p>
<p>如果使用了填充，并且 <code>sections-command</code>命令看起来像表达式的延续（？），则可能需要结尾处的逗号（<code>,</code>）。（The comma at the end may be required if a fill is used and the next sections-command looks like a continuation of the expression.）</p>
<p>这些节都是使用相同的起始地址定义的。这些节的 <code>LMA</code>的排列应使其在内存中从用于整个 <code>Overlay</code>的加载地址开始连续（与正常的节定义一样，加载地址是可选的，默认是起始地址；起始地址也是可选，并且默认为位置计数器的当前值）。</p>
<p>如果使用了 <code>NOCROSSREFS</code>关键字，并且节之间存在任何引用，链接器将报告错误。由于这些节都在同一地址运行，因此一个节直接引用另一个节通常没有意义。（See <a href="https://sourceware.org/binutils/docs/ld/Miscellaneous-Commands.html">NOCROSSREFS</a>.）</p>
<p>对于 <code>OVERLAY</code>中的每个节，链接器会自动提供两个符号。符号 <code>__load_start_secname</code>定义为节的起始加载地址。符号 <code>__load_stop_secname</code>定义为节的最终加载地址。<code>secname</code>中任何在 <code>C</code>标识符中不合法的字符都将被删除。<code>C</code>（或汇编程序）代码可以根据需要使用这些符号来移动重叠的部分。</p>
<p>在覆盖结束时，位置计数器的值设置为覆盖的起始地址加上最大部分的大小。</p>
<p>这里有一个例子。请记住，这将出现在 <code>SECTIONS</code>结构中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OVERLAY 0x1000 : AT (0x4000)</span><br><span class="line"> &#123;</span><br><span class="line">   .text0 &#123; o1/*.o(.text) &#125;</span><br><span class="line">   .text1 &#123; o2/*.o(.text) &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这定义了从地址 <code>0x1000</code>开始的 <code>.text0</code>和 <code>.text1</code>。<code>.text0</code>会被加载到地址 <code>0x4000</code>，而 <code>.text1</code>将被加载到 <code>.text0</code>后。如果被引用，将定义以下符号：<code>__load_start_text0</code>, <code>__load_stop_text0</code>, <code>__load_start_text1</code>, <code>__load_stop_text1</code>。</p>
<p>将覆盖 <code>.text1</code>复制到覆盖区域的C代码可能如下所示。</p>
<blockquote>
<p>注：<code>OVERLAY</code>命令只是语法糖，因为它所做的一切都可以使用更基本的命令来完成。上面的例子可以写成如下。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text0 0x1000 : AT (0x4000) &#123; o1/*.o(.text) &#125;</span><br><span class="line">PROVIDE (__load_start_text0 = LOADADDR (.text0));</span><br><span class="line">PROVIDE (__load_stop_text0 = LOADADDR (.text0) + SIZEOF (.text0));</span><br><span class="line">.text1 0x1000 : AT (0x4000 + SIZEOF (.text0)) &#123; o2/*.o(.text) &#125;</span><br><span class="line">PROVIDE (__load_start_text1 = LOADADDR (.text1));</span><br><span class="line">PROVIDE (__load_stop_text1 = LOADADDR (.text1) + SIZEOF (.text1));</span><br><span class="line">. = 0x1000 + MAX (SIZEOF (.text0), SIZEOF (.text1));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-PROVIDE"><a href="#3-2-4-PROVIDE" class="headerlink" title="3.2.4 PROVIDE"></a>3.2.4 <code>PROVIDE</code></h3><p>参考：<a href="https://sourceware.org/binutils/docs/ld/PROVIDE.html">PROVIDE (LD) (sourceware.org)</a></p>
<p>在某些情况下，仅在符号被引用且未被链接中包含的任何对象定义时，链接器脚本才需要定义符号。例如，传统链接器定义了符号 <code>etext</code>。而 <code>ANSI C</code>中要求用户能够使用 <code>etext</code>作为函数名，而且不会遇到错误。<code>PROVIDE</code>关键字只能用于定义符号，如 <code>etext</code>，但前提是它被引用但未被定义。语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROVIDE(symbol = expression)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是使用 <code>PROVIDE</code>定义 <code>etext</code>的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">    &#123;</span><br><span class="line">      *(.text)</span><br><span class="line">      _etext = .;</span><br><span class="line">      PROVIDE(etext = .);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本例中，如果程序中定义了 <code>_etext</code>（带前导下划线），链接器将给出一个多定义诊断提示。另一方面，如果程序中定义了 <code>etext</code>（不带前导下划线），链接器将在程序中无声地使用该定义。如果程序引用了 <code>etext</code>，但没有定义 <code>etext</code>，链接器将会使用链接器脚本中地定义。</p>
<blockquote>
<p>注：<code>PROVIDE</code>指令认为要定义通用符号，即使这样的符号可以与 <code>PROVIDE</code>指令将创建的符号组合。当考虑析构函数和析构函数列表符号（如 <code>__CTOR_LIST__</code>）时，这一点尤为重要，因为它们通常被定义为通用符号。</p>
</blockquote>
<h2 id="3-3-指定ROM和RAM"><a href="#3-3-指定ROM和RAM" class="headerlink" title="3.3 指定ROM和RAM"></a>3.3 指定ROM和RAM</h2><blockquote>
<p>如果需要使用外部存储器，如需要XIP和BootRom之类的功能，我们也需要设置存储Bank的区域和大小。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    ROM (rx) : ORIGIN =0x08000000,LENGTH =128k</span><br><span class="line">    RAM (rw) : ORIGIN =0x24000000,LENGTH =512k</span><br><span class="line">&#125;COPY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-4-指定程序入口"><a href="#3-4-指定程序入口" class="headerlink" title="3.4 指定程序入口"></a>3.4 指定程序入口</h2><p>将符号 <code>Reset_Handler</code>设置为入口地址，入口地址是进程执行的第一条指令在进程地址空间的地址，<code>ENTRY(Reset_Handler)</code>表示程序最开始从复位中断服务函数处开始执行。Reset_Handler定义在startup_stm32f407xx.s启动文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-5-指定堆栈大小"><a href="#3-5-指定堆栈大小" class="headerlink" title="3.5 指定堆栈大小"></a>3.5 指定堆栈大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_system_stack_size = 0x200;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指定栈大小，并结合后面的节的定义，设置栈顶和栈底。</p>
<p>此处由于使用的是RTT，因此多余的RAM会被内存堆管理器管理，无需分配堆。</p>
<h2 id="3-6-指定各个节定义"><a href="#3-6-指定各个节定义" class="headerlink" title="3.6 指定各个节定义"></a>3.6 指定各个节定义</h2><p>以下是完整的段定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    .text :                             /* 输出节名 */</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);                   /* 四字节对齐, 位置计数器对齐到下一个对齐边界 */</span><br><span class="line">        _stext = .;                     /* 记录.text节的开始位置 */</span><br><span class="line">        KEEP(*(.isr_vector))            /* Startup code, 标记.isr_vector节的内容不应被消除，避免被编译器优化，</span><br><span class="line">                                            同时向量表放在.text段最开始的位置 */</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);           </span><br><span class="line">        *(.text)                        /* remaining code, 将匹配的输入节放入输出节中 */</span><br><span class="line">        *(.text.*)                      /* remaining code */</span><br><span class="line">        *(.rodata)                      /* read-only data (constants) */</span><br><span class="line">        *(.rodata*) </span><br><span class="line">        *(.glue_7)</span><br><span class="line">        *(.glue_7t)</span><br><span class="line">        *(.gnu.linkonce.t*)</span><br><span class="line"></span><br><span class="line">        /* section information for finsh shell */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __fsymtab_start = .;</span><br><span class="line">        KEEP(*(FSymTab))</span><br><span class="line">        __fsymtab_end = .;</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __vsymtab_start = .;</span><br><span class="line">        KEEP(*(VSymTab))</span><br><span class="line">        __vsymtab_end = .;</span><br><span class="line"></span><br><span class="line">        /* section information for utest */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __rt_utest_tc_tab_start = .;</span><br><span class="line">        KEEP(*(UtestTcTab))</span><br><span class="line">        __rt_utest_tc_tab_end = .;</span><br><span class="line"></span><br><span class="line">        /* section information for at server */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __rtatcmdtab_start = .;</span><br><span class="line">        KEEP(*(RtAtCmdTab))</span><br><span class="line">        __rtatcmdtab_end = .;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">        /* section information for initial. */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __rt_init_start = .;</span><br><span class="line">        KEEP(*(SORT(.rti_fn*)))</span><br><span class="line">        __rt_init_end = .;</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">        PROVIDE(__ctors_start__ = .);           /* 提供__ctors_start__符号 */</span><br><span class="line">        KEEP (*(SORT(.init_array.*)))</span><br><span class="line">        KEEP (*(.init_array))</span><br><span class="line">        PROVIDE(__ctors_end__ = .);</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">        _etext = .;                             /* 记录.text节的结束地址 */</span><br><span class="line">    &#125; &gt; ROM = 0                                 /* .text节存入ROM */</span><br><span class="line"></span><br><span class="line">    /* .ARM.exidx is sorted, so has to go in its own output section.  */</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    .ARM.exidx :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.ARM.exidx* .gnu.linkonce.armexidx.*)</span><br><span class="line"></span><br><span class="line">        /* This is used by the startup in order to initialize the .data secion */</span><br><span class="line">        _sidata = .;</span><br><span class="line">    &#125; &gt; ROM</span><br><span class="line">    __exidx_end = .;</span><br><span class="line"></span><br><span class="line">    /* .data section which is used for initialized data */</span><br><span class="line"></span><br><span class="line">    .data : AT (_sidata)</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .data secion */</span><br><span class="line">        _sdata = . ;</span><br><span class="line"></span><br><span class="line">        *(.data)</span><br><span class="line">        *(.data.*)</span><br><span class="line">        *(.gnu.linkonce.d*)</span><br><span class="line"></span><br><span class="line">        PROVIDE(__dtors_start__ = .);</span><br><span class="line">        KEEP(*(SORT(.dtors.*)))</span><br><span class="line">        KEEP(*(.dtors))</span><br><span class="line">        PROVIDE(__dtors_end__ = .);</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .data secion */</span><br><span class="line">        _edata = . ;</span><br><span class="line">    &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">    .stack : </span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _sstack = .;</span><br><span class="line">        . = . + _system_stack_size;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _estack = .;</span><br><span class="line">    &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">        _sbss = .;</span><br><span class="line"></span><br><span class="line">        *(.bss)</span><br><span class="line">        *(.bss.*)</span><br><span class="line">        *(COMMON)</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">        _ebss = . ;</span><br><span class="line"></span><br><span class="line">        *(.bss.init)</span><br><span class="line">    &#125; &gt; RAM</span><br><span class="line">    __bss_end = .;</span><br><span class="line"></span><br><span class="line">    _end = .;</span><br><span class="line"></span><br><span class="line">    /* 以下部分用于调试，即不可加载也不可分配  */</span><br><span class="line">    /* Stabs debugging sections.  */</span><br><span class="line">    .stab          0 : &#123; *(.stab) &#125;</span><br><span class="line">    .stabstr       0 : &#123; *(.stabstr) &#125;</span><br><span class="line">    .stab.excl     0 : &#123; *(.stab.excl) &#125;</span><br><span class="line">    .stab.exclstr  0 : &#123; *(.stab.exclstr) &#125;</span><br><span class="line">    .stab.index    0 : &#123; *(.stab.index) &#125;</span><br><span class="line">    .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125;</span><br><span class="line">    .comment       0 : &#123; *(.comment) &#125;</span><br><span class="line">    /* DWARF debug sections.</span><br><span class="line">     * Symbols in the DWARF debugging sections are relative to the beginning</span><br><span class="line">     * of the section so we begin them at 0.  */</span><br><span class="line">    /* DWARF 1 */</span><br><span class="line">    .debug          0 : &#123; *(.debug) &#125;</span><br><span class="line">    .line           0 : &#123; *(.line) &#125;</span><br><span class="line">    /* GNU DWARF 1 extensions */</span><br><span class="line">    .debug_srcinfo  0 : &#123; *(.debug_srcinfo) &#125;</span><br><span class="line">    .debug_sfnames  0 : &#123; *(.debug_sfnames) &#125;</span><br><span class="line">    /* DWARF 1.1 and DWARF 2 */</span><br><span class="line">    .debug_aranges  0 : &#123; *(.debug_aranges) &#125;</span><br><span class="line">    .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125;</span><br><span class="line">    /* DWARF 2 */</span><br><span class="line">    .debug_info     0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125;</span><br><span class="line">    .debug_abbrev   0 : &#123; *(.debug_abbrev) &#125;</span><br><span class="line">    .debug_line     0 : &#123; *(.debug_line) &#125;</span><br><span class="line">    .debug_frame    0 : &#123; *(.debug_frame) &#125;</span><br><span class="line">    .debug_str      0 : &#123; *(.debug_str) &#125;</span><br><span class="line">    .debug_loc      0 : &#123; *(.debug_loc) &#125;</span><br><span class="line">    .debug_macinfo  0 : &#123; *(.debug_macinfo) &#125;</span><br><span class="line">    /* SGI/MIPS DWARF 2 extensions */</span><br><span class="line">    .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125;</span><br><span class="line">    .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125;</span><br><span class="line">    .debug_typenames 0 : &#123; *(.debug_typenames) &#125;</span><br><span class="line">    .debug_varnames  0 : &#123; *(.debug_varnames) &#125;</span><br><span class="line">&#125;COPY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-7-完整的链接脚本示例"><a href="#3-7-完整的链接脚本示例" class="headerlink" title="3.7 完整的链接脚本示例"></a>3.7 完整的链接脚本示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * linker script for STM32H750XBHx with GNU ld</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* Program Entry, set to mark it as &quot;used&quot; and avoid gc */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">ROM (rx) : ORIGIN =0x08000000,LENGTH =128k</span><br><span class="line">RAM (rw) : ORIGIN =0x24000000,LENGTH =512k</span><br><span class="line">&#125;</span><br><span class="line">ENTRY(Reset_Handler)</span><br><span class="line">_system_stack_size = 0x200;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _stext = .;</span><br><span class="line">        KEEP(*(.isr_vector))            /* Startup code, 向量表放在.text节最开始的部分 */</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        *(.text)                        /* remaining code */</span><br><span class="line">        *(.text.*)                      /* remaining code */</span><br><span class="line">        *(.rodata)                      /* read-only data (constants) */</span><br><span class="line">        *(.rodata*)</span><br><span class="line">        *(.glue_7)</span><br><span class="line">        *(.glue_7t)</span><br><span class="line">        *(.gnu.linkonce.t*)</span><br><span class="line"></span><br><span class="line">        /* section information for finsh shell */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __fsymtab_start = .;</span><br><span class="line">        KEEP(*(FSymTab))</span><br><span class="line">        __fsymtab_end = .;</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __vsymtab_start = .;</span><br><span class="line">        KEEP(*(VSymTab))</span><br><span class="line">        __vsymtab_end = .;</span><br><span class="line"></span><br><span class="line">        /* section information for utest */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __rt_utest_tc_tab_start = .;</span><br><span class="line">        KEEP(*(UtestTcTab))</span><br><span class="line">        __rt_utest_tc_tab_end = .;</span><br><span class="line"></span><br><span class="line">        /* section information for at server */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __rtatcmdtab_start = .;</span><br><span class="line">        KEEP(*(RtAtCmdTab))</span><br><span class="line">        __rtatcmdtab_end = .;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">        /* section information for initial. */</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __rt_init_start = .;</span><br><span class="line">        KEEP(*(SORT(.rti_fn*)))</span><br><span class="line">        __rt_init_end = .;</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">        PROVIDE(__ctors_start__ = .);</span><br><span class="line">        KEEP (*(SORT(.init_array.*)))</span><br><span class="line">        KEEP (*(.init_array))</span><br><span class="line">        PROVIDE(__ctors_end__ = .);</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">        _etext = .;</span><br><span class="line">    &#125; &gt; ROM = 0</span><br><span class="line"></span><br><span class="line">    /* .ARM.exidx is sorted, so has to go in its own output section.  */</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    .ARM.exidx :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.ARM.exidx* .gnu.linkonce.armexidx.*)</span><br><span class="line"></span><br><span class="line">        /* This is used by the startup in order to initialize the .data secion */</span><br><span class="line">        _sidata = .;</span><br><span class="line">    &#125; &gt; ROM</span><br><span class="line">    __exidx_end = .;</span><br><span class="line"></span><br><span class="line">    /* .data section which is used for initialized data */</span><br><span class="line"></span><br><span class="line">    .data : AT (_sidata)</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .data secion */</span><br><span class="line">        _sdata = . ;</span><br><span class="line"></span><br><span class="line">        *(.data)</span><br><span class="line">        *(.data.*)</span><br><span class="line">        *(.gnu.linkonce.d*)</span><br><span class="line"></span><br><span class="line">        PROVIDE(__dtors_start__ = .);</span><br><span class="line">        KEEP(*(SORT(.dtors.*)))</span><br><span class="line">        KEEP(*(.dtors))</span><br><span class="line">        PROVIDE(__dtors_end__ = .);</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .data secion */</span><br><span class="line">        _edata = . ;</span><br><span class="line">    &#125; &gt;RAM</span><br><span class="line">     /* 初始化栈 */</span><br><span class="line">    .stack :                        </span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _sstack = .;</span><br><span class="line">        . = . + _system_stack_size;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _estack = .;</span><br><span class="line">    &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">        _sbss = .;</span><br><span class="line"></span><br><span class="line">        *(.bss)</span><br><span class="line">        *(.bss.*)</span><br><span class="line">        *(COMMON)</span><br><span class="line"></span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">        _ebss = . ;</span><br><span class="line"></span><br><span class="line">        *(.bss.init)</span><br><span class="line">    &#125; &gt; RAM</span><br><span class="line">    __bss_end = .;</span><br><span class="line"></span><br><span class="line">    _end = .;</span><br><span class="line"></span><br><span class="line">    /* Stabs debugging sections.  */</span><br><span class="line">    .stab          0 : &#123; *(.stab) &#125;</span><br><span class="line">    .stabstr       0 : &#123; *(.stabstr) &#125;</span><br><span class="line">    .stab.excl     0 : &#123; *(.stab.excl) &#125;</span><br><span class="line">    .stab.exclstr  0 : &#123; *(.stab.exclstr) &#125;</span><br><span class="line">    .stab.index    0 : &#123; *(.stab.index) &#125;</span><br><span class="line">    .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125;</span><br><span class="line">    .comment       0 : &#123; *(.comment) &#125;</span><br><span class="line">    /* DWARF debug sections.</span><br><span class="line">     * Symbols in the DWARF debugging sections are relative to the beginning</span><br><span class="line">     * of the section so we begin them at 0.  */</span><br><span class="line">    /* DWARF 1 */</span><br><span class="line">    .debug          0 : &#123; *(.debug) &#125;</span><br><span class="line">    .line           0 : &#123; *(.line) &#125;</span><br><span class="line">    /* GNU DWARF 1 extensions */</span><br><span class="line">    .debug_srcinfo  0 : &#123; *(.debug_srcinfo) &#125;</span><br><span class="line">    .debug_sfnames  0 : &#123; *(.debug_sfnames) &#125;</span><br><span class="line">    /* DWARF 1.1 and DWARF 2 */</span><br><span class="line">    .debug_aranges  0 : &#123; *(.debug_aranges) &#125;</span><br><span class="line">    .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125;</span><br><span class="line">    /* DWARF 2 */</span><br><span class="line">    .debug_info     0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125;</span><br><span class="line">    .debug_abbrev   0 : &#123; *(.debug_abbrev) &#125;</span><br><span class="line">    .debug_line     0 : &#123; *(.debug_line) &#125;</span><br><span class="line">    .debug_frame    0 : &#123; *(.debug_frame) &#125;</span><br><span class="line">    .debug_str      0 : &#123; *(.debug_str) &#125;</span><br><span class="line">    .debug_loc      0 : &#123; *(.debug_loc) &#125;</span><br><span class="line">    .debug_macinfo  0 : &#123; *(.debug_macinfo) &#125;</span><br><span class="line">    /* SGI/MIPS DWARF 2 extensions */</span><br><span class="line">    .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125;</span><br><span class="line">    .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125;</span><br><span class="line">    .debug_typenames 0 : &#123; *(.debug_typenames) &#125;</span><br><span class="line">    .debug_varnames  0 : &#123; *(.debug_varnames) &#125;</span><br><span class="line">&#125;</span><br><span class="line">COPY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>链接文件的主要作用是设定栈空间和堆空间（这也省略了启动文件中对堆栈空间的开辟），指定入口函数为Reset_Handler，指定输出段的布局。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432060896.png" alt="1701432060896"></p>
<h1 id="4-STM32的启动文件分析（基于MDK）"><a href="#4-STM32的启动文件分析（基于MDK）" class="headerlink" title="4 STM32的启动文件分析（基于MDK）"></a>4 STM32的启动文件分析（基于MDK）</h1><p>参考链接：<a href="https://blog.csdn.net/weixin_42328389/article/details/121855164">(3条消息) ARM 内核寄存器 和 基本汇编语言讲解_矜辰所致的博客-CSDN博客_arm汇编语言</a></p>
<p><a href="https://www.bilibili.com/video/BV1US4y1o7ok/?spm_id_from=pageDriver&amp;vd_source=b2294685dcc4b104a99f116c1c175bce">第4期BSP驱动教程：STM32H7从启动到运行过程全解析，电源域，复位，时钟，软硬件启动流程到堆栈，map和htm文件分析_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.cnblogs.com/yucloud/p/stm32_startup.html">STM32启动代码分析及其汇编学习-ARM - 蓝天上的云℡ - 博客园 (cnblogs.com)</a></p>
<p>无论是是何种MCU，从简单的51，MSP430，到ARM9，ARM11，A7 都必须有启动文件，因为对于嵌入式开发，绝大部分情况都是使用C语言，而 <strong>C语言一般都是从main 函数开始</strong> ，但是对于MCU来说，他是<strong>如何找到并执行main函数</strong>的，就需要用到“ <strong>启动文件</strong> ”，就是各种 startup_xxxx.s 文件。</p>
<p>换句话说，启动文件是 <strong>使用机器认识的汇编语言</strong> ，经过一些必要的配置，最终能够调用 main 函数，使得用户程序能够在 MCU上正常运行起来的必备文件。</p>
<blockquote>
<p>STM32 总体启动顺序：</p>
<p><code>.s启动文件</code> -&gt; <code>中断处理函数外部定义</code> -&gt; <code>SystemInit()</code> -&gt; <code>SetSysClock</code> -&gt; <code>__main</code> -&gt; <code>main()</code></p>
</blockquote>
<p>以下我们需要参考一个 <code>startup_stm32h750xx.s</code>文件分析一下STM32的汇编启动文件。</p>
<h2 id="4-1-启动文件的主要作用"><a href="#4-1-启动文件的主要作用" class="headerlink" title="4.1 启动文件的主要作用"></a>4.1 启动文件的主要作用</h2><p>在每一款常用MCU的Pack包中，往往都会包含一个startup_xxx.s的汇编启动文件，以STM32为例，这个文件通常会被命名成startup_stm32xxxxx.s等格式。</p>
<p>在该汇编的头部通常会有一段注释，介绍了启动文件执行的主要工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;******************** (C) COPYRIGHT 2018 STMicroelectronics ********************</span><br><span class="line">;* File Name          : startup_stm32h750xx.s</span><br><span class="line">;* @author  MCD Application Team</span><br><span class="line">;* Description        : STM32H7xx devices vector table for MDK-ARM toolchain. </span><br><span class="line">;*                      This module performs:</span><br><span class="line">;*                      - Set the initial SP                        //初始化堆栈指针 SP=_initial_sp </span><br><span class="line">;*                      - Set the initial PC == Reset_Handler       //初始化 PC 指针=Reset_Handler</span><br><span class="line">;*                      - Set the vector table entries with the exceptions ISR address  //初始化中断向量表</span><br><span class="line">;*                      - Branches to __main in the C library (which eventually</span><br><span class="line">;*                        calls main()).                            // 调用C库函数_main初始化用户堆栈，最终调用main函数，转入C</span><br><span class="line">;*                      After Reset the Cortex-M processor is in Thread mode,</span><br><span class="line">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class="line">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class="line">;******************************************************************************</span><br><span class="line">;* @attention</span><br><span class="line">;*</span><br><span class="line">;* Copyright (c) 2018 STMicroelectronics.</span><br><span class="line">;* All rights reserved.</span><br><span class="line">;*</span><br><span class="line">;* This software component is licensed by ST under BSD 3-Clause license,</span><br><span class="line">;* the &quot;License&quot;; You may not use this file except in compliance with the</span><br><span class="line">;* License. You may obtain a copy of the License at:</span><br><span class="line">;*                        opensource.org/licenses/BSD-3-Clause</span><br><span class="line">;*</span><br><span class="line">;******************************************************************************</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-2-启动文件的常用MDK-ARM汇编伪指令"><a href="#4-2-启动文件的常用MDK-ARM汇编伪指令" class="headerlink" title="4.2 启动文件的常用MDK/ARM汇编伪指令"></a>4.2 启动文件的常用MDK/ARM汇编伪指令</h2><p>参考链接：<a href="https://blog.csdn.net/weixin_42328389/article/details/121855164">(3条消息) ARM 内核寄存器 和 基本汇编语言讲解_矜辰所致的博客-CSDN博客_arm汇编语言</a></p>
<p><a href="https://developer.arm.com/documentation/dui0473/m/directives-reference/space-or-fill">ARM Compiler armasm User Guide Version 5.06</a></p>
<p><a href="https://blog.csdn.net/zlmm741/article/details/105189487">(3条消息) 第七章 ARM 反汇编基础（五）（ARM 汇编指令集）_zlmm741的博客-CSDN博客</a></p>
<blockquote>
<p>ARM汇编伪指令是ARM公司的，GNU汇编伪指令是GNU平台的。他们有自己的汇编器，不同的汇编器的解释语法可以设成不同。</p>
</blockquote>
<p>汇编语言分成两块：标准指令集和非标准指令集。 伪指令属于非标准指令集。</p>
<p><strong>伪指令</strong>是类似于宏的东西，把复杂的有好几条指令进行跳转的完成的小功能级进行新的标签设定，这就是伪指令。</p>
<p>类似于学c语言的时候的预处理，在预处理的时候把它定义于一堆的宏转化为真正的c语言的代码。同样，伪指令是在定义好之后的汇编，汇编的时候会把它翻译成标准指令，也许一条简单的伪指令可以翻译成很多条标准的汇编指令集，所以这就是伪指令最重要的作用。</p>
<p>基本的指令可以做各类操作了，但操作起来太麻烦了。伪指令定义了一些类似于带参数的宏，能够更好的实现汇编程序逻辑。（比如我现在要设置一个值给寄存器R0，但下次我修改了寄存器R0之后又需要读出来刚才的值，那我们就要先临时保存值到SPSR,CPSR，然后不断切换。）</p>
<p>伪指令只是在汇编器之前作用，汇编以后翻译为标准的汇编令集。</p>
<p>《ARM Cortex-M3与Cortex-M4权威指南》第5.6节有具体的解释，当然我们也可以参考<a href="https://developer.arm.com/documentation/ka001328/latest">Documentation – Arm Developer</a>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EQU</strong></td>
<td>给数字常量取一个符号名，相当于C语言中的 define</td>
</tr>
<tr>
<td><strong>AREA</strong></td>
<td>汇编一个新的代码段或者数据段</td>
</tr>
<tr>
<td><strong>ALIGN</strong></td>
<td>编译器对指令或者数据的存放地址进行对齐，一般需要跟一个立即数，缺省表示 4字节对齐。要注意的是，这个不是 ARM的指令，是编译器的，这里放到一起为了方便。</td>
</tr>
<tr>
<td><strong>SPACE</strong></td>
<td>分配内存空间</td>
</tr>
<tr>
<td><strong>PRESERVE8</strong></td>
<td>当前文件堆栈需要按照8字节对齐</td>
</tr>
<tr>
<td><strong>THUMB</strong></td>
<td>表示后面指令兼容 THUMB指令。在 ARM以前的指令集中有 16位的THUMBM指令，现在 Cortex-M系列使用的都是 THUMB-2指令集，THUMB-2是 32位的，兼容 16位和 32位的指令，是 THUMB的超级版。</td>
</tr>
<tr>
<td><strong>EXPORT</strong></td>
<td>声明一个标号具有全局属性，可被外部的文件使用</td>
</tr>
<tr>
<td><strong>DCD</strong></td>
<td>以字节为单位分配内存，要求4字节对齐，并要求初始化这些内存</td>
</tr>
<tr>
<td><strong>PROC</strong></td>
<td>定义子程序，与ENDP成对使用，表示子程序结束</td>
</tr>
<tr>
<td><strong>WEAK</strong></td>
<td>弱定义，如果外部文件声明了一个标号，则优先使用外部文件定义的标号，如果外部文件没有定义也不会出错。要注意的是，这个不是 ARM的指令，是编译器的，这里放到一起为了方便。</td>
</tr>
<tr>
<td><strong>IMPORT</strong></td>
<td>声明标号来自外部文件，跟C语言中的 <code>extern</code>关键字类似</td>
</tr>
<tr>
<td><strong>LDR</strong></td>
<td>从存储器中加载字到一个存储器中</td>
</tr>
<tr>
<td><strong>BLX</strong></td>
<td>跳转到由寄存器给出的地址，并根据寄存器的 LSE 确定处理器的状态，还要把跳转前的下条指令地址保存到 LR</td>
</tr>
<tr>
<td><strong>BX</strong></td>
<td>跳转到由寄存器 /标号给出的地址，不用返回</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>跳转到一个标号</td>
</tr>
<tr>
<td><strong>IF,ELSE,ENDIF</strong></td>
<td>汇编条件分支语句，跟C语言的类似</td>
</tr>
<tr>
<td><strong>END</strong></td>
<td>到达文件的末尾，文件结束</td>
</tr>
</tbody>
</table>
</div>
<p>关于其他更多的 ARM汇编指令，我们可以通过 MDK的索引搜索工具中搜索找到。打开索引搜索工具的方法：MDK-&gt;Help-&gt;uVision Help。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432149111.png" alt="1701432149111"></p>
<p>打开之后，我们以EQU为例，演示一下怎么使用，如下图。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432154455.png" alt="1701432154455"></p>
<p>搜索到的标题有很多，我们只需要看Assembler User Guide 这部分即可。</p>
<h2 id="4-3-Stack——栈"><a href="#4-3-Stack——栈" class="headerlink" title="4.3 Stack——栈"></a>4.3 Stack——栈</h2><p>注：类似RTT的嵌入式RTOS中提供了独立的内存管理实现方式（<code>rt_malloc()</code>、<code>rt_free()</code>），由于RTT是采用动态内存堆的内存管理方式，因此 <strong>不需要在启动文件中申请堆</strong> 。RT-Thread中的heap使用 <code>rt_system_heap_init</code>，把所有末使用的内存作为heap供 <code>rt_malloc</code>使用。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432160532.png" alt="1701432160532"></p>
<hr>
<blockquote>
<p>此处8字节对齐的原因可以参考这个链接：<a href="https://www.armbbs.cn/forum.php?mod=viewthread&amp;tid=109400&amp;highlight=%CE%DE%B7%A8%BB%D8%B1%DC%B5%C4%D7%D6%BD%DA%B6%D4%C6%EB%CE%CA%CC%E2">【烧脑技术贴】无法回避的字节对齐问题，从八个方向深入探讨(变量对齐，栈对齐，DMA对齐，结构体成对齐，Cache, RTOS双堆栈等) - STM32H7 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)</a></p>
<p><a href="https://www.armbbs.cn/forum.php?mod=viewthread&amp;tid=4916&amp;page=1">关于MDK中8字节对齐问题 - 编程语言 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)</a></p>
</blockquote>
<p>源码含义：开辟栈的大小为0x0000 0400(1KB)，段名为 <strong>STACK</strong> ，<strong>NOINIT</strong>表示不初始化，<strong>READWRITE</strong>表示可读可写，<strong>ALIGN=3</strong>表示按8（2^3）字节对齐 。</p>
<p> <strong>AREA</strong> ：告诉汇编器汇编一个新的代码段或者数据段，<strong>STACK</strong>表示段名，这个可以任意命名。</p>
<p> <strong>SPACE</strong> ：用于分配一定大小的内存空间，单位为字节，这里指定大小等于Stack_Size。</p>
<p><strong>__initial_sp</strong>紧挨着 SPACE放置，表示栈的结束地址，栈是从高往低生长，所以结束地址就是栈顶地址。</p>
<blockquote>
<p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要在启动文件内修改栈的大小（Stack_Size）。</p>
<p>如果程序出现了莫名奇怪的错误，并进入了HardFault的时候，就要考虑下是不是栈不够大，溢出了。</p>
</blockquote>
<h2 id="4-4-Heap——堆"><a href="#4-4-Heap——堆" class="headerlink" title="4.4 Heap——堆"></a>4.4 Heap——堆</h2><p>源码含义：开辟堆的大小为0X00000200（512字节），名字为HEAP，NOINIT表示不初始化，READWRITE表示可读可写，ALIGN=3表示8（2^3）字节对齐。</p>
<p> <strong>PRESERVE8</strong> ：堆栈任何时候都得4字节对齐，在调用入口时需要8字节对齐，指定当前文件的堆栈按照8字节对齐。</p>
<p> <strong>THUMB</strong> ：表示后面指令兼容THUMB指令。THUBM是ARM以前的指令集，16bit，现在Cortex-M系列的都使用THUMB-2指令集，THUMB-2是32位的，兼容16位和32位的指令，是THUMB的超集。</p>
<p><strong>__heap_base</strong>表示堆的起始地址， <strong>__heap_limit</strong>表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。</p>
<blockquote>
<p>堆的作用是动态内存的分配，像 <code>malloc()</code>、<code>calloc()</code>和 <code>realloc()</code>函数申请的内存就在堆上面。堆中的内存一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收，这个在STM32里面用的比较少，且一般是使用独立的而非系统提供的堆分配、释放函数，因此也可以考虑 <strong>将堆的大小设置为0</strong> ，以节省内存空间。</p>
</blockquote>
<h2 id="4-5-中断向量表"><a href="#4-5-中断向量表" class="headerlink" title="4.5 中断向量表"></a>4.5 中断向量表</h2><p> <strong>向量表作用：</strong> 当内核响应了一个发生的异常后，对应的异常服务例程(ESR)就会执行。为了决定 ESR的入口地址， 内核使用了向量表查表机制。这里使用一张向量表。向量表其实是一个WORD（32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该 ESR 的入口地址。向量表在地址空间中的位置是可以设置的，通过 NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为 0。因此，在地址 0 （即 FLASH 地址 0） 处必须包含一张向量表，用于初始时的异常分配。要注意的是这里有个另类： 0 号类型并不是什么入口地址，而是给出了复位后 MSP 的初值。向量表从 FLASH 的 0 地址开始放置，以 4 个字节为一个单位，地址 0 存放的是栈顶地址， 0X04 存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，而我们也知道 C 语言中的函数名就是一个地址。</p>
<blockquote>
<p><strong>用人话说：</strong> 内核在异常时会访问这个表地址，并根据异常类型查表，按表跳转到异常处理函数执行。</p>
</blockquote>
<p>首先是，创建向量表空间。</p>
<p>源码含义：定义一个数据段，名字为RESET，READONLY表示可读。</p>
<p> <strong>EXPORT</strong> ：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是IAR编译器，则使用的是GLOBAL这个指令。此处，声明<strong>Vectors、</strong>Vectors_End和__Vectors_Size这三个标号具有全局属性，可供外部的文件调用.</p>
<p><strong>我们通过检索map文件也可以检查到向量表的大小。</strong></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432167951.png" alt="1701432167951"></p>
<p><strong>在RTT（GCC环境）下，我们也可以检索到类似内容。</strong></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432173915.png" alt="1701432173915"></p>
<p><strong>可以发现向量表的位置对应的就是我们Code Flash的起始位置。</strong></p>
<p>当异常事件产生且被处理器内核接收后，对应的异常处理（ESR）就会执行。为了确定异常处理的起始地址，处理器利用了一种 <strong>向量表查表的机制</strong> 。向量表起始为一个WORD（32位整数）的数组，每一个下标对应一种异常，该下标元素的值则是该ESR的入口地址。向量表是可以重定位的，重定位由NVIC（Nested Vectored Interrupt Controllers）中名为向量偏移寄存器（VTOR）的可编程寄存器控制。复位后，VTOR默认为0，向量表则位于地址0x0000 0000处。</p>
<p><img src="[https://emoe-blog.oss-cn-hangzhou.aliyuncs.com/article_img/STM32%20%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E3%80%81%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%92%8C%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90_figures/image-20220926163905978.png](https://emoe-blog.oss-cn-hangzhou.aliyuncs.com/article_img/STM32%20%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E3%80%81%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%92%8C%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90_figures/image-20220926163905978.png" alt="image-20220926163905978"></p>
<p>因此，在地址0x0000 0000（即Flash地址0）处必须要包含一张向量表，用于初始时的异常分配。</p>
<blockquote>
<p>需要注意的是，地址0x0000 0000中的并不是程序入口地址，而是复位后给出的MSP初值。</p>
</blockquote>
<hr>
<p>以下为汇编文件中保存的中断向量表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp                      ; Top of Stack                // 首地址为栈顶地址</span><br><span class="line">                DCD     Reset_Handler                     ; Reset Handler               // 次地址为中断服务函数的地址</span><br><span class="line">                DCD     NMI_Handler                       ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler                 ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler                 ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler                  ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler                ; Usage Fault Handler</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     SVC_Handler                       ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler                  ; Debug Monitor Handler</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                    ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                   ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                   ; Window WatchDog interrupt ( wwdg1_it)</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                DCD     CRS_IRQHandler                    ; Clock Recovery Global Interrupt                           </span><br><span class="line">                DCD     ECC_IRQHandler                    ; ECC diagnostic Global Interrupt                                      </span><br><span class="line">                DCD     SAI4_IRQHandler                   ; SAI4 global interrupt                                        </span><br><span class="line">                DCD     0                                 ; Reserved                         </span><br><span class="line">                DCD     0                                 ; Reserved                            </span><br><span class="line">                DCD     WAKEUP_PIN_IRQHandler             ; Interrupt for all 6 wake-up pins </span><br><span class="line"></span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line">                // 中断向量表大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>__Vectors</strong>为向量表起始地址，<strong>__Vectors_End</strong>为向量表结束地址，两个相减即可算出向量表大小， <strong><strong>Vectors <em>Size = \</em> _Vectors_End - </strong>Vectors</strong> 。</p>
<p> <strong>DCD</strong> ：分配一个或者多个以字（4字节）为单位的内存，以4字节对齐，并要求初始化这些内存。每行<strong>DCD</strong>都会生成一个4字节的二进制代码，中断向量表中存放的实际上只是中断服务程序的入口地址。也即使用<strong>DCD</strong>分配一堆内存，并以异常（中断事件）的入口地址初始化它们。当异常（中断事件）发生时，CPU的中断系统将会将相应的入口地址赋值给PC程序计数器，之后开始执行中断服务程序。</p>
<blockquote>
<p>向量表从FLASH的0地址开始放置，以4个字节为一个单位， <strong>地址0x0存放的是栈顶地址，0x4存放的是复位程序的地址</strong> ，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道C语言中的函数名就是一个地址。</p>
<p>上面的这段代码是 <strong>建立中断向量表</strong> ，<strong>中断向量表定位在代码段</strong>的最前面。 <strong>具体的物理地址由链接器的配置参数决定</strong> 。如果程序在 Flash 运行，则中断向量表的起始地址是 0x08000000（IROM1 的地址）。以MDK为例，就是如下配置选项：</p>
</blockquote>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432187198.png" alt="1701432187198"></p>
<h2 id="4-6-复位中断服务程序"><a href="#4-6-复位中断服务程序" class="headerlink" title="4.6 复位中断服务程序"></a>4.6 复位中断服务程序</h2><p>在取出MSP后，PC指针寄存器指向 <code>Reset_Handler</code>，并调用以下程序。</p>
<blockquote>
<p>在GCC编译器下，语法结构会发生变化，如果是RTOS的话，也不一定是通过 <code>__main()</code>来实现跳转（如RT-Thread下跳转到entry()），但整体上启动文件实现的功能大体上是这些。</p>
<p>此__main()函数由MDK封装，并调用堆栈初始化部分的函数。</p>
<p>需要注意的是stm32f103的 <code>SystemInit()</code>较为简单，但stm32h7系列的单片机的 <code>SystemInit()</code>很复杂，在讨论到stm32h7时再做讨论。</p>
</blockquote>
<p>源码含义：在 CODE区定义一个名为 .text的只读的代码段。</p>
<p> <strong>PROC、ENDP</strong> ：定义子程序，这一对伪指令把程序段分为若干个过程，使程序的结构加清晰。</p>
<p>复位子程序是复位后第一个被执行的程序，主要是调用 <code>SystemInit()</code>（标准库函数，在system_stm32f1xx.c中定义）配置系统时钟，这里(stm32f103)调用这个函数之后，单片机的系统时钟配被配置为72M，还有就是初始化FSMC/FMC总线上外挂的 SRAM(可选 )。然后在调用 C 库函数 <code>__main</code>，最终调用 <code>main</code> 函数去到 C 的世界。</p>
<p> <strong>EXPORT</strong> ：声明复位中断向量 Reset_Handler为全局属性，这样外部文件就可以调用此复位中断服务。</p>
<p> <strong>WEAK</strong> ：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。这里表示复位子程序可以由用户在其他文件重新实现（重定向），这里并不是唯一的。</p>
<p> <strong>IMPORT</strong> ：表示该标号来自外部文件，跟C语言中的EXTERN关键字类似。这里表示 <code>SystemInit</code>和 <code>__main</code>这两个函数均来自外部的文件。</p>
<p>LDR、 BLX、 BX 是内核的指令，可在《 CM3 权威指南 CnR2》第四章 -指令集里面查询到。</p>
<p> <strong>LDR</strong> ：表示从存储器中加载字到一个存储器中。</p>
<p> <strong>BLX</strong> ：表示跳转到由寄存器给出的地址，并根据寄存器的 LSE 确定处理器的状态，还要把跳转前的下条指令地址保存到 LR。</p>
<p> <strong>BX</strong> ：表示 跳转到由寄存器/标号给出的地址，不用返回。这里表示切换到 __main地址，最终调用 main函数，不返回，进入C的世界。</p>
<blockquote>
<p><code>__main()</code>是一个标准的C库函数，主要作用是初始化用户堆栈，并在函数的最后调用 <code>main</code>函数去到C的世界。</p>
<p>关于 <code>__main()</code>的反汇编可以参考这些链接：<a href="https://www.cnblogs.com/yucloud/p/stm32_SystemInit_to_main.html">STM32_从SystemInit、__main到main() 已修正 - 蓝天上的云℡ - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/hgsdfghdfsd/article/details/103812484">STM32启动过程详解_Dream_Chaser2015的博客-CSDN博客_rt_lib_init</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gccint/Initialization.html">Initialization (GNU Compiler Collection (GCC) Internals)</a></p>
</blockquote>
<p> <strong>根据这篇链接里的文章，我们可以看到 <code>__main()</code>是一个标准的C库函数，<code>__main()</code>主要实现的功能有复制代码和数据，初始化 <code>RW</code>段（复制已初始化的数据）、初始化 <code>ZI</code>段（解压缩未初始化的数据），转入 <code>__rt_entry()</code>，初始化堆栈（<strong>user_initial_stackheap()，这个函数2.8节中提供）、初始化映像文件（`</strong>rt_lib_init()<code>）、以及转入</code>main()`。（这些我们都可以对应着在GCC版本中找到）</strong> 这也就是为什么我们写的程序都有一个 <code>main</code>函数的原因。因为这是由C/C++标准实时库所规定的——并且不能更改，因为C/C++标准实时库并不对外界开放源代码。在进入了 <code>main</code>函数后，我们就进入了C的世界，可以开始运行我们编写的应用程序。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432262861.png" alt="1701432262861"></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432270090.png" alt="1701432270090"></p>
<h2 id="4-7-中断服务程序"><a href="#4-7-中断服务程序" class="headerlink" title="4.7 中断服务程序"></a>4.7 中断服务程序</h2><p>在启动文件中，已经帮我们写好了所有中断的中断服务函数，但跟用户写在应用程序中的中断服务函数不同，这些函数都是空的（都被 <code>WEAK</code>声明为弱定义函数，如果外部文件声明了一个标号，则优先使用外部文件定义的标号，如果外部文件没有定义也不会出错。），也即真正的中断复位服务程序 <strong>需要我们在外部的C文件里面重新实现，这里只是提前占了一个位置</strong> （都是声明为弱定义，所以真正的中断服务函数需要我们在外部实现），一般都留在stm32xxx_it.c中实现 <strong>重定向</strong> 。</p>
<p>如果我们在使用某个外设的时候，开启了某个中断，但是又 <strong>忘记编写配套的中断服务程序或者函数名写错</strong> ，那当中断来临的时，程序就会跳转到启动文件预先写好的空的中断服务程序中，并且在这个空函数中无线循环，即程序就死在这里。（原因是B指令的作用是跳转到一个标号，这里跳转到一个‘.’，表示无限循环。）</p>
<p>这里的系统异常中断部分是内核的，外部中断部分是外设的。</p>
<p><code>B .</code>所代表的意思为跳转到当前位置，也即当系统报了NMI_Handler、HardFault_Handler等异常时，若该中断函数未定义，则系统会卡死在相应中断函数内。</p>
<h2 id="4-8-用户堆栈初始化"><a href="#4-8-用户堆栈初始化" class="headerlink" title="4.8 用户堆栈初始化"></a>4.8 用户堆栈初始化</h2><blockquote>
<p>参考文档：《Libraries and Floating Point Support Guide》</p>
<p><a href="https://blog.csdn.net/OnlyLove_/article/details/119837369">rt-thread源码分析篇四：堆栈分配机制_lqonlylove的博客-CSDN博客</a></p>
</blockquote>
<p>《Libraries and Floating Point Support Guide》文档中对堆栈描述如下：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432372345.png" alt="1701432372345"></p>
<p><strong>堆栈模型有2种：</strong><br><strong>1、单内存区域模型（堆栈共用一片空间）；</strong><br><strong>2、双内存区域模型（堆和栈都有独立空间）。</strong></p>
<p>源码含义：</p>
<ul>
<li>首先判断是否定义了 <code>__MICROLIB</code>（ <strong>MDK特有的内容，自带的微库，是缺省，重新定义了标准C库中的常用函数，减小调用了标准C库中 <code>printf</code>、<code>scanf</code>等函数的文件生成的代码大小，但执行速度会比标准C库慢，功能也比缺省C库少，MicroLIB没有源码，只有库</strong> ），如果定义了这个宏则赋予标号 <code>__initial_sp</code>（栈顶地址）、<code>__heap_base</code>（堆起始地址）、<code>__heap_limit</code>（堆结束地址）全局属性，可供外部文件调用。有关这个宏我们在KEIL里面配置，具体见图使用微库。</li>
</ul>
<blockquote>
<p>关于MicroLIB更多知识可以看官方介绍 <a href="http://www.keil.com/arm/microlib.asp">http://www.keil.com/arm/microlib.asp</a> 。另外注意microlib只有库，没有源文件。下图是标准库和微库生成代码的比较。</p>
</blockquote>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432391986.png" alt="1701432391986"></p>
<ul>
<li>如果没有定义 <code>__MICROLIB</code>，则才用双区域堆栈模型，且声明标号 <code>__user_initial_stackheap</code>具有全局属性，堆栈的初始化由 C库函数 <code>__main</code>来完成。</li>
<li><p>接下来进行堆栈空间初始化，堆是从低到高生长，栈是从高到低生长，是两个互相独立的数据段，并且不能交叉使用：</p>
<ol>
<li><code>LDR R0, = Heap_Mem</code>：保存堆起始地址；</li>
<li><code>LDR R1, =(Stack_Mem + Stack_Size)</code>：保存栈大小；</li>
<li><code>LDR R2, = (Heap_Mem + Heap_Size)</code>：保存堆大小；</li>
<li><code>LDR R3, = Stack_Mem</code>：保存栈顶指针；</li>
<li><code>BX LR</code>：跳转到 LR标号给出的地址（<code>main</code>函数），不用返回；</li>
<li><code>END</code>表示 到达文件的末尾，文件结束。</li>
</ol>
<p><strong>IF,ELSE,ENDIF</strong> ：汇编的条件分支语句，跟C语言的if,else类似。</p>
<p><strong>IMPORT</strong> ：声明 <code>__use_two_region_memory</code>标号来自外部文件。<br><strong>EXPORT</strong> ：声明 <code>__user_initial_stackheap</code>具有全局属性，可被外部的文件使用。</p>
<p><strong>ALIGN</strong> ：表示对指令或者数据的存放地址进行对齐，一般需要跟一个立即数，缺省表示 4字节对齐。要注意的是，这个不是 ARM的指令，是编译器的。</p>
<p><strong>END</strong> ：文件结束 。</p>
</li>
</ul>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432403086.png" alt="1701432403086"></p>
<p>最后，堆栈的初始化就由C库函数__rt_entry()来完成，这也解释了， <strong>为什么在启动文件中，堆栈命名在前面，但实际上先执行的却是MSP和复位向量指针</strong> 。</p>
<p>当然，我们也可以结合实际情况，不选中 <code>microlib</code>，编译后分析 <code>map</code>文件。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432451975.png" alt="1701432451975"></p>
<p>或者，选中 <code>microlib</code>，编译后分析 <code>map</code>文件。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432458642.png" alt="1701432458642"></p>
<h1 id="5-STM32链接脚本分析（基于MDK）"><a href="#5-STM32链接脚本分析（基于MDK）" class="headerlink" title="5 STM32链接脚本分析（基于MDK）"></a>5 STM32链接脚本分析（基于MDK）</h1><p>参考链接：DUI0377G_02_mdk_armlink_user_guide.pdf（可以在keil的帮助文档中找到，主要参考这个）</p>
<p><a href="https://blog.csdn.net/qq_23274715/article/details/103445958">sct文件编写与使用_theboynoName的博客-CSDN博客_keil sct文件解析</a></p>
<p><a href="https://developer.arm.com/documentation/100070/0611/scatter-file-syntax/load-region-descriptions">Arm 编译器 armlink 用户指南 6.11 版</a></p>
<p>MDK环境下的STM32的链接脚本文件，又被称为分散加载文件，是由Keil自定义的链接文件，就我们常见的分散加载文件 <code>.sct</code>，通常十分简洁。</p>
<p>在MDK中，我们可以使用魔术棒中的工具，来实现分散加载文件的快速配置。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432481051.png" alt="1701432481051"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; *************************************************************</span><br><span class="line">; *** Scatter-Loading Description File generated by uVision ***</span><br><span class="line">; *************************************************************</span><br><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00020000  &#123;    ; load region size_region，定义一个加载域，域基地址为0x08000000，域大小为0x00020000，对应实际 Flash 的大小</span><br><span class="line">  ER_IROM1 0x08000000 0x00020000  &#123;  ; load address = execution address 定义一个运行域，第一个运行域的基地址必须和加载域的基地址相同</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x24000000 0x00080000  &#123;  ; AXI SRAM 512K</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个分散加载文件由一个或者多个加载域描述(<code>load regions description</code>)组成。每个加载域描述由一个或者多个执行域描述(<code>execution regions description</code>)组成。执行域中又包含很多个输入节描述(<code>Input section description</code>)，关系图如下：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432488419.png" alt="1701432488419"></p>
<p>上图中的 <code>.sct</code>文件包含两个加载域描述。每个加载域描述中又都包含两个执行域描述。每个执行域描述中包含一个输入节描述。</p>
<blockquote>
<p>为什么要加上描述两个字呢？</p>
<p>因为这些并非真正的输入节和执行域，可重定位的目标文件中的输入节经过分散加载文件的描述映射到可执行或可共享的目标文件中的输出段/加载域。</p>
</blockquote>
<p>分散加载的好处在于我们可以将变量和代码精确地存放在某个位置，特别是像STM32H7这种MCU，拥有多个RAM块，外置SDRAM空间，以及内部Flash和外置内存映射的QSPI Flash。 我们可以把时间关键代码放到 <code>ITCM</code>里面运行，而占用空间超大，又不需要快速执行的代码放到 <code>QSPI Flash</code>运行，都可以方便的配置。</p>
<blockquote>
<p>后续3.1~3.3节翻译自DUI0377G_02_mdk_armlink_user_guide.pdf。</p>
</blockquote>
<p>此外，以下很大的一部分是自己阅读文件并翻译的内容，实际意义不大，也不需要费心真的把这些看完，仅做了解的话，看硬汉giegie的视频就行：<a href="https://www.bilibili.com/video/BV1MR4y157XS/">第7期BSP驱动教程：MDK专题高级进阶，重要的分散加载使用，通过各种实战案例来学习_哔哩哔哩_bilibili</a></p>
<h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>以下，我们先对MDK的分散加载文件的基本概念做一定的介绍。</p>
<h3 id="5-1-1-ARM-ELF映像（image）的结构"><a href="#5-1-1-ARM-ELF映像（image）的结构" class="headerlink" title="5.1.1 ARM ELF映像（image）的结构"></a>5.1.1 ARM ELF映像（<code>image</code>）的结构</h3><p>一个ARM ELF映像包括节、域和段，每个链接阶段具有不同的映像视图。</p>
<p>一个映像文件的结构被定义为：</p>
<ol>
<li>组成映像的域和输出节的数量；</li>
<li>加载映像时，这些域和节在内存中的位置；</li>
<li>执行映像时，这些域和节在内存中的位置。</li>
</ol>
<h3 id="5-1-2-每个链接阶段的映像视图"><a href="#5-1-2-每个链接阶段的映像视图" class="headerlink" title="5.1.2 每个链接阶段的映像视图"></a>5.1.2 每个链接阶段的映像视图</h3><p>每个链接阶段具有不同的映像视图。</p>
<h4 id="5-1-2-1-ELF目标文件视图（链接输入）"><a href="#5-1-2-1-ELF目标文件视图（链接输入）" class="headerlink" title="5.1.2.1 ELF目标文件视图（链接输入）"></a>5.1.2.1 ELF目标文件视图（链接输入）</h4><p>ELF目标文件视图包括输入节。ELF目标文件可以是：</p>
<ol>
<li>一个包含适用于与其他目标文件链接以创建可执行或可共享目标文件的代码和数据的可重定位文件；</li>
<li>一个保存代码和数据的可共享的目标文件。</li>
</ol>
<h4 id="5-1-2-2-链接视图"><a href="#5-1-2-2-链接视图" class="headerlink" title="5.1.2.2 链接视图"></a>5.1.2.2 链接视图</h4><p>链接器有两个程序程序地址空间视图，当存在重叠的、位置无关的和可重定位的程序片段（代码或数据）时，这两个程序地址空间视图会变得不同：</p>
<ol>
<li>一个程序片段的加载地址是链接器期望外部代理（如程序加载器、动态链接器或调试器）从ELF文件复制片段的目标地址，这可能不是片段的地址；</li>
<li>一个程序片段的执行地址是链接器在参与程序执行时期望片段驻留的目标地址。</li>
</ol>
<p>如果一个片段是位置无关或可重定位的，它的执行地址可以在执行期间变化。</p>
<h4 id="5-1-2-3-ELF映像文件视图（链接输出）"><a href="#5-1-2-3-ELF映像文件视图（链接输出）" class="headerlink" title="5.1.2.3 ELF映像文件视图（链接输出）"></a>5.1.2.3 ELF映像文件视图（链接输出）</h4><p>ELF映像文件视图包括程序段和输出节：</p>
<ol>
<li>一个加载域对应于一个程序段；</li>
<li>一个执行域包括一个或多个下列的输出节：<ul>
<li>RO节（只读）；</li>
<li>RW节（可读写）；</li>
<li>XO节（可执行）；</li>
<li>ZI节（初始化为0）。</li>
</ul>
</li>
</ol>
<p>一个或多个执行域组成一个加载域。</p>
<p>当描述一个内存视图时：</p>
<ol>
<li>根域意味着拥有相同的加载和执行地址的域；</li>
<li>加载域等同于ELF的段。</li>
</ol>
<p>下列图片显示了每个链接阶段的视图之间的关系：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432568048.png" alt="1701432568048"></p>
<h3 id="5-1-3-输入节、输出节、域和程序段"><a href="#5-1-3-输入节、输出节、域和程序段" class="headerlink" title="5.1.3 输入节、输出节、域和程序段"></a>5.1.3 输入节、输出节、域和程序段</h3><p>一个目标或映像文件由输入节、输出节、域和程序段的层次结构构成。</p>
<h4 id="5-1-3-1-输入节"><a href="#5-1-3-1-输入节" class="headerlink" title="5.1.3.1 输入节"></a>5.1.3.1 输入节</h4><p>一个输入节是来自于一个输入目标文件的一个独立节。输入节包含代码、初始化数据或描述在执行映像前未初始化或必须设置为0的内存片段。这些属性由RO、RW、XO和ZI等属性表示。armlink（armlink的链接器）使用这些属性将输入节分组为更大的构建块，称为输出节和域。</p>
<h4 id="5-1-3-2-输出节"><a href="#5-1-3-2-输出节" class="headerlink" title="5.1.3.2 输出节"></a>5.1.3.2 输出节</h4><p>一个输出节是一组具有相同RO、RW、XO或ZI属性的输入节，并且由链接器连续放置在内存中。输出节具有与组成它的输入节相同的属性。在输出节中，根据节放置规则对输入节进行排序。</p>
<h4 id="5-1-3-3-域"><a href="#5-1-3-3-域" class="headerlink" title="5.1.3.3 域"></a>5.1.3.3 域</h4><p>一个域最多包含四个输出节，具体取决于内容和具有不同属性的节的数量。默认情况下，域的输出节根据属性进行排序。首先是XO属性的输出节，然后是RO属性的输出节，最后是RW属性的输出节和ZI属性的输出节。域通常会映射到物理存储设备上，例如ROM、RAM或外围设备上，可以使用分散加载更改输出节的顺序。</p>
<h4 id="5-1-3-4-程序段"><a href="#5-1-3-4-程序段" class="headerlink" title="5.1.3.4 程序段"></a>5.1.3.4 程序段</h4><p>一个程序段对应于一个加载域，并且包含执行域。 程序段包含文本和数据等信息。</p>
<h4 id="5-1-3-5-存在只执行节（execute-only-sections）的注意事项"><a href="#5-1-3-5-存在只执行节（execute-only-sections）的注意事项" class="headerlink" title="5.1.3.5 存在只执行节（execute-only sections）的注意事项"></a>5.1.3.5 存在只执行节（execute-only sections）的注意事项</h4><ol>
<li>可以在一个执行域中混合XO和非XO节，但输出结果是一个RO节；</li>
<li>如果输入文件具有一个或多个XO节，则链接器将生成单独的XO ELF段，在最后的映像中，除非使用分散加载文件或 <code>--xo-base</code>选项另有指定，否则XO段紧接在RO段之后。</li>
</ol>
<h3 id="5-1-4-映像的加载视图和执行视图"><a href="#5-1-4-映像的加载视图和执行视图" class="headerlink" title="5.1.4 映像的加载视图和执行视图"></a>5.1.4 映像的加载视图和执行视图</h3><p>映像域在加载时被放置到系统内存映射中。在执行中，内存中域的位置可能会改变。</p>
<p>在执行映像前，可能必须将映像的某些域移动到它们的执行地址，并创建ZI输出节。比如，初始化的RW数据可能需要从ROM的加载地址复制到RAM的执行地址。</p>
<p>映像的内存映射有以下几种不同的视图。</p>
<h4 id="5-1-4-1-加载视图"><a href="#5-1-4-1-加载视图" class="headerlink" title="5.1.4.1 加载视图"></a>5.1.4.1 加载视图</h4><p>根据映像加载到内存中时所处的地址，即映像执行开始前的位置，描述每个映像的域和节。</p>
<h4 id="5-1-4-2-执行视图"><a href="#5-1-4-2-执行视图" class="headerlink" title="5.1.4.2 执行视图"></a>5.1.4.2 执行视图</h4><p>根据映像执行期间所处的地址，描述每个映像的域和节。</p>
<hr>
<p>下面的图像展示了一个不含只执行节（execute-only sections）的映像的加载和执行视图。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432580601.png" alt="1701432580601"></p>
<p>下面的图像展示了一个含一个只执行节（execute-only sections）的映像的加载和执行视图：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432590737.png" alt="1701432590737"></p>
<p>下表比较了加载和执行视图：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>加载</th>
<th>描述</th>
<th>执行</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载地址</td>
<td>在包含节或域的映像开始执行前，将其加载到内存中的地址。``节或非根域的加载地址可以与其执行地址不同。</td>
<td>执行地址</td>
<td>节或域所在的地址，其中包含了该节或域的映像正在执行。</td>
</tr>
<tr>
<td>加载域</td>
<td>一个加载域描述了加载地址空间中连续的内存块的布局。</td>
<td>执行域</td>
<td>一个执行域描述了在执行地址空间中连续的内存块的布局。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-1-5-映像入口点"><a href="#5-1-5-映像入口点" class="headerlink" title="5.1.5 映像入口点"></a>5.1.5 映像入口点</h3><p>映像中的入口点是被加载到PC指针寄存器中的位置，是程序执行开始的位置。尽管一个映像中可以有多个入口点，但在链接过程中，只可以指定一个。</p>
<p>并不是每一个ELF文件都必须有一个入口点，一个ELF文件中不允许存在多个入口点。</p>
<blockquote>
<p>对于嵌入式 Cortex-M 内核的程序，程序的执行是从复位向量所在的位置（地址）开始执行。复位向量会被加载到 PC 寄存器中，且复位向量的位置（地址）并不固定。 通常，复位向量指向 CMSIS 的 Reset_Handler 函数。</p>
</blockquote>
<h4 id="5-1-5-1-入口点类型"><a href="#5-1-5-1-入口点类型" class="headerlink" title="5.1.5.1 入口点类型"></a>5.1.5.1 入口点类型</h4><p>有两种不同类型的入口点。</p>
<p><strong>初始化入口点：</strong></p>
<p>镜像的初始入口点是存储在 ELF 头文件中的单个值。 对于那些需要由操作系统或引导加载程序加载到 RAM 中的程序，加载程序通过将控制转移到镜像中的初始入口点来启动镜像执行。</p>
<p>一个镜像只能有一个初始化入口点。初始入口点可以是，但并不必须是，ENTRY 指令设置的入口点之一。</p>
<p><strong>ENTRY 指令指定的入口点：</strong></p>
<p>可以为一个镜像从多个可能的入口点中选择一个入口点。每个镜像只能有一个入口点。</p>
<p>可以在汇编程序文件中使用 ENTRY 指令在目标中创建入口点。 在嵌入式系统中，该指令的典型用途是标记进入处理器异常向量（例如 RESET，IRQ 和 FIQ）的代码。</p>
<p>该指令使用 ENTRY 关键字标记输出代码部分，该关键字指示链接器在执行未使用的部分消除时不删除该部分。</p>
<p>对于 C/C++ 程序，C 库 中的 __main() 函数就是入口点。</p>
<p>如果加载程序要使用一个嵌入式映像，则必须在标头中指定一个初始入口点。 使用 <code>--entry</code>命令行选项选择入口点。</p>
<h4 id="5-1-5-2-映像的初始入口点"><a href="#5-1-5-2-映像的初始入口点" class="headerlink" title="5.1.5.2 映像的初始入口点"></a>5.1.5.2 映像的初始入口点</h4><p>一个映像只能有一个初始入口点，否则会报 <code>L6305W</code>警告。</p>
<p>初始入口点必须满足以下条件：</p>
<ol>
<li>映像的入口点必须位于执行域中；</li>
<li>执行域必须不能覆盖另一个执行域，且必须是根执行域，即加载地址与执行地址相同。</li>
</ol>
<p>如果没有使用 <code>--entry</code>命令行选项来指定初始入口点，那么：</p>
<ol>
<li>如果输入目标值包含一个由 <code>ENTRY</code>指令定义的入口点，链接器使用该入口点作为映像的初始入口点；</li>
<li>在以下情况下，链接器生成一个不包含一个入口点的映像：<ul>
<li>使用 <code>ENTRY</code>指令来指定超过一个入口点；</li>
<li>没有使用 <code>ENTRY</code>指令指定入口点。</li>
</ul>
</li>
</ol>
<p>对于ROM为0的嵌入式应用使用 <code>--entry 0x0</code>命令，或对使用高矢量的处理器选择 <code>0xFFFF0000</code>。</p>
<h2 id="5-2-基本语法"><a href="#5-2-基本语法" class="headerlink" title="5.2 基本语法"></a>5.2 基本语法</h2><h3 id="5-2-1-BNF符号"><a href="#5-2-1-BNF符号" class="headerlink" title="5.2.1 BNF符号"></a>5.2.1 BNF符号</h3><p>分散加载描述语法使用了标准的BNF符号。</p>
<p>下表总结了用于描述分散加载描述的语法的巴科斯范式（Backus-Naur Form，BNF）符号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>SYMBOL</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;</code></td>
<td>Quotation marks indicate that a character that is normally part of the BNF syntax is used as a literal character in the definition. The definition <code>B&quot;+&quot;C</code>, for example, can only be replaced by the pattern <code>B+C</code>. The definition <code>B+C</code> can be replaced by, for example, patterns <code>BC</code>, <code>BBC</code>, or <code>BBBC</code>.</td>
</tr>
<tr>
<td>A ::= B</td>
<td>Defines A as B. For example,`A::= B”+” \</td>
<td>C<code>means that A is equivalent to either</code>B+<code>or</code>C<code>. The</code>::=<code>notation defines a higher level construct in terms of its components. Each component might also have a</code>::=<code>definition that defines it in terms of even simpler components. For example,</code>A::= B<code>and</code>B::= C \</td>
<td>D<code>means that the definition A is equivalent to the patterns</code>C<code>or</code>D`.</td>
</tr>
<tr>
<td>[A]</td>
<td>Optional element A. For example,<code>A::= B[C]D</code> means that the definition <code>A</code> can be expanded into either <code>BD</code> or <code>BCD</code>.</td>
</tr>
<tr>
<td>A+</td>
<td>Element A can have one or more occurrences. For example,<code>A::= B+</code> means that the definition <code>A</code> can be expanded into <code>B,</code> <code>BB</code>, or <code>BBB</code>.</td>
</tr>
<tr>
<td>A*</td>
<td>Element A can have zero or more occurrences.</td>
</tr>
<tr>
<td>A</td>
<td>B</td>
</tr>
<tr>
<td>(A B)</td>
<td>Element A and B are grouped together. This is particularly useful when the</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-2-2-分散加载文件的语法"><a href="#5-2-2-分散加载文件的语法" class="headerlink" title="5.2.2 分散加载文件的语法"></a>5.2.2 分散加载文件的语法</h3><p>一个分散加载文件包括一个或多个加载域。每个加载域可以包含一个或多个执行域。</p>
<p>下列的图像显示了一个典型的分散加载文件的组成部分和组织结构：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432611257.png" alt="1701432611257"></p>
<h3 id="5-2-3-加载域描述"><a href="#5-2-3-加载域描述" class="headerlink" title="5.2.3 加载域描述"></a>5.2.3 加载域描述</h3><p><strong>加载域描述指定了其子执行域在内存区域内的放置方式。</strong></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432619288.png" alt="1701432619288"></p>
<h4 id="5-2-3-1-加载域描述的语法"><a href="#5-2-3-1-加载域描述的语法" class="headerlink" title="5.2.3.1 加载域描述的语法"></a>5.2.3.1 加载域描述的语法</h4><p>加载域描述的组成部分允许独一无二地定义一个加载域和控制一个ELF文件的哪个部分放置在那个域中。</p>
<p>BNF下，加载域描述的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_region_description ::=</span><br><span class="line">    load_region_name (base_address | (&quot;+&quot; offset)) [attribute_list] [max_size]</span><br><span class="line">        &quot;&#123;&quot;</span><br><span class="line">        execution_region_description+</span><br><span class="line">        &quot;&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个加载域描述有以下的组成部分：</p>
<ol>
<li>名称（<code>load_region_name</code>）：命名加载域。可以使用带引号的名称，仅当使用任何域相关的链接器定义的符号时，名称才区分大小写；</li>
<li>基地址（<code>base_address</code>）：指定链接区域的对象的地址，<code>base_address</code>必须满足对齐要求；</li>
<li>偏移（<code>&quot;+&quot; offset</code>）：描述超过前一个加载域末尾 <code>offset</code>字节的一个基地址。<code>offset</code>的值必须按4字节对齐，如果是第一个加载域，<code>&quot;+&quot; offset</code>表示基址从0的 <code>offset</code>字节偏移处开始；<br>如果使用 <code>&quot;+&quot; offset</code>，则加载域可能会从先前的加载域继承某些属性。</li>
<li>属性列表（<code>attribute_list</code>）：指定加载域内内容的属性；</li>
<li>加载域大小（<code>max_size</code>，可选）：指定加载域的大小，这是在进行任何解压或零初始化之前的加载域大小，如果指定了可选的 <code>max_size</code>值，那么如果域分配了超过 <code>max_size</code>字节，<code>armlink</code>将生成错误；</li>
<li>执行域描述（<code>execution_region_description</code>）：指定执行域的名称，地址和内容，一个加载域包含一个或多个执行域描述。</li>
</ol>
<blockquote>
<p>BNF定义包含额外的行返回和空格，以提高可读性。分散加载描述中不需要它们，如果存在于分散文件中，则忽略它们。</p>
</blockquote>
<h3 id="5-2-4-执行域描述"><a href="#5-2-4-执行域描述" class="headerlink" title="5.2.4 执行域描述"></a>5.2.4 执行域描述</h3><p><strong>一个执行域描述指定了运行时放置映像部分的内存区域。</strong></p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432639809.png" alt="1701432639809"></p>
<h4 id="5-2-4-1-执行域描述的语法"><a href="#5-2-4-1-执行域描述的语法" class="headerlink" title="5.2.4.1 执行域描述的语法"></a>5.2.4.1 执行域描述的语法</h4><p>执行域描述的组成部分允许独一无二地标识每一个执行域及其在父加载域中的位置，并控制ELF文件的哪些部分放置在该执行域中。</p>
<p>BNF下，执行域描述的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution_region_description ::=</span><br><span class="line">    exec_region_name (base_address | &quot;+&quot; offset) [attribute_list] [max_size | length]</span><br><span class="line">        &quot;&#123;&quot;</span><br><span class="line">        input_section_description*</span><br><span class="line">        &quot;&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>名称（<code>exec_region_name</code>）：命名执行域。可以使用带引号的名称，仅当使用任何域相关的链接器定义的符号时，名称才区分大小写；</li>
<li>基地址（<code>base_address</code>）：指定链接区域的对象的地址，<code>base_address</code>必须满足对齐要求；</li>
</ol>
<blockquote>
<p>在执行域上使用 <code>ALIGN</code>，使加载域和执行域一同对齐。</p>
</blockquote>
<ol>
<li>偏移（<code>&quot;+&quot; offset</code>）：描述超过前一个执行域末尾 <code>offset</code>字节的一个基地址。<code>offset</code>的值必须按4字节对齐，如果是第一个执行域，<code>&quot;+&quot; offset</code>表示基址从包含于的加载域的 <code>offset</code>字节偏移处开始；<br>如果使用 <code>&quot;+&quot; offset</code>，则执行域会从父加载域继承某些属性，或从统一加载域的前一个执行域继承某些属性。</li>
<li>属性列表（<code>attribute_list</code>）：指定执行域内内容的属性；</li>
<li>执行域大小（<code>max_size</code>，可选）：指定执行域的大小，对于标记为 <code>EMPTY</code>或 <code>FILL</code>的执行域，<code>max_size</code>值被解释为域的长度。否则，<code>max_size</code>值将被解释为执行域的最大大小；</li>
<li>长度（<code>length</code>）：只能与 <code>EMPTY</code>一起使用，以表示在内存中增长的堆栈。如果长度为负值，则将 <code>base_address</code>作为域的结束地址；</li>
<li>输入节描述（<code>input_section_description</code>）：指定输入节的内容。</li>
</ol>
<blockquote>
<p>BNF定义包含额外的行返回和空格，以提高可读性。分散加载描述中不需要它们，如果存在于分散文件中，则忽略它们。</p>
</blockquote>
<h3 id="5-2-5-输入节描述"><a href="#5-2-5-输入节描述" class="headerlink" title="5.2.5 输入节描述"></a>5.2.5 输入节描述</h3><p>输入节描述是标识输入节的模式。</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432699712.png" alt="1701432699712"></p>
<h4 id="5-2-5-1-输入节描述的语法"><a href="#5-2-5-1-输入节描述的语法" class="headerlink" title="5.2.5.1 输入节描述的语法"></a>5.2.5.1 输入节描述的语法</h4><p>输入节描述指定将哪些输入节加载到父执行域中。</p>
<p>BNF下，输入节描述的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input_section_description ::=</span><br><span class="line">    module_select_pattern</span><br><span class="line">        [ &quot;(&quot; input_section_selector ( &quot;,&quot; input_section_selector )* &quot;)&quot; ]</span><br><span class="line">input_section_selector ::=</span><br><span class="line">        (&quot;+&quot; input_section_attr | input_section_pattern | input_symbol_pattern | section_properties)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p>模块匹配模式（<code>module_select_pattern</code>）：模式由字面文本构建。当程序块匹配模式与以下之一匹配时，输入节与程序块匹配模式匹配：</p>
<ul>
<li>包含该节的目标文件的名称；</li>
<li>库成员的名称（不带前导路径名）；</li>
<li>从中提取节的库的全名（包括路径名），如果名称包含空格，需要使用通配符，例如，使用 <code>*libname.lib</code>匹配 <code>C:\lib dir\libname.lib</code>。</li>
</ul>
<p>通配符 <code>*</code>匹配0个或多个字符，<code>?</code>匹配任意单个字符。<br>匹配不区分大小写，即使在区分大小写文件命名的主机上也是如此。<br><code>*.o</code> 匹配任何目标文件，使用 <code>*</code> 匹配任何目标文件或库。<br>可以使用被引用的文件名，如 <code>&quot;file one.o&quot;</code>。<br>分散文件中不能有两个 <code>*</code> 模块选择器。但可以使用两个修改后的模块选择器，如 <code>*A</code>和 <code>*B</code>，并且，可以同时使用一个有 <code>*</code> 选择器的 <code>.ANY</code>选择器。<br><code>*</code> 模块选择器拥有比 <code>.ANY</code> 模块选择器更高的优先级。<br>如果文件中包含 <code>*</code> 模块选择器的部分被删除，<code>.ANY</code>模块选择器将激活。</p>
</li>
<li><p>输入节属性（<code>input_section_attr</code>）：与输入节属性匹配的属性选择器（attribute selector）。每个 <code>input_section_attr</code>后跟一个 <code>+</code>。 如果要指定与输入节名称匹配的模式，则名称前面必须有 <code>+</code>。选择器不区分大小写。可识别以下选择器：</p>
<ul>
<li>RO-CODE</li>
<li>RO-DATA</li>
<li>RO，用来同时选择RO-CODE和RO-DATA</li>
<li>RW-DATA</li>
<li>RW-CODE</li>
<li>RW，用来同时选择 RW-CODE 和 RW-DATA</li>
<li>XO</li>
<li>ZI</li>
<li>ENTRY，包含 <code>ENTRY</code>点的节</li>
</ul>
<p>可以识别以下同义词：</p>
<ul>
<li>CODE for RO-CODE</li>
<li>CONST for RO-DATA</li>
<li>TEXT for RO</li>
<li>DATA for RW</li>
<li>BSS for ZI</li>
</ul>
<p>可以识别以下伪属性：</p>
<ul>
<li>FIRST</li>
<li>LAST</li>
</ul>
<p>如果放置顺序很重要，请用 <code>FIRST</code>和 <code>LAST</code>标记执行区域中的第一节和最后一节。例如，如果特定的输入节必须是域中的首位，而包含校验和的输入部分则必须是末位。一个执行区域只能有一个 <code>FIRST</code>或一个 <code>LAST</code>属性，并且它必须跟在一个 <code>input_section_attr</code>后面。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(section, +FIRST)           # This pattern is correct.</span><br><span class="line">*(+FIRST, section)           # This pattern is incorrect and produces an error message.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入节模式（<code>input_section_pattern</code>）：与输入节名称匹配的模式，不区分大小写。它是由字面文本构成的。通配符 <code>*</code>匹配0个或多个字符，以及 <code>?</code>匹配任何单个字符，可以使用带引号的输入节名称。</p>
<blockquote>
<p>如果使用不止一个的输入节模式，请确保不同的执行域中没有重复的模式以避免歧义错误。</p>
</blockquote>
</li>
<li><p>输入符号模式（<code>input_symbol_pattern</code>）：可以通过节定义的全局符号的名字来选择输入节，这允许用户从部分链接的对象中选择具有相同名称的各个节。<br><code>:gdef:</code>前缀区分全局符号模式和节模式。例如使用 <code>:gdef:mysym</code>来选择定义为 <code>mysym</code>的节。以下的例子中显示了一个分散加载文件，其中 <code>ExecReg1</code>包含定义全局符号 <code>mysym1</code>的节和包含全局符号 <code>myym2</code>的节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoadRegion 0x8000</span><br><span class="line">&#123;</span><br><span class="line">ExecReg1 +0</span><br><span class="line">&#123;   </span><br><span class="line">       *(:gdef:mysym1)</span><br><span class="line">       *(:gdef:mysym2)</span><br><span class="line">&#125;</span><br><span class="line">        ; rest of scatter-loading description</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用一个引号引起的全局符号模式。<code>:gdef:</code>前缀可以在引号内或引号外。</p>
<blockquote>
<p>如果使用不止一个输入符号模式（<code>input_symbol_pattern</code>），请确保不同的执行域中没有重复的模式以避免歧义错误。</p>
<p>输入节描述符的顺序不重要。</p>
</blockquote>
</li>
<li><p>节特性（<code>section_properties</code>）： 可以是 <code>+FIRST</code>，<code>+LAST</code> 和 <code>OVERALIGN value</code>。其中，OVERALIGN 中的值必须为 2 的正幂，并且必须大于或等于 4。</p>
</li>
</ol>
<blockquote>
<ul>
<li>只有匹配 <code>module_select_pattern</code>和至少一个 <code>input_section_attr</code>或 <code>input_section_pattern</code>的输入节会被包含于执行域中。如果省略（<code>+input_section_attr</code>）或（input_section_pattern），则默认值为 <code>+RO</code>。</li>
<li>不要依赖于编译器生成或ARM库代码库代码使用的的输入节名。例如，使用不同的编译器选项，这些选项可能会在编译之间发生变化。此外，编译器使用的节命名约定不能保证在发行版之间保持不变。</li>
<li>BNF定义包含额外的行返回和空格，以提高可读性。分散加载描述中不需要它们，如果存在于分散文件中，则忽略它们。</li>
</ul>
</blockquote>
<h2 id="5-3-分散加载功能"><a href="#5-3-分散加载功能" class="headerlink" title="5.3 分散加载功能"></a>5.3 分散加载功能</h2><h3 id="5-3-1-分散加载机制"><a href="#5-3-1-分散加载机制" class="headerlink" title="5.3.1 分散加载机制"></a>5.3.1 分散加载机制</h3><p>分散加载机制允许用户使用文本文件中的描述指定映像到链接器的内存映射。</p>
<h4 id="5-3-1-1-分散加载概述"><a href="#5-3-1-1-分散加载概述" class="headerlink" title="5.3.1.1 分散加载概述"></a>5.3.1.1 分散加载概述</h4><p>分散加载使用户可以完全控制映像组成部分的分组和放置。</p>
<p>可以使用分散加载来创建简单的映像，但通常只用于具有复杂内存映射的映像。也就是说，在加载和执行时，多个内存区域分散在内存映射中。</p>
<p>映像内存映射由域和输出节组成，内存映射的每个域具有不同的加载和执行地址。</p>
<p>为了构建一个映像的内存映射，链接器必须有：</p>
<ol>
<li>描述输入节如何分组成输出节和域的分组信息；</li>
<li>描述域在内存映射中的地址的位置信息。</li>
</ol>
<p>当链接器创建一个使用分散加载文件的映像，它会创建一些域相关的符号。只有当用户代码引用它们时，链接器才会创建这些特殊符号。</p>
<h4 id="5-3-1-2-何时使用分散加载"><a href="#5-3-1-2-何时使用分散加载" class="headerlink" title="5.3.1.2 何时使用分散加载"></a>5.3.1.2 何时使用分散加载</h4><p>实现嵌入式系统通常需要分散加载，因为这些系统需要使用ROM、RAM和内存映射的外围设备。</p>
<p>需要分散加载或使用分散加载非常有用的情况：</p>
<ol>
<li>复杂的内存映射：必须放入许多不同内存区域的代码和数据，需要详细说明将这些部分放在内存空间中的哪些位置。</li>
<li>不同类型的内存：许多系统包含各种物理存储设备，如FLASH、ROM、SDRAM和快速SRAM。分散加载描述可以将代码和数据与最合适的内存类型匹配。例如，中断代码可以放入快速SRAM以提高中断响应时间，但不经常使用的配置信息可以被放入较慢的闪存中。</li>
<li>内存映射类型的外设：分散加载描述可以将一个数据节放置在内存映射的精确地址，以便可以访问内存映射的外围设备。</li>
<li>固定位置的函数：即使周围的应用程序已被修改和重新编译，函数也可以放在内存中的统一位置。这对于跳转表的实现非常有用。</li>
<li>使用符号标识堆和堆栈：链接应用程序时，可以为堆和堆栈位置定义符号。</li>
</ol>
<h3 id="5-3-2-根执行域"><a href="#5-3-2-根执行域" class="headerlink" title="5.3.2 根执行域"></a>5.3.2 根执行域</h3><p>根域是一个有相同的加载和执行地址的域。</p>
<h4 id="5-3-2-1-初始化入口点"><a href="#5-3-2-1-初始化入口点" class="headerlink" title="5.3.2.1 初始化入口点"></a>5.3.2.1 初始化入口点</h4><p>映像的初始化入口点必须是一个根域。</p>
<p>如果初始化入口点不是根域，链接会失败，链接器会给出错误信息。</p>
<p>以下就是一个根域的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_1 0x040000           ; load region starts at 0x40000</span><br><span class="line">&#123;                       ; start of execution region descriptions</span><br><span class="line">    ER_RO 0x040000      ; load address = execution address</span><br><span class="line">    &#123;</span><br><span class="line">        * (+RO)         ; all RO sections (must include section with</span><br><span class="line">                        ; initial entry point)</span><br><span class="line">    &#125;</span><br><span class="line">    …                   ; rest of scatter-loading description</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-2-ABSOLUTE属性"><a href="#5-3-2-2-ABSOLUTE属性" class="headerlink" title="5.3.2.2 ABSOLUTE属性"></a>5.3.2.2 <code>ABSOLUTE</code>属性</h4><p>可以使用 <code>ABSOLUTE</code>属性指定根执行域。</p>
<p>将 <code>ABSOLUTE</code>指定为执行域的属性，可以显式指定，也可以允许其默认，并将相同的地址用于第一个执行域和封闭的加载域。</p>
<p>要使执行域地址与加载域地址相同，请执行以下任一操作：</p>
<ol>
<li>为执行域的基址和加载域的基地址指定相同的数值；</li>
<li>为加载域中的第一个执行域指定 <code>+0</code>偏移。</li>
</ol>
<p>如果为加载域中的所有后续执行域指定了零（<code>+0</code>）的偏移，则不在包含 <code>ZI</code>的执行域之后的所有执行域也是根域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_1 0x040000       ; load region starts at 0x40000</span><br><span class="line">&#123;                   ; start of execution region descriptions</span><br><span class="line">    ER_RO 0x040000  ; load address = execution address</span><br><span class="line">    &#123;</span><br><span class="line">        * (+RO)     ; all RO sections (must include section with</span><br><span class="line">                    ; initial entry point)</span><br><span class="line">    &#125;</span><br><span class="line">    …               ; rest of scatter-loading description</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-3-FIXED属性"><a href="#5-3-2-3-FIXED属性" class="headerlink" title="5.3.2.3 FIXED属性"></a>5.3.2.3 <code>FIXED</code>属性</h4><p>可以使用分散加载文件中执行域的FIXED属性来创建在固定地址加载和执行的根域。</p>
<p>使用 <code>FIXED</code>执行域属性确保特定域的加载地址和执行地址相同，可以使用 <code>FIXED</code>属性将任何执行域放置在ROM中的特定地址。<br>例如，以下内存映射显示了固定的执行域：</p>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432722326.png" alt="1701432722326"></p>
<p>以下示例显示了相应的分散加载描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_1 0x040000               ; load region starts at 0x40000</span><br><span class="line">    &#123;                       ; start of execution region descriptions</span><br><span class="line">    ER_RO 0x040000          ; load address = execution address</span><br><span class="line">    &#123;</span><br><span class="line">        * (+RO)             ; RO sections other than those in init.o</span><br><span class="line">    &#125;</span><br><span class="line">    ER_INIT 0x080000 FIXED  ; load address and execution address of this</span><br><span class="line">                            ; execution region are fixed at 0x80000</span><br><span class="line">    &#123;</span><br><span class="line">        init.o(+RO)         ; all RO sections from init.o</span><br><span class="line">    &#125;</span><br><span class="line">    …                       ; rest of scatter-loading description</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用它将函数或数据块（如常量表或校验和）放置在ROM中的固定地址，以便通过指针轻松访问。<br>例如，如果指定将一些初始化代码放在ROM的开头，将校验和放在ROM末尾，则某些内存内容可能未使用。使用 <code>*</code>或 <code>.ANY</code>模块选择器来填充初始化块结束和数据块开始之间的区域。<br>为了使代码更易于维护和调试，建议您在分散加载文件中使用最小数量的放置规范，并将函数和数据的详细放置留给链接器。</p>
<blockquote>
<p>在某些情况下，使用 <code>FIXED</code>和单个加载域是不合适的。指定固定位置的其他技术包括：</p>
<ul>
<li>如果加载器可以处理多个加载区域，请将RO代码或数据放置在其自己的加载域中。</li>
<li>如果不要求函数或数据位于ROM中的固定位置，请使用 <code>ABSOLUTE</code>而不是 <code>FIXED</code>。然后，加载器将数据从加载区域复制到RAM中的指定地址。<br>ABSOLUTE是默认属性。</li>
<li>要将数据结构放置在内存映射I/O的位置，请使用两个加载区域并指定 <code>UNINIT</code>。<code>UNINIT</code>确保内存位置未初始化为零。</li>
</ul>
</blockquote>
<h3 id="5-3-3-使用-ANY模块选择器放置未分配的部分"><a href="#5-3-3-使用-ANY模块选择器放置未分配的部分" class="headerlink" title="5.3.3 使用 .ANY模块选择器放置未分配的部分"></a>5.3.3 使用 <code>.ANY</code>模块选择器放置未分配的部分</h3><p>链接器试图将输入节放入特定的执行区域。对于任何无法解析的输入节，如果这些部分的位置不重要，可以在分散文件中使用 <code>.ANY</code>模块选择器。<br>在大多数情况下，使用单个 <code>.ANY</code>选择器等同于使用 <code>*</code>模块选择器。但是，与 <code>*</code>不同，您可以在多个执行域中指定 <code>.ANY</code>。</p>
<h4 id="5-3-3-1-使用多个-ANY模块选择器时的放置规则"><a href="#5-3-3-1-使用多个-ANY模块选择器时的放置规则" class="headerlink" title="5.3.3.1 使用多个 .ANY模块选择器时的放置规则"></a>5.3.3.1 使用多个 <code>.ANY</code>模块选择器时的放置规则</h4><p>当使用多个 <code>.ANY</code>选择器时，链接器具有放置节的默认规则。<br>当分散加载文件中存在多个 <code>.ANY</code>选择器时，链接器将按大小降序对节进行排序。然后，它获取大小最大的未分配节，并将该节分配给具有足够可用空间的任何特定执行域。（与 <code>*</code>模块选择器的主要不同，<code>*</code>不会做这种选择，<a href="https://www.bilibili.com/video/BV1MR4y157XS/">第7期BSP驱动教程：MDK专题高级进阶，重要的分散加载使用，通过各种实战案例来学习_哔哩哔哩_bilibili</a>）例如，<code>.ANY(.text)</code>被判断为比 <code>.ANY(+RO)</code>更具体。<br>如果多个执行区域同等特定，则将该节分配给剩余空间最多的执行域。<br>例如：</p>
<ol>
<li>如果您有两个同样特定的执行域，其中一个域的大小限制为0x2000，另一个域没有限制，那么所有节都将分配给第二个无界 <code>.ANY</code>域。</li>
<li>如果您有两个同样特定的执行域，其中一个区域的大小限制为0x2000，另一个区域为0x3000，则将要放置的第一个节分配给第二个 <code>.ANY</code>域大小限制为0x3000的区域，直到第二个 <code>.ANY</code>域的剩余大小将减小为0x2000。从此开始，在两个 <code>.ANY</code>执行区域之间交替分配节。</li>
</ol>
<p>可以使用执行域属性 <code>ANY_SIZE</code>指定用于未分配节的最大空间量。</p>
<h2 id="5-4-链接脚本分析"><a href="#5-4-链接脚本分析" class="headerlink" title="5.4 链接脚本分析"></a>5.4 链接脚本分析</h2><p>我们可以回到我们的链接脚本文件，并对其做一定的分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; *************************************************************</span><br><span class="line">; *** Scatter-Loading Description File generated by uVision ***</span><br><span class="line">; *************************************************************</span><br><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00020000  &#123;    ; load region size_region，定义一个加载域，域基地址为0x08000000，域大小为0x00020000，对应实际 Flash 的大小</span><br><span class="line">  ER_IROM1 0x08000000 0x00020000  &#123;  ; load address = execution address 定义一个运行域，第一个运行域的基地址必须和加载域的基地址相同，这是一个根域</span><br><span class="line">   *.o (RESET, +First)      </span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x24000000 0x00080000  &#123;  ; AXI SRAM 512K</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/04/STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image/1701432735069.png" alt="1701432735069"></p>
<h3 id="5-4-1-加载域"><a href="#5-4-1-加载域" class="headerlink" title="5.4.1 加载域"></a>5.4.1 加载域</h3><p><code>LR_IROM1 0x08000000 0x00020000</code>定义了一个加载域，加载域的名称是 <code>LR_IROM1</code> ，域基地址为0x08000000，域大小为0x00020000，对应实际 Flash 的大小。</p>
<h3 id="5-4-2-执行域"><a href="#5-4-2-执行域" class="headerlink" title="5.4.2 执行域"></a>5.4.2 执行域</h3><p><code>ER_IROM1 0x08000000 0x00020000</code>定义一个执行域，第一个执行域的基地址必须和加载域的基地址相同，这是一个根域。</p>
<p><code>*.o</code>匹配所有以 <code>.o</code>结尾的文件，<code>(RESET, +First)</code>限制了必须含有 <code>RESET</code>节（以下内容），且将该节内容放在根域的起始地址内。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">// EXPORT：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是IAR编译器，则使用的是GLOBAL这个指令，如果是GCC编译器，则使用的是.global。COPY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>*(InRoot$$Sections)</code>匹配的是IDE自带的部分函数（MDK的一些库文件），比如 <code>__main.o</code>，<code>_scatter*.o</code>，<code>_dc*.o</code>，必须放置在根域中。</p>
<p><code>.ANY (+RO)</code>匹配所有具有RO只读属性的数据。</p>
<p><code>.ANY (+XO)</code>匹配所有XO属性的数据（只可执行的代码）的内容。关于XO节，可以参考<a href="https://www.armbbs.cn/forum.php?mod=viewthread&amp;tid=110924&amp;highlight=execute">MDK的Option选择中execute-only code区的作用 - 开发环境 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)</a></p>
<p><code>RW_IRAM1 0x24000000 0x00080000</code>定义一个执行域，这个域是一个存放RW和ZI数据的域，域基地址为0x24000000，域大小为0x00080000，对应实际 SRAM的大小。</p>
<p><code>.ANY (+RW +ZI)</code>匹配任意RW和ZI属性的数据。</p>
<h1 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6 参考链接"></a>6 参考链接</h1><p><a href="https://blog.csdn.net/weixin_42328389/article/details/121855164">ARM 内核寄存器 和 基本汇编语言讲解_矜辰所致的博客-CSDN博客_arm汇编语言</a></p>
<p><a href="https://blog.csdn.net/weixin_42328389/article/details/121067474">FreeRTOS记录（三、RTOS任务调度原理解析_Systick、PendSV、SVC）_矜辰所致的博客-CSDN博客_freertos任务调度原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/109057983">ARM汇编语言入门 - 知乎 (zhihu.com)</a></p>
<p><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">Writing ARM Assembly (Part 1) | Azeria Labs (azeria-labs.com)</a></p>
<p>MiniPro STM32H750 开发指南_V1.1.pdf</p>
<p><a href="https://www.bilibili.com/video/BV1AN411R7Be/">【蛋饼嵌入式】我提着鞋带拎自己？嵌入式芯片启动过程全解析，彻底理解bootloader_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.st.com/content/ccc/resource/technical/document/application_note/b9/9b/16/3a/12/1e/40/0c/CD00167594.pdf/files/CD00167594.pdf/jcr:content/translations/en.CD00167594.pdf">AN2606 PDF</a>）</p>
<p><a href="https://www.armbbs.cn/forum.php?mod=viewthread&amp;tid=109321">【不是问题的问题】为什么STM32的Flash地址要设置到0x08000000 - STM32H7 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)</a></p>
<p><a href="https://developer.arm.com/documentation/ka001328/latest">Documentation – Arm Developer</a></p>
<p><a href="https://www.cnblogs.com/solo666/p/16639842.html">gcc链接脚本ld 实例讲解 - solonj - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fmrt.gitbooks.io/riscv-spec-v2-cn/content/index.html">介紹 | RISC-V 指令集手册（卷一） (gitbooks.io)</a></p>
<p>AAPCS:《Procedure Call Standard for the ARM Architecture》</p>
<p>DUI0377G_02_mdk_armlink_user_guide.pdf</p>
<p><a href="https://www.armbbs.cn/forum.php?mod=viewthread&amp;tid=110924&amp;highlight=execute">MDK的Option选择中execute-only code区的作用 - 开发环境 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)</a></p>
<p><a href="https://developer.arm.com/documentation/ddi0489/f/">Arm Cortex-M7 Processor Technical Reference Manual r1p2</a></p>
<p><a href="https://developer.arm.com/documentation/ddi0403/ee">ARMv7-M Architecture Reference Manual</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32系统时钟</title>
    <url>/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-1-什么是时钟"><a href="#1-1-什么是时钟" class="headerlink" title="1.1 什么是时钟"></a>1.1 什么是时钟</h2><p>时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。时钟系统就是CPU的脉搏，决定cpu速率，像人的心跳一样 只有有了心跳，人才能做其他的事情，而单片机有了时钟，才能够运行执行指令，才能够做其他的处理 (点灯，串口，ADC)，时钟的重要性不言而喻。</p>
<h2 id="1-2-为什么-STM32-要有多个时钟源呢？"><a href="#1-2-为什么-STM32-要有多个时钟源呢？" class="headerlink" title="1.2 为什么 STM32 要有多个时钟源呢？"></a>1.2 为什么 STM32 要有多个时钟源呢？</h2><p>STM32本身十分复杂，外设非常多  但我们实际使用的时候只会用到有限的几个外设，使用任何外设都需要时钟才能启动，但并不是所有的外设都需要系统时钟那么高的频率，为了兼容不同速度的设备，有些高速，有些低速，如果都用高速时钟，势必造成浪费   并且，同一个电路，时钟越快功耗越快，同时抗电磁干扰能力也就越弱，所以较为复杂的MCU都是采用多时钟源的方法来解决这些问题。所以便有了STM32的时钟系统和时钟树</p>
<h2 id="1-3-总括"><a href="#1-3-总括" class="headerlink" title="1.3 总括"></a>1.3 总括</h2><ul>
<li>STM32时钟系统主要的目的就是<strong>给相对独立的外设模块提供时钟</strong>，也是<strong>为了降低整个芯片的耗能</strong>。</li>
<li>系统时钟，是处理器运行时间基准（每一条机器指令一个时钟周期）</li>
<li><strong>时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令</strong>。</li>
<li>一个单片机内提供多个不同的系统时钟，可以适应更多的应用场合。</li>
<li><strong>不同的功能模块会有不同的时钟上限，因此提供不同的时钟，也能在一个单片机内放置更多的功能模块。对不同模块的时钟增加开启和关闭功能，可以降低单片机的功耗</strong></li>
<li>STM32为了低功耗，他将所有的外设时钟都设置为disable(不使能)，用到什么外设，只要打开对应外设的时钟就可以， 其他的没用到的可以还是disable(不使能)，这样耗能就会减少。  这就是为什么<strong>不管你配置什么功能都需要先打开对应的时钟的原因</strong></li>
</ul>
<h1 id="二、STM32的时钟系统框图"><a href="#二、STM32的时钟系统框图" class="headerlink" title="二、STM32的时钟系统框图"></a>二、STM32的时钟系统框图</h1><p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704527146976.png" alt="1704527146976"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529893529.png" alt="1704529893529"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704530896581.png" alt="1704530896581"></p>
<p>可以看出系统时钟SYSCLK 的左边  系统时钟有很多种选择，而左边的部分就是设置系统时钟使用那个时钟源，系统时钟SYSCLK 的右边，则是系统时钟通过AHB预分频器，给相对应的外设设置相对应的时钟频率从左到右可以简单理解为  <strong>各个时钟源—-&gt;系统时钟来源的设置—-&gt;各个外设时钟的设置</strong></p>
<h1 id="三、时钟系统"><a href="#三、时钟系统" class="headerlink" title="三、时钟系统"></a>三、时钟系统</h1><h2 id="3-1-各个时钟源-左边的部分"><a href="#3-1-各个时钟源-左边的部分" class="headerlink" title="3.1 各个时钟源    (左边的部分)"></a>3.1 各个时钟源    (左边的部分)</h2><p>STM32 有4个独立时钟源:HSI、HSE、LSI、LSE。</p>
<p>①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br>②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。<br>③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。　<br>④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。</p>
<p>其中LSI是作为IWDGCLK(独立看门狗)时钟源和RTC时钟源 而独立使用而HSI高速内部时钟 HSE高速外部时钟 PLL锁相环时钟  这三个经过分频或者倍频 作为系统时钟来使用PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。  通过倍频之后作为系统时钟的时钟源。</p>
<blockquote>
<p><strong>举个例子：</strong>Keil编写程序是默认的时钟为72Mhz，其实是这么来的：外部晶振(HSE)提供的8MHz（与电路板上的晶振的相关）通过PLLXTPRE分频器后，进入PLLSRC选择开关，进而通过PLLMUL锁相环进行倍频（x9）后，为系统提供72MHz的系统时钟（SYSCLK）。之后是AHB预分频器对时钟信号进行分频，然后为低速外设提供时钟。或者内部RC振荡器(HSI) 为8MHz  /2 为4MHz 进入PLLSRC选择开关，通过PLLMUL锁相环进行倍频（x18）后 为72MHz</p>
<p><strong>PS:</strong>  网上有很多人说是5个时钟源，这种说法有点问题，学习之后就会发现PLL并不是自己产生的时钟源，而是通过其他三个时钟源倍频得到的时钟</p>
</blockquote>
<h2 id="3-2-系统时钟SYSCLK"><a href="#3-2-系统时钟SYSCLK" class="headerlink" title="3.2 系统时钟SYSCLK"></a>3.2 系统时钟SYSCLK</h2><p>系统时钟SYSCLK可来源于三个时钟源：</p>
<p>①、HSI振荡器时钟<br>②、HSE振荡器时钟<br>③、PLL时钟</p>
<p>最大为72Mhz</p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704527483565.png" alt="1704527483565"></p>
<h2 id="3-3-USB时钟"><a href="#3-3-USB时钟" class="headerlink" title="3.3 USB时钟"></a>3.3 USB时钟</h2><p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704527515393.png" alt="1704527515393"></p>
<p>STM32中有一个全速功能的USB模块，其串行接口引擎需要一个频率为48MHz的时钟源。该时钟源只能从PLL输出端获取（唯一的），，可以选择为1.5分频或者1分频，也就是，当需要使用USB模块时，PLL必须使能，并且时钟频率配置为48MHz或72MHz。</p>
<h2 id="3-4-把时钟信号输出到外部"><a href="#3-4-把时钟信号输出到外部" class="headerlink" title="3.4 把时钟信号输出到外部"></a>3.4 把时钟信号输出到外部</h2><p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704527552500.png" alt="1704527552500"></p>
<p>STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟。可以把时钟信号输出供外部使用</p>
<h2 id="3-5-系统时钟通过AHB分频器给外设提供时钟-右边的部分-重点"><a href="#3-5-系统时钟通过AHB分频器给外设提供时钟-右边的部分-重点" class="headerlink" title="3.5 系统时钟通过AHB分频器给外设提供时钟(右边的部分)  重点"></a>3.5 系统时钟通过AHB分频器给外设提供时钟(右边的部分)  重点</h2><p><strong>从左到右可以简单理解为  系统时钟—-&gt;AHB分频器—-&gt;各个外设分频倍频器 —-&gt;   外设时钟的设置</strong></p>
<p>右边部分为：系统时钟SYSCLK通过AHB分频器分频后送给各模块使用，AHB分频器可选择1、2、4、8、16、64、128、256、512分频。其中AHB分频器输出的时钟送给5大模块使用：</p>
<p>　①内核总线：送给AHB总线、内核、内存和DMA使用的HCLK时钟。</p>
<p>　②Tick定时器：通过8分频后送给Cortex的系统定时器时钟。</p>
<p>　③I2S总线：直接送给Cortex的空闲运行时钟FCLK。</p>
<p>　④APB1外设：送给APB1分频器。APB1分频器可选择1、2、4、8、16分频，其输出一路供APB1外设使用(PCLK1，最大频率36MHz)，另一路送给通用定时器使用。该倍频器可选择1或者2倍频，时钟输出供定时器2-7使用。</p>
<p>　⑤APB2外设：送给APB2分频器。APB2分频器可选择1、2、4、8、16分频，其输出一路供APB2外设使用(PCLK2，最大频率72MHz)，另一路送给高级定时器。该倍频器可选择1或者2倍频，时钟输出供定时器1和定时器8使用。</p>
<p>另外，APB2分频器还有一路输出供ADC分频器使用，分频后送给ADC模块使用。ADC分频器可选择为2、4、6、8分频。</p>
<p>需要注意的是，如果 APB 预分频器分频系数是 1，则定时器时钟频率 (TIMxCLK) 为 PCLKx。否则，定时器时钟频率将为 APB 域的频率的两倍：<code>TIMxCLK = 2xPCLKx</code></p>
<h3 id="3-5-1-APB1和APB2的对应外设"><a href="#3-5-1-APB1和APB2的对应外设" class="headerlink" title="3.5.1 APB1和APB2的对应外设"></a>3.5.1 APB1和APB2的对应外设</h3><h4 id="F1系列"><a href="#F1系列" class="headerlink" title="F1系列"></a>F1系列</h4><p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704527942686.png" alt="1704527942686"></p>
<p>APB1上面连接的是低速外设，包括电源接口、备份接口、CAN、USB、I2C1、I2C2、USART2、USART3、UART4、UART5、SPI2、SP3等；</p>
<p>而APB2上面连接的是高速外设，包括UART1、SPI1、Timer1、ADC1、ADC2、ADC3、所有的普通I/O口（PA-PE）、第二功能I/O（AFIO）口等。</p>
<h4 id="F4系列"><a href="#F4系列" class="headerlink" title="F4系列"></a>F4系列</h4><p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704527973454.png" alt="1704527973454"></p>
<p>这个和F1系列类似，我们就举几个特殊的</p>
<p> <strong>APB2总线：</strong>高级定时器timer1, timer8以及通用定时器timer9, timer10, timer11   UTART1,USART6</p>
<p> <strong>APB1总线：</strong>通用定时器timer2-timer5，通用定时器timer12-timer14以及基本定时器timer6,timer7  UTART2-UTART5</p>
<p>F4系列的系统时钟频率最高能到168M</p>
<p><strong>具体  可以在 stm32f10x_rcc.h  和stm32f40x_rcc.h   中查看，或者通过 STM32参考手册搜索“系统架构”或者“系统结构”  查看外设挂在哪个时钟下</strong> </p>
<h2 id="3-6-时钟监视系统（CSS）"><a href="#3-6-时钟监视系统（CSS）" class="headerlink" title="3.6 时钟监视系统（CSS）"></a>3.6 时钟监视系统（CSS）</h2><p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529499885.png" alt="1704529499885"></p>
<p>STM32还提供了一个时钟监视系统（CSS），用于监视高速外部时钟（HSE）的工作状态。倘若HSE失效，会自动切换（高速内部时钟）HSI作为系统时钟的输入，保证系统的正常运行。</p>
<h1 id="四、时钟配置"><a href="#四、时钟配置" class="headerlink" title="四、时钟配置"></a>四、时钟配置</h1><h2 id="4-1-配置流程"><a href="#4-1-配置流程" class="headerlink" title="4.1 配置流程"></a>4.1 配置流程</h2><h4 id="①-在STM32单片机复位之后，首先进入-startup-程序："><a href="#①-在STM32单片机复位之后，首先进入-startup-程序：" class="headerlink" title="①. 在STM32单片机复位之后，首先进入 startup 程序："></a>①. 在STM32单片机复位之后，首先进入 <strong>startup</strong> 程序：</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Reset handler</span></span><br><span class="line"><span class="symbol">Reset_Handler</span>    <span class="meta">PROC</span></span><br><span class="line">                 <span class="meta">EXPORT</span>  Reset_Handler             [WEAK]</span><br><span class="line">        <span class="meta">IMPORT</span>  SystemInit</span><br><span class="line">        <span class="meta">IMPORT</span>  __main</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">LDR</span>     <span class="built_in">R0</span>, <span class="symbol">=SystemInit</span></span><br><span class="line">                 <span class="keyword">BLX</span>     <span class="built_in">R0</span></span><br><span class="line">                 <span class="keyword">LDR</span>     <span class="built_in">R0</span>, <span class="symbol">=__main</span></span><br><span class="line">                 <span class="keyword">BX</span>      <span class="built_in">R0</span></span><br><span class="line">                 <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure>
<p>可以看出，在进入main主程序之前，先触发了 <strong>SystemInit()</strong> 函数（打开相应的时钟晶振，分频选择），这样就可以保证不需要每次都把时钟配置程序写入main.c文件了；</p>
<p>同样，当你想要执行自定义时钟配置程序时也可以改动这个部分。</p>
<h4 id="②-SystemInit"><a href="#②-SystemInit" class="headerlink" title="②. SystemInit()"></a>②. SystemInit()</h4><p>该函数位于 <strong>system_stm32f4xx.c</strong> 文件中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Setup the microcontroller system</span></span><br><span class="line"><span class="comment">  *         Initialize the Embedded Flash Interface, the PLL and update the </span></span><br><span class="line"><span class="comment">  *         SystemFrequency variable.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* FPU settings ------------------------------------------------------------*/</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (__FPU_PRESENT == 1) &amp;&amp; (__FPU_USED == 1)</span></span><br><span class="line">    SCB-&gt;CPACR |= ((<span class="number">3UL</span> &lt;&lt; <span class="number">10</span>*<span class="number">2</span>)|(<span class="number">3UL</span> &lt;&lt; <span class="number">11</span>*<span class="number">2</span>));  <span class="comment">/* set CP10 and CP11 Full Access */</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Reset the RCC clock configuration to the default reset state ------------*/</span></span><br><span class="line">  <span class="comment">/* Set HSION bit */</span></span><br><span class="line">  RCC-&gt;CR |= (<span class="type">uint32_t</span>)<span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset CFGR register */</span></span><br><span class="line">  RCC-&gt;CFGR = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset HSEON, CSSON and PLLON bits */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFEF6FFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset PLLCFGR register */</span></span><br><span class="line">  RCC-&gt;PLLCFGR = <span class="number">0x24003010</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset HSEBYP bit */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFFFBFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable all interrupts */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)</span></span><br><span class="line">  <span class="built_in">SystemInit_ExtMemCtl</span>(); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */</span></span></span><br><span class="line">       </span><br><span class="line">  <span class="comment">/* Configure the System clock source, PLL Multiplier and Divider factors, </span></span><br><span class="line"><span class="comment">     AHB/APBx prescalers and Flash settings ----------------------------------*/</span></span><br><span class="line">  <span class="built_in">SetSysClock</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，SystemInit()函数的作用就是使RCC_CR寄存器Bit0 置1，即开启 16MHz HSI 振荡器，复位其他的时钟，然后转到SetSysClock()函数中。<br>对于系统时钟，默认情况下就是SystemInit 函数的 SetSysClock() 函数中间判断的</p>
<h4 id="③-SetSysClock"><a href="#③-SetSysClock" class="headerlink" title="③. SetSysClock()"></a>③. SetSysClock()</h4><p>该函数位于 <strong>system_stm32f4xx.c</strong> 文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SetSysClock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx)</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*            PLL (clocked by HSE) used as System clock source                */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> StartUpCounter = <span class="number">0</span>, HSEStatus = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Enable HSE */</span></span><br><span class="line">  RCC-&gt;CR |= ((<span class="type">uint32_t</span>)RCC_CR_HSEON);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class="line">    StartUpCounter++;</span><br><span class="line">  &#125; <span class="keyword">while</span>((HSEStatus == <span class="number">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="type">uint32_t</span>)<span class="number">0x01</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="type">uint32_t</span>)<span class="number">0x00</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HSEStatus == (<span class="type">uint32_t</span>)<span class="number">0x01</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Select regulator voltage output Scale 1 mode */</span></span><br><span class="line">    RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN;</span><br><span class="line">    PWR-&gt;CR |= PWR_CR_VOS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HCLK = SYSCLK / 1*/</span></span><br><span class="line">    RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx)    </span></span><br><span class="line">    <span class="comment">/* PCLK2 = HCLK / 2*/</span></span><br><span class="line">    RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV2;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* PCLK1 = HCLK / 4*/</span></span><br><span class="line">    RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV4;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F40_41xxx || STM32F427_437x || STM32F429_439xx */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F401xx)</span></span><br><span class="line">    <span class="comment">/* PCLK2 = HCLK / 2*/</span></span><br><span class="line">    RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV1;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* PCLK1 = HCLK / 4*/</span></span><br><span class="line">    RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F401xx */</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* Configure the main PLL */</span></span><br><span class="line">    RCC-&gt;PLLCFGR = PLL_M | (PLL_N &lt;&lt; <span class="number">6</span>) | (((PLL_P &gt;&gt; <span class="number">1</span>) <span class="number">-1</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q &lt;&lt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable the main PLL */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till the main PLL is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F427_437xx) || defined (STM32F429_439xx)</span></span><br><span class="line">    <span class="comment">/* Enable the Over-drive to extend the clock frequency to 180 Mhz */</span></span><br><span class="line">    PWR-&gt;CR |= PWR_CR_ODEN;</span><br><span class="line">    <span class="keyword">while</span>((PWR-&gt;CSR &amp; PWR_CSR_ODRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    PWR-&gt;CR |= PWR_CR_ODSWEN;</span><br><span class="line">    <span class="keyword">while</span>((PWR-&gt;CSR &amp; PWR_CSR_ODSWRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/* Configure Flash prefetch, Instruction cache, Data cache and wait state */</span></span><br><span class="line">    FLASH-&gt;ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F427_437x || STM32F429_439xx  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F40_41xxx)   </span></span><br><span class="line">    <span class="comment">/* Configure Flash prefetch, Instruction cache, Data cache and wait state */</span></span><br><span class="line">    FLASH-&gt;ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F40_41xxx  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F401xx)</span></span><br><span class="line">    <span class="comment">/* Configure Flash prefetch, Instruction cache, Data cache and wait state */</span></span><br><span class="line">    FLASH-&gt;ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_2WS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F401xx */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Select the main PLL as system clock source */</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="type">uint32_t</span>)((<span class="type">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class="line">    RCC-&gt;CFGR |= RCC_CFGR_SW_PLL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till the main PLL is used as system clock source */</span></span><br><span class="line">    <span class="keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="type">uint32_t</span>)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">/* If HSE fails to start-up, the application will have wrong clock</span></span><br><span class="line"><span class="comment">         configuration. User can add here some code to deal with this error */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不要被上面的长度吓到了，其实无非就是对RCC几个寄存器的赋值，里面注释很详细，对着寄存器功能表，可以很容易理解其意思！</p>
<p>主要有耐心去看，很容易就搞明白怎么回事了！</p>
<h2 id="4-2-配置寄存器（STMF4为例）"><a href="#4-2-配置寄存器（STMF4为例）" class="headerlink" title="4.2 配置寄存器（STMF4为例）"></a>4.2 配置寄存器（STMF4为例）</h2><p>STM32中，对时钟的配置，即是对  <strong>RCC</strong> （Reset Clocl Control，复位和时钟寄存器）的配置，时钟寄存器包含如下几个：</p>
<h4 id="4-2-1-时钟控制寄存器（RCC-CR）"><a href="#4-2-1-时钟控制寄存器（RCC-CR）" class="headerlink" title="4.2.1 时钟控制寄存器（RCC_CR）"></a>4.2.1 时钟控制寄存器（RCC_CR）</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">偏移地址：0x00</span></span><br><span class="line"><span class="string">复位值：0x0000</span> <span class="string">XX83，其中</span> <span class="string">X</span> <span class="string">未定义。</span></span><br><span class="line"><span class="string">访问：无等待周期，按字、半字和字节访问</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529210374.png" alt="1704529210374"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529234919.png" alt="1704529234919"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529283002.png" alt="1704529283002"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529293529.png" alt="1704529293529"></p>
<h4 id="4-3-2-RCC-时钟配置寄存器-RCC-CFGR"><a href="#4-3-2-RCC-时钟配置寄存器-RCC-CFGR" class="headerlink" title="4.3.2 RCC 时钟配置寄存器 (RCC_CFGR)"></a>4.3.2 RCC 时钟配置寄存器 (RCC_CFGR)</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">偏移地址：0x08</span></span><br><span class="line"><span class="string">复位值：0x0000</span> <span class="number">0000</span></span><br><span class="line"><span class="string">访问：0</span> <span class="string"></span> <span class="string">等待周期</span> <span class="string"></span> <span class="number">2</span><span class="string">，按字、半字和字节访问</span></span><br><span class="line"><span class="string">只有在时钟源切换期间进行访问时才会插入</span> <span class="number">1</span> <span class="string">或</span> <span class="number">2</span> <span class="string">个等待周期。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529339090.png" alt="1704529339090"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529355941.png" alt="1704529355941"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529366930.png" alt="1704529366930"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529386175.png" alt="1704529386175"></p>
<p><img src="/2024/04/04/STM32%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/image/1704529393757.png" alt="1704529393757"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698746511013.png" alt="1698746511013"><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756153909.png" alt="1698756153909"></p>
<h1 id="一、文件系统的基本组成"><a href="#一、文件系统的基本组成" class="headerlink" title="一、文件系统的基本组成"></a>一、文件系统的基本组成</h1><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p>
<p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p>
<p>Linux 最经典的一句话是： <strong>「一切皆文件」</strong> ，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p>
<p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和  <strong>目录项（directory entry）</strong> ，它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li>索引节点，也就是 <code>inode</code>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li>
<li>目录项，也就是 <code>dentry</code>，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。</li>
</ul>
<p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p>
<p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p>
<blockquote>
<p><strong>目录项和目录是一个东西吗？</strong></p>
<p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p>
<p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p>
<p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。</p>
<p><strong>那文件数据是如何存储在磁盘的呢？</strong></p>
<p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。</p>
<p>所以，文件系统把多个扇区组成了一个<strong>逻辑块</strong>，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p>
</blockquote>
<p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756258672.png" alt="1698756258672"></p>
<p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。</p>
<p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是 <strong>超级块</strong> 、<strong>索引节点区</strong>和 <strong>数据块区</strong> 。</p>
<ul>
<li><strong>超级块</strong> ，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。</li>
<li><strong>索引节点区</strong> ，用来存储索引节点；</li>
<li><strong>数据块区</strong> ，用来存储文件或目录数据；</li>
</ul>
<p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：</p>
<ul>
<li><strong>超级块</strong> ：当文件系统挂载时进入内存；</li>
<li><strong>索引节点区</strong> ：当文件被访问时进入内存；</li>
</ul>
<h1 id="二、虚拟文件系统"><a href="#二、虚拟文件系统" class="headerlink" title="二、虚拟文件系统"></a>二、虚拟文件系统</h1><p>文件系统的种类众多，而操作系统希望 <strong>对用户提供一个统一的接口</strong> ，于是在用户层与文件系统层引入了中间层，这个中间层就称为 <strong>虚拟文件系统（Virtual File System，VFS）</strong> 。</p>
<p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p>
<p>在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756275943.png" alt="1698756275943"></p>
<p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：</p>
<ul>
<li><strong>磁盘的文件系统</strong> ，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。</li>
<li><strong>内存的文件系统</strong> ，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 /proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。</li>
<li><strong>网络的文件系统</strong> ，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li>
</ul>
<p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p>
<h1 id="三、文件的使用"><a href="#三、文件的使用" class="headerlink" title="三、文件的使用"></a>三、文件的使用</h1><p>我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756308228.png" alt="1698756308228"></p>
<p>write 的过程</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fd = open(name, flag); # 打开文件</span><br><span class="line">...</span><br><span class="line">write(fd,...);         # 写数据</span><br><span class="line">...</span><br><span class="line">close(fd);             # 关闭文件</span><br></pre></td></tr></table></figure>
<p>上面简单的代码是读取一个文件的过程：</p>
<ul>
<li>首先用 <code>open</code> 系统调用打开文件，<code>open</code> 的参数中包含文件的路径名和文件名。</li>
<li>使用 <code>write</code> 写数据，其中 <code>write</code> 使用 <code>open</code> 所返回的文件描述符，并不使用文件名作为参数。</li>
<li>使用完文件后，要用 <code>close</code> 系统调用关闭文件，避免资源的泄露。</li>
</ul>
<p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表  <strong>「文件描述符」</strong> ，所以说文件描述符是打开文件的标识。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756353829.png" alt="1698756353829"></p>
<p>操作系统在打开文件表中维护着打开文件的状态和信息：</p>
<ul>
<li><strong>文件指针</strong>：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>
<li><strong>文件打开计数器</strong>：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li>
<li><strong>文件磁盘位置</strong>：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li>
<li><strong>访问权限</strong>：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求</li>
</ul>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1701509098206.png" alt="1701509098206"></p>
<p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。</p>
<p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。</p>
<p>我们来分别看一下，读文件和写文件的过程：</p>
<ul>
<li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。</li>
<li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。</li>
</ul>
<p>所以说， <strong>文件系统的基本操作单位是数据块</strong> 。</p>
<h1 id="四、文件的存储"><a href="#四、文件的存储" class="headerlink" title="四、文件的存储"></a>四、文件的存储</h1><p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：</p>
<ul>
<li>连续空间存放方式</li>
<li>非连续空间存放方式</li>
</ul>
<p>其中，非连续空间存放方式又可以分为「<a href="https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%25E9%2593%25BE%25E8%25A1%25A8%26spm%3D1001.2101.3001.7020">链表</a>方式」和「索引方式」。</p>
<p>不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。</p>
<h2 id="4-1-连续空间存放方式"><a href="#4-1-连续空间存放方式" class="headerlink" title="4.1 连续空间存放方式"></a>4.1 连续空间存放方式</h2><p>连续空间存放方式顾名思义，<strong>文件存放在磁盘「连续的」物理空间中</strong>。这种模式下，文件的数据都是紧密相连，<strong>读写效率很高</strong>，因为一次磁盘寻道就可以读出整个文件。</p>
<p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。</p>
<p>所以，<strong>文件头里需要指定「起始块的位置」和「长度」</strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。</p>
<p>注意，此处说的文件头，就类似于 Linux 的 inode。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756506172.png" alt="1698756506172"></p>
<p>连续空间存放的方式虽然读写效率高，<strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。</strong></p>
<p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756523589.png" alt="1698756523589"></p>
<p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。</p>
<p>那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。</p>
<h2 id="4-2-非连续空间存放方式"><a href="#4-2-非连续空间存放方式" class="headerlink" title="4.2 非连续空间存放方式"></a>4.2 非连续空间存放方式</h2><p>非连续空间存放方式分为「链表方式」和「索引方式」。</p>
<h3 id="4-2-1-链表方式"><a href="#4-2-1-链表方式" class="headerlink" title="4.2.1 链表方式"></a>4.2.1 链表方式</h3><p>链表的方式存放是<strong>离散的，不用连续的</strong>，于是就可以<strong>消除磁盘碎片</strong>，可大大提高磁盘空间的利用率，同时<strong>文件的长度可以动态扩展</strong>。根据实现的方式的不同，链表可分为<strong>「隐式链表」</strong>和<strong>「显式链接」</strong>两种形式。</p>
<p>文件要以<strong>「隐式链表」</strong>的方式存放的话，<strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置</strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756612470.png" alt="1698756612470"></p>
<p>隐式链表的存放方式的<strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间</strong>。隐式链接分配的稳定性较差，系统在运行过程中由于软件或者硬件错误<strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失</strong>。</p>
<p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是<strong>「显式链接」</strong>，它指<strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中</strong>，该表在整个磁盘仅设置一张，<strong>每个表项中存放链接指针，指向下一个数据块号。</strong></p>
<p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为  <strong>文件分配表（File Allocation Table，FAT）</strong> 。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698756655342.png" alt="1698756655342"></p>
<p>由于查找记录的过程是在内存中进行的，因而不仅显著地<strong>提高了检索速度</strong>，而且<strong>大大减少了访问磁盘的次数</strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是<strong>不适用于大磁盘</strong>。</p>
<p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。</p>
<h3 id="4-2-2-索引方式"><a href="#4-2-2-索引方式" class="headerlink" title="4.2.2 索引方式"></a>4.2.2 索引方式</h3><p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。</p>
<p><strong>索引的实现是为每个文件创建一个「索引数据块」，里面存放的是指向文件数据块的指针列表</strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。</p>
<p>另外，<strong>文件头需要包含指向「索引数据块」的指针</strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。</p>
<p>创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757246533.png" alt="1698757246533"></p>
<p>索引的方式优点在于：</p>
<ul>
<li>文件的创建、增大、缩小很方便；</li>
<li>不会有碎片的问题；</li>
<li>支持顺序读写和随机读写；</li>
</ul>
<p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。</p>
<p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。</p>
<p>先来看看<strong>链表 + 索引的组合，这种组合称为「链式索引块」</strong>，它的实现方式是<strong>在索引数据块留出一个存放下一个索引数据块的指针</strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757310413.png" alt="1698757310413"></p>
<p>还有另外一种组合方式是<strong>索引 + 索引的方式，这种组合称为「多级索引块」</strong>，实现方式是<strong>通过一个索引块来存放多个索引数据块</strong>，一层套一层索引，像极了俄罗斯套娃是吧。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757327790.png" alt="1698757327790"></p>
<h1 id="五、Unix-文件的实现方式"><a href="#五、Unix-文件的实现方式" class="headerlink" title="五、Unix 文件的实现方式"></a>五、Unix 文件的实现方式</h1><p>我们先把前面提到的文件实现方式，做个比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>访问磁盘次数</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序分配</td>
<td>需访问磁盘1次</td>
<td>顺序存取速度快，当文件是定长时可以根据文件起始地址及记录长度进行随机访问</td>
<td>要求连续的存储空间，会产生外部碎片，不利于文件的动态扩充</td>
</tr>
<tr>
<td>链表分配</td>
<td>需访问磁盘n次</td>
<td>无外部碎片，提供了外存空间的利用率，动态增长较方便</td>
<td>只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗内存或磁盘空间</td>
</tr>
<tr>
<td>索引分配</td>
<td>m级需访问磁盘m+1次</td>
<td>可以随机访问，易于文件的增删</td>
<td>索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757337984.png" alt="1698757337984"></p>
<p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757347621.png" alt="1698757347621"></p>
<p>它是根据文件的大小，存放的方式会有所变化：</p>
<ul>
<li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li>
<li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li>
<li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li>
<li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li>
</ul>
<p>那么，文件头（<strong>Inode</strong>）就需要包含 13 个指针：</p>
<ul>
<li>10 个指向数据块的指针；</li>
<li>第 11 个指向索引块的指针；</li>
<li>第 12 个指向二级索引块的指针；</li>
<li>第 13 个指向三级索引块的指针；</li>
</ul>
<p>所以，这种方式能很灵活地支持小文件和大文件的存放：</p>
<ul>
<li>对于小文件使用直接查找的方式可减少索引数据块的开销；</li>
<li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；</li>
</ul>
<p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。</p>
<p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。</p>
<h1 id="六、空闲空间管理"><a href="#六、空闲空间管理" class="headerlink" title="六、空闲空间管理"></a>六、空闲空间管理</h1><p>前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？</p>
<p>那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：</p>
<ul>
<li>空闲表法</li>
<li>空闲链表法</li>
<li>位图法</li>
</ul>
<h2 id="6-1-空闲表法"><a href="#6-1-空闲表法" class="headerlink" title="6.1 空闲表法"></a>6.1 空闲表法</h2><p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757401267.png" alt="1698757401267"></p>
<p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</p>
<p>这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。</p>
<h2 id="6-2-空闲链表法"><a href="#6-2-空闲链表法" class="headerlink" title="6.2 空闲链表法"></a>6.2 空闲链表法</h2><p>我们也可以使用<strong>「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块</strong>，这样也能很方便的找到空闲块并管理起来。如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757424352.png" alt="1698757424352"></p>
<p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。</p>
<p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。</p>
<p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>
<h2 id="6-3-位图法"><a href="#6-3-位图法" class="headerlink" title="6.3 位图法"></a>6.3 位图法</h2><p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。</p>
<p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure>
<p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</p>
<h1 id="七、文件系统的结构"><a href="#七、文件系统的结构" class="headerlink" title="七、文件系统的结构"></a>七、文件系统的结构</h1><p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。</p>
<p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 <code>4 * 1024 * 8 = 2^15</code>个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 <code>2^15 * 4 * 1024 = 2^27</code>个 byte，也就是 128M。</p>
<p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。</p>
<p>在 Linux 文件系统，把这个结构称为一个<strong>块组</strong>，那么有 N 多的块组，就能够表示 N 大的文件。</p>
<p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757451418.png" alt="1698757451418"></p>
<p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p>
<ul>
<li><strong>超级块</strong>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>
<li><strong>块组描述符</strong>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li><strong>数据位图和 inode 位图</strong>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>
<li><strong>inode 列表</strong>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li><strong>数据块</strong>，包含文件的有用数据。</li>
</ul>
<p>你可以会发现每个块组里有很多重复的信息，比如<strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要</strong>，这么做是有两个原因：</p>
<ul>
<li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li>
<li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li>
</ul>
<p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。</p>
<h1 id="八、目录的存储"><a href="#八、目录的存储" class="headerlink" title="八、目录的存储"></a>八、目录的存储</h1><p>在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的目录，它是如何保存的呢？</p>
<p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 vim 打开它，它也有 inode，inode 里面也是指向一些块。</p>
<p>和普通文件不同的是，<strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</strong></p>
<p>在目录文件的块中，最简单的保存格式就是<strong>列表</strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p>
<p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757494170.png" alt="1698757494170"></p>
<p>通常，第一项是「<code>.</code>」，表示当前目录，第二项是「<code>..</code>」，表示上一级目录，接下来就是一项一项的文件名和 inode。</p>
<p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。</p>
<p>于是，保存目录的格式改成<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p>
<p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p>
<h1 id="九、软链接和硬链接"><a href="#九、软链接和硬链接" class="headerlink" title="九、软链接和硬链接"></a>九、软链接和<strong>硬链接</strong></h1><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<strong>硬链接（Hard Link）</strong> 和<strong>软链接（Symbolic Link）</strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p>
<p><strong>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode</strong>，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757530614.png" alt="1698757530614"></p>
<p><strong>软链接相当于重新创建一个文件，这个文件有独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757557687.png" alt="1698757557687"></p>
<h1 id="十、文件-I-O"><a href="#十、文件-I-O" class="headerlink" title="十、文件 I/O"></a>十、文件 I/O</h1><p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有</p>
<ul>
<li>缓冲与非缓冲 I/O</li>
<li>直接与非直接 I/O</li>
<li>阻塞与非阻塞 I/O VS 同步与异步 I/O</li>
</ul>
<p>接下来，分别对这些分类讨论讨论。</p>
<h1 id="十一、缓冲与非缓冲-I-O"><a href="#十一、缓冲与非缓冲-I-O" class="headerlink" title="十一、缓冲与非缓冲 I/O"></a>十一、缓冲与非缓冲 I/O</h1><p>文件操作的标准库是可以实现数据的缓存，那么<strong>根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：</strong></p>
<ul>
<li>缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li>
<li>非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。</li>
</ul>
<p>这里所说的「缓冲」特指标准库内部实现的缓冲。</p>
<p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>
<h1 id="十二、直接与非直接-I-O"><a href="#十二、直接与非直接-I-O" class="headerlink" title="十二、直接与非直接 I/O"></a>十二、直接与非直接 I/O</h1><p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。</p>
<p>那么，<strong>根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：</strong></p>
<ul>
<li>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</li>
<li>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</li>
</ul>
<p>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。</p>
<blockquote>
<p>如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？<br>以下几种场景会触发内核缓存的数据写入磁盘：</p>
</blockquote>
<ul>
<li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>
<li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li>
<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>
<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>
</ul>
<h1 id="十三、阻塞与非阻塞-I-O-VS-同步与异步-I-O"><a href="#十三、阻塞与非阻塞-I-O-VS-同步与异步-I-O" class="headerlink" title="十三、阻塞与非阻塞 I/O VS 同步与异步 I/O"></a>十三、阻塞与非阻塞 I/O VS 同步与异步 I/O</h1><p>为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。</p>
<p>先来看看<strong>阻塞 I/O</strong>，当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</p>
<p>注意，<strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</strong>。过程如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757629510.png" alt="1698757629510"></p>
<p>知道了阻塞 I/O ，来看看<strong>非阻塞 I/O</strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。过程如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757642815.png" alt="1698757642815"></p>
<p>注意，<strong>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</strong></p>
<p>举个例子，访问管道或 socket 时，如果设置了 <code>O_NONBLOCK</code> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。</p>
<p>应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。</p>
<p>为了解决这种傻乎乎轮询方式，于是 <strong>I/O 多路复用</strong>技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。</p>
<p>这个做法大大改善了 CPU 的利用率，因为当调用了 I/O 多路复用接口，如果没有事件发生，那么当前线程就会发生阻塞，这时 CPU 会切换其他线程执行任务，等内核发现有事件到来的时候，会唤醒阻塞在 I/O 多路复用接口的线程，然后用户可以进行后续的事件处理。</p>
<p>整个流程要比阻塞 IO 要复杂，似乎也更浪费性能。但  <strong>I/O 多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求</strong> （参见：<a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">I/O 多路复用：select/poll/epoll <strong>(opens new window)</strong></a>）。用户可以注册多个 socket，然后不断地调用 I/O 多路复用接口读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<p>下图是使用 select I/O 多路复用过程。注意，<code>read</code> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个 <strong>同步的过程</strong> ，需要等待：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757714839.png" alt="1698757714839"></p>
<p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用<strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p>
<p>而真正的<strong>异步 I/O</strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。</p>
<p>当我们发起 <code>aio_read</code> 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757737449.png" alt="1698757737449"></p>
<p>下面这张图，总结了以上几种 I/O 模型：</p>
<p><img src="/2024/04/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image/1698757743317.png" alt="1698757743317"></p>
<p>在前面我们知道了，I/O 是分为两个过程的：</p>
<ol>
<li>数据准备的过程</li>
<li>数据从内核空间拷贝到用户进程缓冲区的过程</li>
</ol>
<p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。</p>
<p>异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。</p>
<blockquote>
<p>用故事去理解这几种 I/O 模型</p>
</blockquote>
<p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。</p>
<p>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。</p>
<p>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。</p>
<p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（<code>select</code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。</p>
<p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试</title>
    <url>/2024/04/05/GDB%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="GDB调试（常见指令）"><a href="#GDB调试（常见指令）" class="headerlink" title="GDB调试（常见指令）"></a>GDB调试（常见指令）</h1><p><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">【Linux】GDB用法详解(5小时快速教程) - Avatarx - 博客园</a></p>
<h1 id="1-GDB-概述"><a href="#1-GDB-概述" class="headerlink" title="1. GDB 概述"></a><strong>1. GDB</strong> <strong>概述</strong></h1><p>GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在 UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。</p>
<p>一般来说，GDB主要帮忙你完成下面四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ol>
<p>从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有时候，命令行的调试工具却有着图形化工具所不能完成的功能。</p>
<h1 id="2-使用GDB"><a href="#2-使用GDB" class="headerlink" title="2. 使用GDB"></a><strong>2. 使用GDB</strong></h1><p>一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p>
<blockquote>
<p>gcc -g hello.c -o hello</p>
<p>g++ -g hello.cpp -o hello</p>
</blockquote>
<p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。</p>
<h2 id="2-1-启动GDB的方法有以下几种："><a href="#2-1-启动GDB的方法有以下几种：" class="headerlink" title="2.1 启动GDB的方法有以下几种："></a>2.1 <strong>启动GDB的方法有以下几种：</strong></h2><ol>
<li><strong>gdb program</strong></li>
</ol>
<p>program 也就是你的执行文件，一般在当前目录下。</p>
<ol>
<li><strong>gdb program core</strong></li>
</ol>
<p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p>
<ol>
<li><strong>gdb program 1234</strong></li>
</ol>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="2-2-GDB的启动开关"><a href="#2-2-GDB的启动开关" class="headerlink" title="2.2 GDB的启动开关"></a>2.2 GDB的启动开关</h2><p>GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。下面只列举一些比较常用的参数：</p>
<ul>
<li><strong>-symbols=SYMFILE</strong></li>
</ul>
<p>从指定文件中读取符号表。</p>
<ul>
<li><strong>-se=FILE</strong></li>
</ul>
<p>从指定文件中读取符号表信息，并把他用在可执行文件中。</p>
<ul>
<li><strong>-core=COREFILE</strong></li>
</ul>
<p>调试时core dump的core文件。</p>
<ul>
<li><strong>-directory=DIR</strong></li>
</ul>
<p>加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。</p>
<h1 id="3-GDB-的命令概貌"><a href="#3-GDB-的命令概貌" class="headerlink" title="3 GDB 的命令概貌"></a><strong>3 GDB</strong> <strong>的命令概貌</strong></h1><p>启动gdb后，就进入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb的命令可以使用help命令来查看，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">root@linux:/home/benben# **gdb**</span><br><span class="line">GNU gdb <span class="number">5.1</span><span class="number">.1</span></span><br><span class="line">Copyright <span class="number">2002</span> Free Software Foundation, Inc.</span><br><span class="line">GDB is free software, covered by the GNU General Public License, <span class="keyword">and</span> you are</span><br><span class="line">welcome to change it <span class="keyword">and</span>/<span class="keyword">or</span> distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> to see the conditions.</span><br><span class="line">There is absolutely no warranty <span class="keyword">for</span> GDB. Type <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i386-suse-linux&quot;</span>.</span><br><span class="line">**(gdb) help**</span><br><span class="line">List of classes of commands:</span><br><span class="line"> </span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying <span class="keyword">and</span> examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"> </span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed by a <span class="keyword">class</span> <span class="title class_">name</span> <span class="keyword">for</span> a list of commands in that <span class="keyword">class</span>.</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed by command name <span class="keyword">for</span> full documentation.</span><br><span class="line">Command name abbreviations are allowed <span class="keyword">if</span> unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>gdb的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用 help 命令，如：help breakpoints，查看设置断点的所有命令。也可以直接help 来查看命令的帮助。</p>
<p>gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其列出来。</p>
<p><strong>示例一：</strong> 在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b func</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048458</span>: file hello.c, line <span class="number">10.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例二：</strong> 敲入b按两次TAB键，你会看到所有b打头的命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b</span><br><span class="line">backtrace <span class="keyword">break</span> bt</span><br></pre></td></tr></table></figure>
<p><strong>示例三：</strong> 只记得函数的前缀，可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b make_ &lt;按TAB键&gt;</span><br><span class="line">（再按下一次TAB键，你会看到:）</span><br><span class="line">make_a_section_from_file make_environ</span><br><span class="line">make_abs_section make_function_type</span><br><span class="line">make_blockvector make_pointer_type</span><br><span class="line">make_cleanup make_reference_type</span><br><span class="line">make_command make_symbol_completion_list</span><br></pre></td></tr></table></figure>
<p>GDB把所有make开头的函数全部例出来给你查看。</p>
<p>要退出gdb时，只用发quit或命令简称q就行了。</p>
<h1 id="4-GDB-中运行UNIX的shell程序"><a href="#4-GDB-中运行UNIX的shell程序" class="headerlink" title="4 GDB 中运行UNIX的shell程序"></a><strong>4 GDB</strong> <strong>中运行UNIX的shell程序</strong></h1><h2 id="4-1-shell"><a href="#4-1-shell" class="headerlink" title="4.1 shell"></a>4.1 shell</h2><p>在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure>
<p>调用UNIX的shell来执行，环境变量SHELL中定义的UNIX的shell将会被用来执行，如果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。</p>
<p>退出用exit命令，回到gdb提示符</p>
<h2 id="4-2-make"><a href="#4-2-make" class="headerlink" title="4.2 make"></a>4.2 make</h2><p>还有一个gdb命令是make：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>可以在gdb中执行make命令来重新build自己的程序。这个命令等价于“shell make ”。</p>
<h1 id="5-在GDB中运行程序"><a href="#5-在GDB中运行程序" class="headerlink" title="5 在GDB中运行程序"></a>5 <strong>在GDB中运行程序</strong></h1><p>当以 gdb 方式启动gdb后，gdb会在PATH路径和当前目录中搜索源文件。如要确认gdb是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。</p>
<p>在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。</p>
<h2 id="5-1-程序运行参数。"><a href="#5-1-程序运行参数。" class="headerlink" title="5.1 程序运行参数。"></a>5.<strong>1 程序运行参数。</strong></h2><p>set args 可指定运行时参数。（如：set args <em>10 20 30 40 50</em> ）</p>
<p>show args 命令可以查看设置好的运行参数。</p>
<h2 id="5-2-运行环境。"><a href="#5-2-运行环境。" class="headerlink" title="5.2 运行环境。"></a>5.<strong>2 运行环境。</strong></h2><p>path</p>
<p>可设定程序的运行路径。</p>
<p>show paths 查看程序的运行路径。</p>
<p>set env <em>environmentVarname=value</em> 设置环境变量。如：set env <em>USER=benben</em>show env <em>[varname]</em> 查看环境变量，不带varname，打印出当前所有环境变量。</p>
<h2 id="5-3-工作目录。"><a href="#5-3-工作目录。" class="headerlink" title="5.3 工作目录。"></a>5.<strong>3 工作目录。</strong></h2><p>cd 相当于shell的cd命令。</p>
<p>pwd 显示当前的所在目录。</p>
<h2 id="5-4-程序的输入输出。"><a href="#5-4-程序的输入输出。" class="headerlink" title="5.4 程序的输入输出。"></a>5.<strong>4 程序的输入输出。</strong></h2><p>info terminal 显示你程序用到的终端的模式。</p>
<p>使用重定向控制程序输出。如：run &gt; outfile</p>
<p>tty命令可以设置输入输出使用的终端设备。如：tty /dev/tty1</p>
<h2 id="5-5-调试已运行的程序"><a href="#5-5-调试已运行的程序" class="headerlink" title="5.5 调试已运行的程序"></a>5.<strong>5 调试已运行的程序</strong></h2><p>两种方法：</p>
<ol>
<li>在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID <em>process-id</em> 格式挂接正在运行的程序。</li>
<li>先用gdb 关联上源代码，并进行gdb，在gdb中用attach <em>process-id</em> 命令来挂接进程的PID。并用detach来取消挂接的进程。</li>
</ol>
<h1 id="6-暂停-恢复程序运行"><a href="#6-暂停-恢复程序运行" class="headerlink" title="6 暂停 / 恢复程序运行"></a><strong>6</strong> <strong>暂停 / 恢复程序运行</strong></h1><p><strong>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行</strong>。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。</p>
<p>当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。</p>
<p>在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可以使用c或是continue命令。</p>
<h1 id="7-常见指令"><a href="#7-常见指令" class="headerlink" title="7 常见指令"></a>7 常见指令</h1><h2 id="7-1-设置断点（BreakPoint）"><a href="#7-1-设置断点（BreakPoint）" class="headerlink" title="7.1 设置断点（BreakPoint）"></a>7.1 <strong>设置断点（BreakPoint）</strong></h2><p>我们用break命令来设置断点。正面有几点设置断点的方法：</p>
<ol>
<li><p><strong>break <em>function</em></strong><br>在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函数名。</p>
</li>
<li><p><strong>break <em>linenum</em></strong><br>在指定行号停住。</p>
</li>
<li><p><strong>break <em>+offset /</em> break -<em>offset</em></strong></p>
<ol>
<li>break <em>+offset</em></li>
<li>break <em>-offset</em></li>
</ol>
<p>在当前行号的前面或后面的offset行停住。offset为自然数。</p>
</li>
<li><p><strong>break <em>filename:linenum</em></strong><br>在源文件filename的linenum行处停住。</p>
</li>
<li><p><strong>break <em>filename:function</em></strong><br>在源文件filename的function函数的入口处停住。</p>
</li>
<li><p><strong>break </strong>address<em>*</em><br>在程序运行的内存地址处停住。</p>
</li>
<li><p><strong>break</strong><br>break命令没有参数时，表示在下一条指令处停住。</p>
</li>
<li><p><strong>break … if <em>cond</em></strong><br>…可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设置break if i=100，表示当i为100时停住程序。</p>
</li>
</ol>
<p>查看断点时，可使用info命令，如下所示：（注：n表示断点号）</p>
<ol>
<li>info breakpoints [n]</li>
<li>info break [n]</li>
<li>info watchpoints [n]</li>
</ol>
<h2 id="7-2-设置观察点（WatchPoint）"><a href="#7-2-设置观察点（WatchPoint）" class="headerlink" title="7.2 设置观察点（WatchPoint）"></a>7.2 <strong>设置观察点（WatchPoint）</strong></h2><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来设置观察点：</p>
<ol>
<li><strong>watch <em>expr</em></strong><br>为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。</li>
<li><strong>rwatch <em>expr</em></strong><br>当表达式（变量）expr被读时，停住程序。</li>
<li><strong>awatch <em>expr</em></strong><br>当表达式（变量）的值被读或被写时，停住程序。</li>
<li>info watchpoints<br>查看观察点、断点和捕捉点信息，同<strong>info break</strong> 一样.</li>
</ol>
<h2 id="7-3-设置捕捉点（CatchPoint）"><a href="#7-3-设置捕捉点（CatchPoint）" class="headerlink" title="7.3 设置捕捉点（CatchPoint）"></a>7.3 <strong>设置捕捉点（CatchPoint）</strong></h2><p>你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。设置捕捉点的格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> *event*</span><br></pre></td></tr></table></figure>
<p>当event发生时，停住程序。event可以是下面的内容：</p>
<ol>
<li><strong>throw</strong> 一个C++抛出的异常。（throw为关键字）</li>
<li><strong>catch</strong> 一个C++捕捉到的异常。（catch为关键字）</li>
<li><strong>exec</strong> 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）</li>
<li><strong>fork</strong> 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）</li>
<li><strong>vfork</strong> 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）</li>
<li><strong>load</strong> 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）</li>
<li><strong>unload</strong> 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tcatch *event*</span><br></pre></td></tr></table></figure>
<p>只设置一次捕捉点，当程序停住以后，应点被自动删除。</p>
<h2 id="7-4-维护停止点"><a href="#7-4-维护停止点" class="headerlink" title="7.4 维护停止点"></a>7.4 <strong>维护停止点</strong></h2><p>上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来进行维护。</p>
<ol>
<li><strong>clear</strong><br>清除所有的已定义的停止点。</li>
<li><strong>clear <em>function</em></strong><br>清除所有设置在函数上的停止点。</li>
<li><strong>clear <em>linenum</em></strong><br>清除所有设置在指定行上的停止点。</li>
<li><strong>clear <em>filename:linenum</em></strong><br>清除所有设置在指定文件：指定行上的停止点。</li>
<li><strong>delete <em>[breakpoints] [range…]</em></strong><br>删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。<br>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。</li>
<li><strong>disable <em>[breakpoints] [range…]</em></strong><br>disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis.</li>
<li><strong>enable <em>[breakpoints] [range…]</em></strong><br>enable所指定的停止点，breakpoints为停止点号。</li>
<li><strong>enable <em>[breakpoints] once range…</em></strong><br>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。</li>
<li><strong>enable <em>[breakpoints] delete range…</em></strong><br>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</li>
</ol>
<h2 id="7-5-停止条件维护"><a href="#7-5-停止条件维护" class="headerlink" title="7.5 停止条件维护"></a>7.5 <strong>停止条件维护</strong></h2><p>前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有 break和watch命令支持if，catch目前暂不支持if）</p>
<ol>
<li><strong>condition <em>bnum expression</em></strong><br>修改断点号为bnum的停止条件为expression。</li>
<li><strong>condition <em>bnum</em></strong><br>清除断点号为bnum的停止条件。</li>
<li><strong>ignore <em>bnum count</em></strong><br>表示忽略断点号为bnum的停止条件count次。</li>
</ol>
<h2 id="7-6-为停止点设定运行命令"><a href="#7-6-为停止点设定运行命令" class="headerlink" title="7.6 为停止点设定运行命令"></a>7.6 <strong>为停止点设定运行命令</strong></h2><p>我们可以 <strong>使用GDB提供的command命令来设置停止点的运行命令</strong> 。也就是说，当运行的程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于GDB的自动化调试是一个强大的支持。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">commands [bnum]</span><br><span class="line"></span><br><span class="line">... command-list ...</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> foo <span class="keyword">if</span> x &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">commands</span><br><span class="line"></span><br><span class="line">printf <span class="string">&quot;x is %d &quot;</span>,x</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>断点设置在函数foo中，断点条件是x&gt;0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。</p>
<p>如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个end就行了。</p>
<h2 id="7-7-断点菜单"><a href="#7-7-断点菜单" class="headerlink" title="7.7 断点菜单"></a>7.7 <strong>断点菜单</strong></h2><p>在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break 不能告诉GDB要停在哪个函数的入口。当然，你可以使用break 也就是把函数的参数类型告诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的断点。你只要输入你菜单列表中的编号就可以了。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b String::after</span><br><span class="line">[<span class="number">0</span>] cancel</span><br><span class="line">[<span class="number">1</span>] all</span><br><span class="line">[<span class="number">2</span>] file:String.cc; line number:<span class="number">867</span></span><br><span class="line">[<span class="number">3</span>] file:String.cc; line number:<span class="number">860</span></span><br><span class="line">[<span class="number">4</span>] file:String.cc; line number:<span class="number">875</span></span><br><span class="line">[<span class="number">5</span>] file:String.cc; line number:<span class="number">853</span></span><br><span class="line">[<span class="number">6</span>] file:String.cc; line number:<span class="number">846</span></span><br><span class="line">[<span class="number">7</span>] file:String.cc; line number:<span class="number">735</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xb26c</span>: file String.cc, line <span class="number">867.</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0xb344</span>: file String.cc, line <span class="number">875.</span></span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0xafcc</span>: file String.cc, line <span class="number">846.</span></span><br><span class="line">Multiple breakpoints were set.</span><br><span class="line">Use the <span class="string">&quot;delete&quot;</span> command to <span class="keyword">delete</span> unwanted breakpoints.</span><br><span class="line">(gdb)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见，GDB列出了所有after的重载函数，你可以选一下列表编号就行了。0表示放弃设置断点，1表示所有函数都设置断点。</p>
<h2 id="7-8-恢复程序运行和单步调试"><a href="#7-8-恢复程序运行和单步调试" class="headerlink" title="7.8 恢复程序运行和单步调试"></a>7.8 <strong>恢复程序运行和单步调试</strong></h2><p>当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用step或next命令单步跟踪程序。</p>
<ol>
<li><p><strong>continue <em>[ignore-count]</em></strong><br>c <em>[ignore-count]</em><br>fg <em>[ignore-count]</em><br>恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。</p>
</li>
<li><p><strong>step <em>[count]</em></strong><br>单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，<strong>加表示执行后面的count条指令，然后再停住。</strong></p>
</li>
<li><p><strong>next <em>[count]</em></strong><br>同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，<strong>加表示执行后面的count条指令，然后再停住。</strong></p>
</li>
<li><p><strong>set step-mode on</strong><br><strong>打开step-mode模式</strong> ，于是，在进行单步跟踪时，程序会因为没有debug信息而停住。这个参数有很利于查看机器码。</p>
</li>
<li><p><strong>set step-mod off</strong><br><strong>关闭step-mode模式。</strong>This is the default.</p>
</li>
<li><p><strong>show step-mode</strong><br><strong>显示 gdb 是否会在没有源代码行调试信息的情况下停止或跳过函数。</strong></p>
</li>
<li><p><strong>finish</strong><br><strong>运行程序，直到当前函数完成返回。</strong>并打印函数返回时的堆栈地址和返回值及参数值等信息。</p>
</li>
<li><p><strong>until 或 u</strong><br><strong>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</strong></p>
</li>
<li><p><strong>until <em>location /</em> u <em>location</em></strong><br><strong>继续运行程序，直到到达指定位置或返回当前堆栈帧。</strong> location 是 break 可以接受的任何参数形式。这种形式的命令使用断点，因此比不带参数的 until 更快。只有当指定的位置位于当前堆栈帧中时，才会实际到达该位置。这意味着 until 可以用来跳过递归函数的调用。<br>例如，在下面的代码中，如果当前位置是第 96 行，那么执行直到第 99 行的命令将在同一次调用阶乘的过程中执行程序到第 99 行，即在内部调用返回之后。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span> <span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		value *= <span class="built_in">factorial</span> (value - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>stepi 或 si 或 stepi repeatCount</strong><br><strong>单步跟踪一条机器指令！</strong>一条程序代码有可能由数条机器指令完成，stepi可以单步执行机器指令。在执行机器指令时，使用 “display/i $pc “通常很有用。这样，每次程序停止时，gdb 都会自动显示下一条要执行的指令。</p>
</li>
</ol>
<h2 id="7-9-信号（Signals）"><a href="#7-9-信号（Signals）" class="headerlink" title="7.9 信号（Signals）"></a>7.9 <strong>信号（Signals）</strong></h2><p><strong>信号是一种软中断，是一种处理异步事件的方法。</strong>一般来说，操作系统都支持许多信号。尤其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下非常重要的一种技术。</p>
<p>GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。你可以用GDB的handle命令来完成这一功能。</p>
<ol>
<li><strong>handle signal <em>[keywords…]</em></strong><br><strong>在GDB中定义一个信号处理。</strong>信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从 SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。可选参数关键字（如下所述）说明了要进行的更改。<ol>
<li>nostop<br>当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。</li>
<li>stop<br>当被调试的程序收到信号时，GDB会停住你的程序。这也暗示了 nostop 关键字。</li>
<li>print<br>当被调试的程序收到信号时，GDB会显示出一条信息。</li>
<li>noprint<br>当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。这也暗示了 nostop 关键字。</li>
<li>pass<br>noignore<br>当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序处理，否则，如果信号是致命的，且未得到处理，则可能会终止运行。</li>
<li>nopass<br>ignore<br>当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</li>
<li>info signals<br>info handle<br>查看有哪些信号在被GDB检测中。</li>
</ol>
</li>
</ol>
<h2 id="7-10-线程（Thread-Stops）"><a href="#7-10-线程（Thread-Stops）" class="headerlink" title="7.10 线程（Thread Stops）"></a>7.10 <strong>线程（Thread Stops）</strong></h2><p>如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线程。GDB很容易帮你完成这一工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> *linespec* thread *threadno*</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span> *linespec* thread *threadno* <span class="keyword">if</span> ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID</strong> ，注意，这个ID是GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你不指定‘thread <em>threadno</em> ’则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> frik.c:<span class="number">13</span> thread <span class="number">28</span> <span class="keyword">if</span> bartab &gt; lim</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。</p>
<h1 id="8-查看栈信息"><a href="#8-查看栈信息" class="headerlink" title="8 查看栈信息"></a>8 查看栈信息</h1>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>GDB调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile</title>
    <url>/2024/04/06/Makefile/</url>
    <content><![CDATA[<p>说明：本文来着《陈皓大神makefile》</p>
<h1 id="一、Makefile-介绍"><a href="#一、Makefile-介绍" class="headerlink" title="一、Makefile 介绍"></a>一、Makefile 介绍</h1><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>我们的规则是：</p>
<p>  1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br>  2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br>  3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h2 id="1-1-Makefile的规则"><a href="#1-1-Makefile的规则" class="headerlink" title="1.1 Makefile的规则"></a>1.1 Makefile的规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">[Tab]command</span><br></pre></td></tr></table></figure>
<p>  <strong>target也就是一个目标文件</strong>，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<p>  <strong>prerequisites就是要生成那个target所需要的文件或是目标</strong>。</p>
<p>  <strong>command也就是make需要执行的命令</strong>。（任意的Shell命令）</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，<strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</strong>。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<h2 id="1-2-一个示例"><a href="#1-2-一个示例" class="headerlink" title="1.2 一个示例"></a>1.2 一个示例</h2><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最终目标文件--可执行文件</span></span><br><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">      insert.o search.o files.o utils.o</span><br><span class="line">      cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">            insert.o search.o files.o utils.o</span><br><span class="line"><span class="comment"># 中间目标文件</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">      cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">      cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">      cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">      cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">      cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">      cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">      cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">      cc -c utils.c</span><br><span class="line"><span class="comment"># 伪目标文件</span></span><br><span class="line">clean :</span><br><span class="line">      rm edit main.o kbd.o command.o display.o /</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>反斜杠（/）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p>
<p>在这个makefile中，<strong>目标文件（target）</strong>包含：执行文件edit和中间目标文件（<em>.o），<em>*依赖文件（prerequisites）</em></em>就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，<strong>make并不管命令是怎么工作的，他只管执行所定义的命令</strong>。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<blockquote>
<p>很多时候，为了方便，会将unix/linux下的vim编辑器设自动缩进等功能，造成的后果是TAB键被用4个空格替代，那么在编写makefile的时候，去使用TAB，会发现编译的命令的所在行，没有变色，而且执行make指令的时候，会报一个<strong>遗漏的分隔符</strong>这样的错误，因此如果报错了，可以手动修改一下vim的配置文件，具体内容可以参考百度，这里只是讲一下make错误的一种原因</p>
</blockquote>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h2 id="1-3-make是如何工作的"><a href="#1-3-make是如何工作的" class="headerlink" title="1.3 make是如何工作的"></a><strong>1.3 make是如何工作的</strong></h2><p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<p>  1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br>  2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。<br>  3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。<br>  4、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）<br>  5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。</p>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将<strong>不会被自动执行</strong>，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p>
<p>而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h2 id="1-4-makefile中使用变量"><a href="#1-4-makefile中使用变量" class="headerlink" title="1.4 makefile中使用变量"></a>1.4 makefile中使用变量</h2><p>在上面的例子中，先让我们看看edit的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">         insert.o search.o files.o utils.o</span><br><span class="line">      cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">            insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line"><span class="comment"># 最终目标文件</span></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">      cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment"># 中间目标文件</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">      cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">      cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">      cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">      cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">      cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">      cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">      cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">      cc -c utils.c</span><br><span class="line"><span class="comment"># 伪目标文件</span></span><br><span class="line">clean :</span><br><span class="line">      rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。</p>
<h2 id="1-5-让make自动推导"><a href="#1-5-让make自动推导" class="headerlink" title="1.5 让make自动推导"></a>1.5 让make自动推导</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p><strong>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中</strong>，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">      cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">      rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。</p>
<h2 id="1-6-另类风格的makefile"><a href="#1-6-另类风格的makefile" class="headerlink" title="1.6 另类风格的makefile"></a>1.6 另类风格的makefile</h2><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">      cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">      rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h2 id="1-7-清空目标文件的规则"><a href="#1-7-清空目标文件的规则" class="headerlink" title="1.7 清空目标文件的规则"></a>1.7 <strong>清空目标文件的规则</strong></h2><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>更为稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	-rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>前面说过，.PHONY意思表示clean是一个“伪目标”。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。<strong>不成文的规矩是——“clean从来都是放在文件的最后”</strong>。</p>
<h1 id="二、Makefile-总述"><a href="#二、Makefile-总述" class="headerlink" title="二、Makefile 总述"></a>二、Makefile 总述</h1><h2 id="2-1-Makefile里有什么？"><a href="#2-1-Makefile里有什么？" class="headerlink" title="2.1 Makefile里有什么？"></a><strong>2.1 Makefile里有什么？</strong></h2><p>Makefile里主要包含了五个东西：<strong>显式规则、隐晦规则、变量定义、文件指示和注释</strong>。</p>
<p>1、<strong>显式规则</strong>。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</p>
<p>2、<strong>隐晦规则</strong>。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</p>
<p>3、<strong>变量的定义</strong>。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
<p>4、<strong>文件指示</strong>。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p>
<p>5、<strong>注释</strong>。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。</p>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p>
<h2 id="2-2-Makefile的文件名"><a href="#2-2-Makefile的文件名" class="headerlink" title="2.2 Makefile的文件名"></a><strong>2.2 Makefile的文件名</strong></h2><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“—file”参数，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f Make.Linux</span><br><span class="line"></span><br><span class="line">make --file Make.AIX。</span><br></pre></td></tr></table></figure>
<h2 id="2-3-引用其它的Makefile"><a href="#2-3-引用其它的Makefile" class="headerlink" title="2.3 引用其它的Makefile"></a><strong>2.3 引用其它的Makefile</strong></h2><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>  filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和 <code>&lt;filename&gt;</code>可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>
<p>  等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk`</span><br></pre></td></tr></table></figure>
<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<p>  1、如果make执行时，有“-I”或“—include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。<br>  2、如果目录 <code>&lt;prefix&gt;</code>/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>  其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<h2 id="2-4-环境变量-MAKEFILES"><a href="#2-4-环境变量-MAKEFILES" class="headerlink" title="2.4 环境变量 MAKEFILES"></a><strong>2.4 环境变量 MAKEFILES</strong></h2><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议<strong>不要使用这个环境变量</strong>，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h2 id="2-5-make的工作方式"><a href="#2-5-make的工作方式" class="headerlink" title="2.5 make的工作方式"></a><strong>2.5 make的工作方式</strong></h2><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>
<p>  1、读入所有的Makefile。<br>  2、读入被include的其它Makefile。<br>  3、<strong>初始化文件中的变量</strong>。<br>  4、推导隐晦规则，并分析所有规则。<br>  5、为所有的目标文件创建依赖关系链。<br>  6、根据依赖关系，决定哪些目标要重新生成。<br>  7、执行生成命令。</p>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h1 id="三、书写规则"><a href="#三、书写规则" class="headerlink" title="三、书写规则"></a>三、书写规则</h1><p>规则包含两个部分，一个是<strong>依赖关系</strong>，一个是<strong>生成目标的方法</strong>。</p>
<p>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p>
<h2 id="3-1-规则举例"><a href="#3-1-规则举例" class="headerlink" title="3.1 规则举例"></a><strong>3.1 规则举例</strong></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c defs.h    <span class="comment"># foo模块</span></span><br><span class="line">	cc -c -g foo.c</span><br></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：</p>
<p>  1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。<br>  2、如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</p>
<h2 id="3-2-规则的语法"><a href="#3-2-规则的语法" class="headerlink" title="3.2 规则的语法"></a><strong>3.2 规则的语法</strong></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">    command</span><br></pre></td></tr></table></figure>
<p>   或是这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites ; command</span><br><span class="line">      command</span><br></pre></td></tr></table></figure>
<p><strong>targets是文件名</strong>，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p>
<p><strong>command是命令行</strong>，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p>
<p><strong>prerequisites也就是目标所依赖的文件（或依赖目标）</strong>。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。</p>
<p>如果命令太长，你可以使用反斜框（‘/’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。</p>
<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>
<h2 id="3-3-在规则中使用通配符"><a href="#3-3-在规则中使用通配符" class="headerlink" title="3.3 在规则中使用通配符"></a><strong>3.3 在规则中使用通配符</strong></h2><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[…]”。这是和Unix的B-Shell是相同的。</p>
<p>波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。</p>
<p>通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\”，如“\\*”来表示真实的“*”字符，而不是任意长度的字符串。</p>
<p>好吧，还是先来看几个例子吧：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o</span><br></pre></td></tr></table></figure>
<p>  上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">print: *.c</span></span><br><span class="line">     lpr -p <span class="variable">$?</span></span><br><span class="line">     touch print</span><br></pre></td></tr></table></figure>
<p>  上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>
<p>  上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<p>这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。</p>
<h2 id="3-4-文件搜寻"><a href="#3-4-文件搜寻" class="headerlink" title="3.4 文件搜寻"></a><strong>3.4 文件搜寻</strong></h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是<strong>把这许多的源文件分类，并存放在不同的目录中</strong>。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是<strong>把一个路径告诉make，让make在自动去找。</strong></p>
<p>Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<p>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。<strong>目录由“冒号”分隔</strong>。（当然，当前目录永远是最高优先搜索的地方）</p>
<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（<strong>注意，它是全小写的</strong>），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;</span><br></pre></td></tr></table></figure>
<p>  <strong>为符合模式 <code>&lt;pattern&gt;</code>的文件指定搜索目录 <code>&lt;directories&gt;</code>。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vpath &lt;pattern&gt;</span><br></pre></td></tr></table></figure>
<p>  <strong>清除符合模式 <code>&lt;pattern&gt;</code>的文件的搜索目录。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vpath</span><br></pre></td></tr></table></figure>
<p>  <strong>清除所有已被设置好了的文件搜索目录。</strong></p>
<p>vapth使用方法中的 <code>&lt;pattern&gt;</code>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。<code>&lt;pattern&gt;</code>指定了要搜索的文件集，而 <code>&lt;directories&gt;</code>则指定了 <code>&lt;pattern&gt;</code>的文件集的搜索的目录。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>
<p>该语句表示，<strong>要求make在“../headers”目录下搜索所有以“.h”结尾的文件。</strong>（如果某文件在当前目录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的 <code>&lt;pattern&gt;</code>，或是被重复了的 <code>&lt;pattern&gt;</code>，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %  blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>
<p>其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %  blish</span><br></pre></td></tr></table></figure>
<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h2 id="3-5-伪目标"><a href="#3-5-伪目标" class="headerlink" title="3.5 伪目标"></a><strong>3.5 伪目标</strong></h2><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o temp</span><br></pre></td></tr></table></figure>
<p>正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）</p>
<p>因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个<strong>标签</strong>，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记<strong>“.PHONY”来显示地指明一个目标是“伪目标”</strong>，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>
<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o temp</span><br></pre></td></tr></table></figure>
<p><strong>伪目标一般没有依赖的文件。</strong>但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">      cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">      cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">      cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们<strong>声明了一个“all”的伪目标，其依赖于其它三个目标</strong>。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">      rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">      rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">      rm *.diff</span><br></pre></td></tr></table></figure>
<p>“make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h2 id="3-6-多目标"><a href="#3-6-多目标" class="headerlink" title="3.6 多目标"></a><strong>3.6 多目标</strong></h2><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">      generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>  上述规则等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">      generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">      generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<p>  其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。</p>
<h2 id="3-7-静态模式"><a href="#3-7-静态模式" class="headerlink" title="3.7 静态模式"></a><strong>3.7 静态模式</strong></h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">      &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>  targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>  target-parrtern是指明了targets的模式，也就是的目标集模式。</p>
<p>  prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 <code>&lt;target-parrtern&gt;</code>定义成“%.o”，意思是我们的 <code>&lt;target&gt;</code>集合中都是以“.o”结尾的，而如果我们的 <code>&lt;prereq-parrterns&gt;</code>定义成“%.c”，意思是对 <code>&lt;target-parrtern&gt;</code>所形成的目标集进行二次定义，其计算方法是，取 <code>&lt;target-parrtern&gt;</code>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>
<p>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。</p>
<p>看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">      <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">      <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">      <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">      <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">      emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例子展示了Makefile中更大的弹性。</p>
<h2 id="3-8-自动生成依赖性"><a href="#3-8-自动生成依赖性" class="headerlink" title="3.8 自动生成依赖性"></a><strong>3.8 自动生成依赖性</strong></h2><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。</p>
<p>  gcc -M main.c的输出是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h /</span></span><br><span class="line">     /usr/<span class="keyword">include</span>/sys/cdefs.h /usr/<span class="keyword">include</span>/gnu/stubs.h /</span><br><span class="line">     /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="keyword">include</span>/stddef.h /</span><br><span class="line">     /usr/<span class="keyword">include</span>/bits/types.h /usr/<span class="keyword">include</span>/bits/pthreadtypes.h /</span><br><span class="line">     /usr/<span class="keyword">include</span>/bits/sched.h /usr/<span class="keyword">include</span>/libio.h /</span><br><span class="line">     /usr/<span class="keyword">include</span>/_G_config.h /usr/<span class="keyword">include</span>/wchar.h /</span><br><span class="line">     /usr/<span class="keyword">include</span>/bits/wchar.h /usr/<span class="keyword">include</span>/gconv.h /</span><br><span class="line">     /usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="keyword">include</span>/stdarg.h /</span><br><span class="line">     /usr/<span class="keyword">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure>
<p>  gcc -MM main.c的输出则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h</span></span><br></pre></td></tr></table></figure>
<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>
<p>于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生[.d]文件：</p>
<blockquote>
<p>这里没看懂</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">    	@set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    	<span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.; \</span><br><span class="line">    	sed &#x27;s/\(<span class="variable">$*</span>\)\.o[ :]*/\1.o <span class="variable">$@</span> : /g&#x27; &lt; <span class="variable">$@</span>.&gt; <span class="variable">$@</span>; \</span><br><span class="line">    	rm -f <span class="variable">$@</span>.</span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“</p>
<p><code>.</code>意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>转成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o main.d : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line">  <span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>
<p>上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。</p>
<h1 id="四、书写命令"><a href="#四、书写命令" class="headerlink" title="四、书写命令"></a><strong>四、书写命令</strong></h1><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，<strong>每条命令的开头必须以[Tab]键开头</strong>，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</p>
<h2 id="4-1-显示命令"><a href="#4-1-显示命令" class="headerlink" title="4.1 显示命令"></a><strong>4.1 显示命令</strong></h2><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">echo 正在编译XXX模块......</span><br><span class="line">正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>如果make执行时，带入make参数“-n”或“—just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数“-s”或“—slient”则是全面禁止命令的显示。</p>
<h2 id="4-2-命令执行"><a href="#4-2-命令执行" class="headerlink" title="4.2 命令执行"></a><strong>4.2 命令执行</strong></h2><p><strong>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。</strong>需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<p>  示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">        cd /home/hchen</span><br><span class="line">        pwd</span><br></pre></td></tr></table></figure>
<p>  示例二：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">        cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>
<p>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>
<h2 id="4-3-命令出错"><a href="#4-3-命令出错" class="headerlink" title="4.3 命令出错"></a><strong>4.3 命令出错</strong></h2><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">      -rm -f *.o</span><br></pre></td></tr></table></figure>
<p>还有一个全局的办法是，给make加上“-i”或是“—ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的make的参数的是“-k”或是“—keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h2 id="4-4-嵌套执行make"><a href="#4-4-嵌套执行make" class="headerlink" title="4.4 嵌套执行make"></a><strong>4.4 嵌套执行make</strong></h2><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">      cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">      <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p>
<p>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p>
<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;</span><br></pre></td></tr></table></figure>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  示例一：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> variable = value</span><br><span class="line"></span><br><span class="line"><span class="comment">#   其等价于：</span></span><br><span class="line"></span><br><span class="line">variable = value</span><br><span class="line"><span class="keyword">export</span> variable</span><br><span class="line"></span><br><span class="line"><span class="comment">#    其等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> variable := value</span><br><span class="line"></span><br><span class="line"><span class="comment">#    其等价于：</span></span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line"> <span class="keyword">export</span> variable</span><br><span class="line"></span><br><span class="line"><span class="comment">#  示例二：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> variable += value</span><br><span class="line"></span><br><span class="line"><span class="comment">#    其等价于：</span></span><br><span class="line"></span><br><span class="line">variable += value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">      cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>
<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在“嵌套执行”中比较有用的参数，“-w”或是“—print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">make: Entering directory `/home/hchen/gnu/make&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>而在完成下层make后离开目录时，我们会看到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">make: Leaving directory `/home/hchen/gnu/make&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“—slient”）或是“—no-print-directory”，那么，“-w”总是失效的。</p>
<h2 id="4-5-定义命令包"><a href="#4-5-定义命令包" class="headerlink" title="4.5 定义命令包"></a><strong>4.5 定义命令包</strong></h2><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">      $(run-yacc)</span><br></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y“</p>
<p>“$@”就是“foo.c“</p>
<p>（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h1 id="五、使用变量"><a href="#五、使用变量" class="headerlink" title="五、使用变量"></a><strong>五、使用变量</strong></h1><p>在<strong>Makefile中的定义的变量，就像是C/C++语言中的宏一样</strong>，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<p>有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。</p>
<h2 id="5-1-变量的基础"><a href="#5-1-变量的基础" class="headerlink" title="5.1 变量的基础"></a><strong>5.1 变量的基础</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“&#123;&#125;”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。</span><br></pre></td></tr></table></figure>
<p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">      cc -o program <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$(objects)</span> : defs.h</span><br></pre></td></tr></table></figure>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.<span class="variable">$(foo)</span></span><br><span class="line">      <span class="variable">$(foo)</span><span class="variable">$(foo)</span> -<span class="variable">$(foo)</span> prog.<span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>展开后得到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">prog.o : prog.c</span><br><span class="line">      cc -c prog.c</span><br></pre></td></tr></table></figure>
<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。</p>
<p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h2 id="5-2-变量中的变量"><a href="#5-2-变量中的变量" class="headerlink" title="5.2 变量中的变量"></a><strong>5.2 变量中的变量</strong></h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">      echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。</p>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure>
<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 或：</span></span><br><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>
<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<p>那么，y的值是“bar”，而不是“foo bar”。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (0,$&#123;MAKELEVEL&#125;)</span><br><span class="line">cur-dir  := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">whoami  := <span class="variable">$(<span class="built_in">shell</span> whoami)</span></span><br><span class="line">host-type := <span class="variable">$(<span class="built_in">shell</span> arch)</span></span><br><span class="line">MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure>
<p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir := /foo/bar  <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure>
<p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“?=”，先看示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-变量高级用法"><a href="#5-3-变量高级用法" class="headerlink" title="5.3 变量高级用法"></a><strong>5.3 变量高级用法</strong></h2><p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“$&#123;var:a=b&#125;”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</span><br></pre></td></tr></table></figure>
<p>还是看一个示例吧：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。</p>
<p>另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）</p>
<p>我们还可以使用更多的层次：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">  y = z</span><br><span class="line">  z = u</span><br><span class="line">  a := $($(<span class="variable">$(x)</span>))</span><br></pre></td></tr></table></figure>
<p>这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。</p>
<p>再复杂一点，我们再加上函数：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">  y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">  z = y</span><br><span class="line">  a := $($(<span class="variable">$(z)</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。（喔，好不容易）</span><br></pre></td></tr></table></figure>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line"> b = second</span><br><span class="line">all = $($a_$b)</span><br></pre></td></tr></table></figure>
<p>这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。</p>
<p>再来看看结合第一种技术的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> do_sort</span><br><span class="line">func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">func := strip</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">bar := a d b g q c</span><br><span class="line"></span><br><span class="line">foo := $(<span class="variable">$(func)</span> <span class="variable">$(bar)</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g q c)，调用的就是strip函数。</span><br></pre></td></tr></table></figure>
<p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</p>
<h2 id="5-4-追加变量值"><a href="#5-4-追加变量值" class="headerlink" title="5.4 追加变量值"></a><strong>5.4 追加变量值</strong></h2><p>我们可以使用“+=”操作符给变量追加值，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>
<p>于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p>
<p>使用“+=”操作符，可以模拟为下面的这种例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> another.o</span><br></pre></td></tr></table></figure>
<p>所不同的是，用“+=”更为简洁。</p>
<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>
<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h2 id="5-5-override-指示符"><a href="#5-5-override-指示符" class="headerlink" title="5.5 override 指示符"></a><strong>5.5 override 指示符</strong></h2><p>override作用</p>
<ol>
<li>保护makefile中定义的变量的值;</li>
<li>提供一种在makefile中增加或者修改命令行参数的方式;</li>
</ol>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>当然，你还可以追加：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; += &lt;more text&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h2 id="5-6-多行变量"><a href="#5-6-多行变量" class="headerlink" title="5.6 多行变量"></a><strong>5.6 多行变量</strong></h2><p>还有一种设置变量值的方法是使用define关键字。<strong>使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令</strong>（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h2 id="5-7-环境变量"><a href="#5-7-环境变量" class="headerlink" title="5.7 环境变量"></a><strong>5.7 环境变量</strong></h2><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h2 id="5-8-目标变量"><a href="#5-8-目标变量" class="headerlink" title="5.8 目标变量"></a><strong>5.8 目标变量</strong></h2><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;variable-assignment&gt;</span><br><span class="line"></span><br><span class="line">&lt;target...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;variable-assignment&gt;</code>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">      <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">      <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">      <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">      <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”</span><br></pre></td></tr></table></figure>
<h2 id="5-9-模式变量"><a href="#5-9-模式变量" class="headerlink" title="5.9 模式变量"></a><strong>5.9 模式变量</strong></h2><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;pattern ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line"></span><br><span class="line">&lt;pattern ...&gt; : <span class="keyword">override</span> &lt;variable-assignment&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h1 id="六、使用条件判断"><a href="#六、使用条件判断" class="headerlink" title="六、使用条件判断"></a><strong>六、使用条件判断</strong></h1><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h2 id="6-1-示例"><a href="#6-1-示例" class="headerlink" title="6.1 示例"></a><strong>6.1 示例</strong></h2><p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">      <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>
<p>当我们的变量$(CC)值是“gcc”时，目标foo的规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">      <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br></pre></td></tr></table></figure>
<p>而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">      <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br></pre></td></tr></table></figure>
<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">      <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure>
<h2 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a><strong>6.2 语法</strong></h2><p>条件表达式的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;conditional-directive&gt;</code>表示条件关键字，如“ifeq”。这个关键字有四个。</p>
<p>第一个是我们前面所见过的“ifeq”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">  &lt;text-if-empty&gt;</span><br><span class="line">  <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么 <code>&lt;text-if-empty&gt;</code>就生效。</p>
<p>第二个条件关键字是“ifneq”。语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>
<p>第三个条件关键字是“ifdef”。语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifdef &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>如果变量 <code>&lt;variable-name&gt;</code>的值非空，那到表达式为真。否则，表达式为假。当然，<code>&lt;variable-name&gt;</code>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  示例一：</span></span><br><span class="line"></span><br><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  示例二：</span></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p>
<p>第四个条件关键字是“ifndef”。其语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifndef &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>这个我就不多说了，和“ifdef”是相反的意思。</p>
<p>在 <code>&lt;conditional-directive&gt;</code>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。</p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h1 id="七、使用函数"><a href="#七、使用函数" class="headerlink" title="七、使用函数"></a><strong>七、使用函数</strong></h1><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h2 id="7-1-函数的调用语法"><a href="#7-1-函数的调用语法" class="headerlink" title="7.1 函数的调用语法"></a><strong>7.1 函数的调用语法</strong></h2><p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>&lt;function&gt;</code><strong>就是函数名，make支持的函数不多。</strong><code>&lt;arguments&gt;</code>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,$&#123;x&#125;)”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</span><br></pre></td></tr></table></figure>
<p>还是来看一个示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。</span><br></pre></td></tr></table></figure>
<h2 id="7-2-字符串处理函数"><a href="#7-2-字符串处理函数" class="headerlink" title="7.2 字符串处理函数"></a><strong>7.2 字符串处理函数</strong></h2><h3 id="subst-lt-from-gt-lt-to-gt-lt-text-gt"><a href="#subst-lt-from-gt-lt-to-gt-lt-text-gt" class="headerlink" title="$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)"></a><strong>$(subst <code>&lt;from&gt;</code>,<code>&lt;to&gt;</code>,<code>&lt;text&gt;</code>)</strong></h3><p>  名称：字符串替换函数——subst。<br>  功能：把字串 <code>&lt;text&gt;</code>中的 <code>&lt;from&gt;</code>字符串替换成 <code>&lt;to&gt;</code>。<br>  返回：函数返回被替换过后的字符串。</p>
<p>  示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span>，</span><br></pre></td></tr></table></figure>
<pre><code>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。
</code></pre><h3 id="patsubst-lt-pattern-gt-lt-replacement-gt-lt-text-gt"><a href="#patsubst-lt-pattern-gt-lt-replacement-gt-lt-text-gt" class="headerlink" title="$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)"></a><strong>$(patsubst <code>&lt;pattern&gt;</code>,<code>&lt;replacement&gt;</code>,<code>&lt;text&gt;</code>)</strong></h3><p>  名称：模式字符串替换函数——patsubst。<br>  功能：查找 <code>&lt;text&gt;</code>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 <code>&lt;pattern&gt;</code>，如果匹配的话，则以 <code>&lt;replacement&gt;</code>替换。这里，<code>&lt;pattern&gt;</code>可以包括通配符“%”，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code>中也包含“%”，那么，<code>&lt;replacement&gt;</code>中的这个“%”将是 <code>&lt;pattern&gt;</code>中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符）<br>  返回：函数返回被替换过后的字符串。</p>
<p>  示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>
<p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p>
<p>备注：</p>
<p>这和我们前面“变量章节”说过的相关知识有点相似。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">“$(var:&lt;pattern&gt;=&lt;replacement&gt;)”</span></span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">“<span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,<span class="variable">$(var)</span>)</span>”，</span><br></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">“$(var:&lt;suffix&gt;=&lt;replacement&gt;)”</span></span><br></pre></td></tr></table></figure>
<p>则相当于</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">“<span class="variable">$(<span class="built_in">patsubst</span> %&lt;<span class="built_in">suffix</span>&gt;,%&lt;replacement&gt;,<span class="variable">$(var)</span>)</span>”。</span><br></pre></td></tr></table></figure>
<p> 例如有：objects = foo.o bar.o baz.o，</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,<span class="variable">$(objects)</span>)”是一样的。</span></span><br></pre></td></tr></table></figure>
<h3 id="strip-lt-string-gt"><a href="#strip-lt-string-gt" class="headerlink" title="$(strip &lt;string&gt;)"></a><strong>$(strip <code>&lt;string&gt;</code>)</strong></h3><p>  名称：去空格函数——strip。<br>  功能：去掉 <code>&lt;string&gt;</code>字串中开头和结尾的空字符。<br>  返回：返回被去掉空格的字符串值。<br>  示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br></pre></td></tr></table></figure>
<pre><code>把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。
</code></pre><h3 id="findstring-lt-find-gt-lt-in-gt"><a href="#findstring-lt-find-gt-lt-in-gt" class="headerlink" title="$(findstring &lt;find&gt;,&lt;in&gt;)"></a><strong>$(findstring <code>&lt;find&gt;</code>,<code>&lt;in&gt;</code>)</strong></h3><p>  名称：查找字符串函数——findstring。<br>  功能：在字串 <code>&lt;in&gt;</code>中查找 <code>&lt;find&gt;</code>字串。<br>  返回：如果找到，那么返回 <code>&lt;find&gt;</code>，否则返回空字符串。<br>  示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure>
<pre><code>第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）
</code></pre><h3 id="filter-lt-text-gt"><a href="#filter-lt-text-gt" class="headerlink" title="$(filter ,&lt;text&gt;)"></a><strong>$(filter <pattern...>,<code>&lt;text&gt;</code>)</pattern...></strong></h3><p>  名称：过滤函数——filter。<br>  功能：以 <code>&lt;pattern&gt;</code>模式过滤 <code>&lt;text&gt;</code>字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code>的单词。可以有多个模式。<br>  返回：返回符合模式 <code>&lt;pattern&gt;</code>的字串。<br>  示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="section">foo: <span class="variable">$(sources)</span></span></span><br><span class="line">        cc <span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span> -o foo</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span></span><br></pre></td></tr></table></figure>
<p>返回的值是“foo.c bar.c baz.s”。</p>
<h3 id="filter-out-lt-text-gt"><a href="#filter-out-lt-text-gt" class="headerlink" title="$(filter-out ,&lt;text&gt;)"></a><strong>$(filter-out <pattern...>,<code>&lt;text&gt;</code>)</pattern...></strong></h3><p>  名称：反过滤函数——filter-out。<br>  功能：以 <code>&lt;pattern&gt;</code>模式过滤 <code>&lt;text&gt;</code>字符串中的单词，去除符合模式 <code>&lt;pattern&gt;</code>的单词。可以有多个模式。<br>  返回：返回不符合模式 <code>&lt;pattern&gt;</code>的字串。<br>  示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects=main1.o foo.o main2.o bar.o</span><br><span class="line">mains=main1.o main2.o</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(mains)</span>,<span class="variable">$(objects)</span>)</span> </span><br></pre></td></tr></table></figure>
<p>返回值是“foo.o bar.o”。</p>
<h3 id="sort-lt-list-gt"><a href="#sort-lt-list-gt" class="headerlink" title="$(sort &lt;list&gt;)"></a><strong>$(sort <code>&lt;list&gt;</code>)</strong></h3><p>  名称：排序函数——sort。<br>  功能：给字符串 <code>&lt;list&gt;</code>中的单词排序（升序）。<br>  返回：返回排序后的字符串。<br>  示例：$(sort foo bar lose)返回“bar foo lose” 。<br>  备注：sort函数会去掉 <code>&lt;list&gt;</code>中相同的单词。</p>
<h3 id="word-lt-n-gt-lt-text-gt"><a href="#word-lt-n-gt-lt-text-gt" class="headerlink" title="$(word &lt;n&gt;,&lt;text&gt;)"></a><strong>$(word <code>&lt;n&gt;</code>,<code>&lt;text&gt;</code>)</strong></h3><p>名称：取单词函数——word。<br>功能：取字符串 <code>&lt;text&gt;</code>中第 <code>&lt;n&gt;</code>个单词。（从一开始）<br>返回：返回字符串 <code>&lt;text&gt;</code>中第 <code>&lt;n&gt;</code>个单词。如果 <code>&lt;n&gt;</code>比 <code>&lt;text&gt;</code>中的单词数要大，那么返回空字符串。<br>示例：$(word 2, foo bar baz)返回值是“bar”。</p>
<h3 id="words-lt-text-gt"><a href="#words-lt-text-gt" class="headerlink" title="$(words &lt;text&gt;)"></a><strong>$(words <code>&lt;text&gt;</code>)</strong></h3><p>名称：单词个数统计函数——words。<br>功能：统计 <code>&lt;text&gt;</code>中字符串中的单词个数。<br>返回：返回 <code>&lt;text&gt;</code>中的单词数。<br>示例：$(words, foo bar baz)返回值是“3”。<br>备注：如果我们要取 <code>&lt;text&gt;</code>中最后的一个单词，我们可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(word $(words &lt;text&gt;),&lt;text&gt;)</span><br></pre></td></tr></table></figure>
<h3 id="firstword-lt-text-gt"><a href="#firstword-lt-text-gt" class="headerlink" title="$(firstword &lt;text&gt;)"></a><strong>$(firstword <code>&lt;text&gt;</code>)</strong></h3><p>名称：首单词函数——firstword。<br>功能：取字符串 <code>&lt;text&gt;</code>中的第一个单词。<br>返回：返回字符串 <code>&lt;text&gt;</code>的第一个单词。<br>示例：$(firstword foo bar)返回值是“foo”。<br>备注：这个函数可以用word函数来实现：$(word 1,<code>&lt;text&gt;</code>)。</p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</span><br></pre></td></tr></table></figure>
<p>如果我们的 <code>“$(VPATH)”</code> 值是“src:../headers”，那么 <code>“$(patsubst %,-I%,$(subst :, ,$(VPATH)))”</code>  将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。</p>
<h2 id="7-3-文件名操作函数"><a href="#7-3-文件名操作函数" class="headerlink" title="7.3 文件名操作函数"></a>7.3 文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<h3 id="dir"><a href="#dir" class="headerlink" title="$(dir )"></a><strong>$(dir <names...>)</names...></strong></h3><p>  名称：取目录函数——dir。<br>  功能：从文件名序列 <code>&lt;names&gt;</code>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。<br>  返回：返回文件名序列 <code>&lt;names&gt;</code>的目录部分。<br>  示例： $(dir src/foo.c hacks)返回值是“src/ ./”。</p>
<h3 id="notdir"><a href="#notdir" class="headerlink" title="$(notdir )"></a><strong>$(notdir <names...>)</names...></strong></h3><p>  名称：取文件函数——notdir。<br>  功能：从文件名序列 <code>&lt;names&gt;</code>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。<br>  返回：返回文件名序列 <code>&lt;names&gt;</code>的非目录部分。<br>  示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。</p>
<h3 id="suffix"><a href="#suffix" class="headerlink" title="$(suffix )"></a><strong>$(suffix <names...>)</names...></strong></h3><p>  名称：取后缀函数——suffix。<br>  功能：从文件名序列 <code>&lt;names&gt;</code>中取出各个文件名的后缀。<br>  返回：返回文件名序列 <code>&lt;names&gt;</code>的后缀序列，如果文件没有后缀，则返回空字串。<br>  示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p>
<h3 id="basename"><a href="#basename" class="headerlink" title="$(basename )"></a><strong>$(basename <names...>)</names...></strong></h3><p>  名称：取前缀函数——basename。<br>  功能：从文件名序列 <code>&lt;names&gt;</code>中取出各个文件名的前缀部分。<br>  返回：返回文件名序列 <code>&lt;names&gt;</code>的前缀序列，如果文件没有前缀，则返回空字串。<br>  示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。</p>
<h3 id="addsuffix-lt-suffix-gt"><a href="#addsuffix-lt-suffix-gt" class="headerlink" title="$(addsuffix &lt;suffix&gt;,)"></a><strong>$(addsuffix <code>&lt;suffix&gt;</code>,<names...>)</names...></strong></h3><p>  名称：加后缀函数——addsuffix。<br>  功能：把后缀 <code>&lt;suffix&gt;</code>加到 <code>&lt;names&gt;</code>中的每个单词后面。<br>  返回：返回加过后缀的文件名序列。<br>  示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。</p>
<h3 id="addprefix-lt-prefix-gt"><a href="#addprefix-lt-prefix-gt" class="headerlink" title="$(addprefix &lt;prefix&gt;,)"></a><strong>$(addprefix <code>&lt;prefix&gt;</code>,<names...>)</names...></strong></h3><p>  名称：加前缀函数——addprefix。<br>  功能：把前缀 <code>&lt;prefix&gt;</code>加到 <code>&lt;names&gt;</code>中的每个单词后面。<br>  返回：返回加过前缀的文件名序列。<br>  示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。</p>
<h3 id="join-lt-list1-gt-lt-list2-gt"><a href="#join-lt-list1-gt-lt-list2-gt" class="headerlink" title="$(join &lt;list1&gt;,&lt;list2&gt;)"></a><strong>$(join <code>&lt;list1&gt;</code>,<code>&lt;list2&gt;</code>)</strong></h3><p>  名称：连接函数——join。<br>  功能：把 <code>&lt;list2&gt;</code>中的单词对应地加到 <code>&lt;list1&gt;</code>的单词后面。如果 <code>&lt;list1&gt;</code>的单词个数要比 <code>&lt;list2&gt;</code>的多，那么，<code>&lt;list1&gt;</code>中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code>的单词个数要比 <code>&lt;list1&gt;</code>多，那么，<code>&lt;list2&gt;</code>多出来的单词将被复制到 <code>&lt;list2&gt;</code>中。<br>  返回：返回连接过后的字符串。<br>  示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</p>
<h2 id="7-4-foreach-函数"><a href="#7-4-foreach-函数" class="headerlink" title="7.4 foreach 函数"></a>7.4 foreach 函数</h2><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的意思是，把参数 <code>&lt;list&gt;</code>中的单词逐一取出放到参数 <code>&lt;var&gt;</code>所指定的变量中，然后再执行 <code>&lt;text&gt;</code>所包含的表达式。每一次 <code>&lt;text&gt;</code>会返回一个字符串，循环过程中，<code>&lt;text&gt;</code>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>所以，<code>&lt;var&gt;</code>最好是一个变量名，<code>&lt;list&gt;</code>可以是一个表达式，而 <code>&lt;text&gt;</code>中一般会使用 <code>&lt;var&gt;</code>这个参数来依次枚举 <code>&lt;list&gt;</code>中的单词。举个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line"></span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。</p>
<p>注意，foreach中的 <code>&lt;var&gt;</code>参数是一个临时的局部变量，foreach函数执行完后，参数 <code>&lt;var&gt;</code>的变量将不在作用，其作用域只在foreach函数当中。</p>
<h2 id="7-5-if-函数"><a href="#7-5-if-函数" class="headerlink" title="7.5 if 函数"></a>7.5 if 函数</h2><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<code>&lt;condition&gt;</code>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<code>&lt;then-part&gt;</code>会被计算，否则 <code>&lt;else-part&gt;</code>会被计算。</p>
<p>而if函数的返回值是，如果 <code>&lt;condition&gt;</code>为真（非空字符串），那个 <code>&lt;then-part&gt;</code>会是整个函数的返回值，如果 <code>&lt;condition&gt;</code>为假（空字符串），那么 <code>&lt;else-part&gt;</code>会是整个函数的返回值，此时如果 <code>&lt;else-part&gt;</code>没有被定义，那么，整个函数返回空字串。</p>
<p>所以，<code>&lt;then-part&gt;</code>和 <code>&lt;else-part&gt;</code>只会有一个被计算。</p>
<h2 id="7-6-call函数"><a href="#7-6-call函数" class="headerlink" title="7.6 call函数"></a>7.6 call函数</h2><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span></span><br></pre></td></tr></table></figure>
<p>当make执行这个函数时，<code>&lt;expression&gt;</code>参数中的变量，如$(1)，$(2)，$(3)等，会被参数 <code>&lt;parm1&gt;</code>，<code>&lt;parm2&gt;</code>，<code>&lt;parm3&gt;</code>依次取代。而 <code>&lt;expression&gt;</code>的返回值就是call函数的返回值。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse = $(1) $(2)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure>
<p>那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse = $(2) $(1)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure>
<p>此时的foo的值就是“b a”。</p>
<h2 id="7-7-origin函数"><a href="#7-7-origin函数" class="headerlink" title="7.7 origin函数"></a>7.7 origin函数</h2><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>&lt;variable&gt;</code>是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p>
<ul>
<li><p>“undefined”</p>
<p>如果 <code>&lt;variable&gt;</code>从来没有定义过，origin函数返回这个值“undefined”。</p>
</li>
<li><p>“default”</p>
<p>如果 <code>&lt;variable&gt;</code>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p>
</li>
<li><p>“environment”</p>
<p>如果 <code>&lt;variable&gt;</code>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</p>
</li>
<li><p>“file”</p>
<p>如果 <code>&lt;variable&gt;</code>这个变量被定义在Makefile中。</p>
</li>
<li><p>“command line”</p>
<p>如果 <code>&lt;variable&gt;</code>这个变量是被命令行定义的。</p>
</li>
<li><p>“override”</p>
<p>如果 <code>&lt;variable&gt;</code>是被override指示符重新定义的。</p>
</li>
<li><p>“automatic”</p>
<p>如果 <code>&lt;variable&gt;</code>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
</li>
</ul>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> bletch</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;$(origin bletch)&quot;</span> <span class="string">&quot;environment&quot;</span></span><br><span class="line"></span><br><span class="line">bletch = barf, gag, etc.</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h2 id="7-8-shell函数"><a href="#7-8-shell函数" class="headerlink" title="7.8 shell函数"></a>7.8 shell函数</h2><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h2 id="7-9-控制make的函数"><a href="#7-9-控制make的函数" class="headerlink" title="7.9 控制make的函数"></a>7.9 控制make的函数</h2><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<p><strong>$(error <text ...>)</text></strong></p>
<p>  产生一个致命的错误，<text ...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</text></p>
<p>  示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  示例二：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: err</span></span><br><span class="line"></span><br><span class="line"><span class="section">err: ; <span class="variable">$(ERR)</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>
<p><strong>$(warning <text ...>)</text></strong></p>
<p>   这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h1 id="八、make-的运行"><a href="#八、make-的运行" class="headerlink" title="八、make 的运行"></a>八、make 的运行</h1><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h2 id="8-1-make的退出码"><a href="#8-1-make的退出码" class="headerlink" title="8.1 make的退出码"></a><strong>8.1 make的退出码</strong></h2><p>make命令执行后有三个退出码：</p>
<p>  0 —— 表示成功执行。<br>  1 —— 如果make运行时出现任何错误，其返回1。<br>  2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h2 id="8-2-指定Makefile"><a href="#8-2-指定Makefile" class="headerlink" title="8.2 指定Makefile"></a><strong>8.2 指定Makefile</strong></h2><p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“—file”参数（“—makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure>
<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h2 id="8-3-指定目标"><a href="#8-3-指定目标" class="headerlink" title="8.3 指定目标"></a><strong>8.3 指定目标</strong></h2><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">ifneq</span> ( <span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line">  <span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line">  <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: prog1 prog2 prog3 prog4</span></span><br></pre></td></tr></table></figure>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<ul>
<li>“all”<br>这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>“clean”<br>这个伪目标功能是删除所有被make创建的文件。</li>
<li>“install”<br>这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>“print”<br>这个伪目标的功能是例出改变过的源文件。</li>
<li>“tar”<br>这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>“dist”<br>这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>“TAGS”<br>这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>“check”和“test”<br>这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h2 id="8-4-检查规则"><a href="#8-4-检查规则" class="headerlink" title="8.4 检查规则"></a><strong>8.4 检查规则</strong></h2><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-n”</span><br><span class="line">“--just-print”</span><br><span class="line">“--dry-run”</span><br><span class="line">“--recon”</span><br></pre></td></tr></table></figure>
<p>  不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-t”</span><br><span class="line">“--touch”</span><br></pre></td></tr></table></figure>
<p>  这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-q”</span><br><span class="line">“--question”</span><br></pre></td></tr></table></figure>
<p>  这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">“-W &lt;file&gt;”</span><br><span class="line">“--what-if=&lt;file&gt;”</span><br><span class="line">“--assume-new=&lt;file&gt;”</span><br><span class="line">“--new-file=&lt;file&gt;”</span><br></pre></td></tr></table></figure>
<p>  这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h2 id="8-5-make的参数"><a href="#8-5-make的参数" class="headerlink" title="8.5 make的参数"></a><strong>8.5 make的参数</strong></h2><p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-b”</span><br><span class="line">“-m”</span><br></pre></td></tr></table></figure>
<p>这两个参数的作用是忽略和其它版本make的兼容性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-B”</span><br><span class="line">“--always-make”</span><br></pre></td></tr></table></figure>
<p>认为所有的目标都需要更新（重编译）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-C &lt;dir&gt;”</span><br><span class="line">“--directory=&lt;dir&gt;”</span><br></pre></td></tr></table></figure>
<p>指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“—debug[=&lt;options&gt;]”</span><br></pre></td></tr></table></figure>
<p>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是 <code>&lt;options&gt;</code>的取值：</p>
<ul>
<li>a —— 也就是all，输出所有的调试信息。（会非常的多）</li>
<li>b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。</li>
<li>v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。</li>
<li>i —— 也就是implicit，输出所以的隐含规则。</li>
<li>j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</li>
<li>m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-d”</span><br></pre></td></tr></table></figure>
<p>相当于“—debug=a”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-e”</span><br><span class="line">“--environment-overrides”</span><br></pre></td></tr></table></figure>
<p>指明环境变量的值覆盖makefile中定义的变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-f=&lt;file&gt;”</span><br><span class="line">“--file=&lt;file&gt;”</span><br><span class="line">“--makefile=&lt;file&gt;”</span><br></pre></td></tr></table></figure>
<p>指定需要执行的makefile。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-h”</span><br><span class="line">“--help”</span><br></pre></td></tr></table></figure>
<p>显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-i”</span><br><span class="line">“--ignore-errors”</span><br></pre></td></tr></table></figure>
<p>在执行时忽略所有的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-I &lt;dir&gt;”</span><br><span class="line">“--include-dir=&lt;dir&gt;”</span><br></pre></td></tr></table></figure>
<p>指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-j [&lt;jobsnum&gt;]”</span><br><span class="line">“--jobs[=&lt;jobsnum&gt;]”</span><br></pre></td></tr></table></figure>
<p>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-k”</span><br><span class="line">“--keep-going”</span><br></pre></td></tr></table></figure>
<p>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-l &lt;load&gt;”</span><br><span class="line">“--load-average[=&lt;load]”</span><br><span class="line">“—max-load[=&lt;load&gt;]”</span><br></pre></td></tr></table></figure>
<p>指定make运行命令的负载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-n”</span><br><span class="line">“--just-print”</span><br><span class="line">“--dry-run”</span><br><span class="line">“--recon”</span><br></pre></td></tr></table></figure>
<p>仅输出执行过程中的命令序列，但并不执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-o &lt;file&gt;”</span><br><span class="line">“--old-file=&lt;file&gt;”</span><br><span class="line">“--assume-old=&lt;file&gt;”</span><br></pre></td></tr></table></figure>
<p>不重新生成的指定的 <code>&lt;file&gt;</code>，即使这个目标的依赖文件新于它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-p”</span><br><span class="line">“--print-data-base”</span><br></pre></td></tr></table></figure>
<p>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-q”</span><br><span class="line">“--question”</span><br></pre></td></tr></table></figure>
<p>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-r”</span><br><span class="line">“--no-builtin-rules”</span><br></pre></td></tr></table></figure>
<p>禁止make使用任何隐含规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-R”</span><br><span class="line">“--no-builtin-variabes”</span><br></pre></td></tr></table></figure>
<p>禁止make使用任何作用于变量上的隐含规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-s”</span><br><span class="line">“--silent”</span><br><span class="line">“--quiet”</span><br></pre></td></tr></table></figure>
<p>在命令运行时不输出命令的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-S”</span><br><span class="line">“--no-keep-going”</span><br><span class="line">“--stop”</span><br></pre></td></tr></table></figure>
<p>取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-t”</span><br><span class="line">“--touch”</span><br></pre></td></tr></table></figure>
<p>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-v”</span><br><span class="line">“--version”</span><br></pre></td></tr></table></figure>
<p>输出make程序的版本、版权等关于make的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-w”</span><br><span class="line">“--print-directory”</span><br></pre></td></tr></table></figure>
<p>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“--no-print-directory”</span><br></pre></td></tr></table></figure>
<p>禁止“-w”选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“-W &lt;file&gt;”</span><br><span class="line">“--what-if=&lt;file&gt;”</span><br><span class="line">“--new-file=&lt;file&gt;”</span><br><span class="line">“--assume-file=&lt;file&gt;”</span><br></pre></td></tr></table></figure>
<p>假定目标 <code>&lt;file&gt;</code>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得 <code>&lt;file&gt;</code>的修改时间为当前时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“--warn-undefined-variables”</span><br></pre></td></tr></table></figure>
<p>只要make发现有未定义的变量，那么就输出警告信息。</p>
<h1 id="九、隐含规则"><a href="#九、隐含规则" class="headerlink" title="九、隐含规则"></a><strong>九、隐含规则</strong></h1><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。<br>我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h2 id="9-1-使用隐含规则"><a href="#9-1-使用隐含规则" class="headerlink" title="9.1 使用隐含规则"></a><strong>9.1 使用隐含规则</strong></h2><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">      cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">      cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.p</span><br></pre></td></tr></table></figure>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<h2 id="9-2-隐含规则一览"><a href="#9-2-隐含规则一览" class="headerlink" title="9.2 隐含规则一览"></a><strong>9.2 隐含规则一览</strong></h2><p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“—no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：<strong>.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el</strong>。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p><strong>1、编译C程序的隐含规则。</strong><br>“<code>&lt;n&gt;</code>.o”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”</p>
<p><strong>2、编译C++程序的隐含规则。</strong><br>“<code>&lt;n&gt;</code>.o”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.cc”或是“<code>&lt;n&gt;</code>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p>
<p><strong>3、编译Pascal程序的隐含规则。</strong></p>
<p>“<code>&lt;n&gt;</code>.o”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。</p>
<p><strong>4、编译Fortran/Ratfor程序的隐含规则。</strong></p>
<p>“<code>&lt;n&gt;</code>.o”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.r”或“<code>&lt;n&gt;</code>.F”或“<code>&lt;n&gt;</code>.f”，并且其生成命令是:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">“.f” “<span class="variable">$(FC)</span> –c <span class="variable">$(FFLAGS)</span>”</span><br><span class="line">“.F” “<span class="variable">$(FC)</span> –c <span class="variable">$(FFLAGS)</span> <span class="variable">$(CPPFLAGS)</span>”</span><br><span class="line">“.f” “<span class="variable">$(FC)</span> –c <span class="variable">$(FFLAGS)</span> <span class="variable">$(RFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p><strong>5、预处理Fortran/Ratfor程序的隐含规则。</strong><br>“<code>&lt;n&gt;</code>.f”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.r”或“<code>&lt;n&gt;</code>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">“.F” “<span class="variable">$(FC)</span> –F <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(FFLAGS)</span>”</span><br><span class="line">“.r” “<span class="variable">$(FC)</span> –F <span class="variable">$(FFLAGS)</span> <span class="variable">$(RFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p><strong>6、编译Modula-2程序的隐含规则。</strong></p>
<p>“<code>&lt;n&gt;</code>.sym”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“<n.o>” 的目标的依赖目标会自动推导为“<n>.mod”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。</n></n.o></p>
<p><strong>7、汇编和汇编预处理的隐含规则。</strong></p>
<p>“<code>&lt;n&gt;</code>.o” 的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<code>&lt;n&gt;</code>.s” 的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.S”，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。</p>
<p><strong>8、链接Object文件的隐含规则。</strong><br>“<code>&lt;n&gt;</code>”目标依赖于“<code>&lt;n&gt;</code>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <code>&lt;n&gt;</code>.o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x : y.o z.o</span><br></pre></td></tr></table></figure>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>**9、Yacc C程序时的隐含规则。</p>
<p>**“<code>&lt;n&gt;</code>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
<p><strong>10、Lex C程序时的隐含规则。</strong><br>“<code>&lt;n&gt;</code>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）</p>
<p><strong>11、Lex Ratfor程序时的隐含规则。</strong><br>“<code>&lt;n&gt;</code>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。</p>
<p><strong>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</strong><br>“<code>&lt;n&gt;</code>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<code>&lt;n&gt;</code>.y”和“<code>&lt;n&gt;</code>.l”也是同样的规则。</p>
<h2 id="9-3-隐含规则使用的变量"><a href="#9-3-隐含规则使用的变量" class="headerlink" title="9.3 隐含规则使用的变量"></a><strong>9.3 隐含规则使用的变量</strong></h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“—no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<p><strong>1、关于命令的变量。</strong></p>
<ul>
<li>AR<br>函数库打包程序。默认命令是“ar”。</li>
<li>AS<br>汇编语言编译程序。默认命令是“as”。</li>
<li>CC<br>C语言编译程序。默认命令是“cc”。</li>
<li>CXX<br>C++语言编译程序。默认命令是“g++”。</li>
<li>CO<br>从 RCS文件中扩展文件程序。默认命令是“co”。</li>
<li>CPP<br>C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。</li>
<li>FC<br>Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。</li>
<li>GET<br>从SCCS文件中扩展文件的程序。默认命令是“get”。</li>
<li>LEX<br>Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。</li>
<li>PC<br>Pascal语言编译程序。默认命令是“pc”。</li>
<li>YACC<br>Yacc文法分析器（针对于C程序）。默认命令是“yacc”。</li>
<li>YACCR<br>Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。</li>
<li>MAKEINFO<br>转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。</li>
<li>TEX<br>从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。</li>
<li>TEXI2DVI<br>从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。</li>
<li>WEAVE<br>转换Web到TeX的程序。默认命令是“weave”。</li>
<li>CWEAVE<br>转换C Web 到 TeX的程序。默认命令是“cweave”。</li>
<li>TANGLE<br>转换Web到Pascal语言的程序。默认命令是“tangle”。</li>
<li>CTANGLE<br>转换C Web 到 C。默认命令是“ctangle”。</li>
<li>RM<br>删除文件命令。默认命令是“rm –f”。</li>
</ul>
<p><strong>2、关于命令参数的变量</strong></p>
<p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<ul>
<li>ARFLAGS<br>函数库打包程序AR命令的参数。默认值是“rv”。</li>
<li>ASFLAGS<br>汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。</li>
<li>CFLAGS<br>C语言编译器参数。</li>
<li>CXXFLAGS<br>C++语言编译器参数。</li>
<li>COFLAGS<br>RCS命令参数。</li>
<li>CPPFLAGS<br>C预处理器参数。（ C 和 Fortran 编译器也会用到）。</li>
<li>FFLAGS<br>Fortran语言编译器参数。</li>
<li>GFLAGS<br>SCCS “get”程序参数。</li>
<li>LDFLAGS<br>链接器参数。（如：“ld”）</li>
<li>LFLAGS<br>Lex文法分析器参数。</li>
<li>PFLAGS<br>Pascal语言编译器参数。</li>
<li>RFLAGS<br>Ratfor 程序的Fortran 编译器参数。</li>
<li>YFLAGS<br>Yacc文法分析器参数。</li>
</ul>
<h2 id="9-4-隐含规则链"><a href="#9-4-隐含规则链" class="headerlink" title="9.4 隐含规则链"></a><strong>9.4 隐含规则链</strong></h2><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<h2 id="9-5-定义模式规则"><a href="#9-5-定义模式规则" class="headerlink" title="9.5 定义模式规则"></a>9.5 定义模式规则</h2><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 <code>%</code>字符。<code>%</code>的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 <code>%</code>，只是依赖目标中的 <code>%</code>的取值，取决于其目标。</p>
<p>有一点需要注意的是，<code>%</code>的展开发生在变量和函数的展开之后，变量和函数的展开发生在 <code>make</code>载入 <code>Makefile</code>时，而模式规则中的 <code>%</code>则发生在运行时。</p>
<h3 id="9-5-1-模式规则介绍"><a href="#9-5-1-模式规则介绍" class="headerlink" title="9.5.1 模式规则介绍"></a>9.5.1 模式规则介绍</h3><p>模式规则中，至少在规则的目标定义中要包含 <code>%</code>，否则，就是一般的规则。目标中的 <code>%</code>定义表示对文件名的匹配，<code>%</code>表示长度任意的非空字符串。例如：<code>%.c</code>表示以 <code>.c</code>结尾的文件名（文件名的长度至少为3），而 <code>s.%.c</code>则表示以 <code>s.</code>开头，<code>.c</code>结尾的文件名（文件名的长度至少为5）。</p>
<p>如果 <code>%</code>定义在目标中，那么，目标中的 <code>%</code>的值决定了依赖目标中的 <code>%</code>的值，也就是说，目标中的模式的 <code>%</code>决定了依赖目标中 <code>%</code>的样子。例如有一个模式规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c ; &lt;command ......&gt;</span><br></pre></td></tr></table></figure>
<p>其含义是，指出了怎么从所有的 <code>.c</code>文件生成相应的 <code>.o</code>文件的规则。如果要生成的目标是 <code>a.o b.o</code>，那么 <code>%c</code>就是 <code>a.c b.c</code>。</p>
<p>一旦依赖目标中的 <code>%</code>模式被确定，那么，<code>make</code>会被要求去匹配当前目录下所有的文件名，一旦找到，<code>make</code>就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，<code>make</code>就会产生所有的模式目标，此时，<code>make</code>关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h3 id="9-5-2-模式规则示例"><a href="#9-5-2-模式规则示例" class="headerlink" title="9.5.2 模式规则示例"></a>9.5.2 模式规则示例</h3><p>下面这个例子表示了,把所有的 <code>c</code>文件都编译成 <code>.o</code>文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>$@</code>表示所有的目标的挨个值，<code>$&lt;</code>表示了所有依赖目标的挨个值。这些奇怪的变量我们叫”自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.tab.c %.tab.h: %.y</span><br><span class="line">        bison -d <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这条规则告诉 <code>make</code>把所有的 <code>.y</code>]文件都以 <code>bison -d &lt;n&gt;.y</code>执行，然后生成 <code>&lt;n&gt;.tab.c</code>和 <code>&lt;n&gt;.tab.h</code>文件。（其中，<code>&lt;n&gt;</code>表示一个任意字符串）。如果我们的执行程序 <code>foo</code>依赖于文件 <code>parse.tab.o</code>和 <code>scan.o</code>，并且文件 <code>scan.o</code>依赖于文件 <code>parse.tab.h</code>，如果 <code>parse.y</code>文件被更新了，那么根据上述的规则，<code>bison -d parse.y</code>就会被执行一次，于是，<code>parse.tab.o</code>和 <code>scan.o</code>的依赖文件就齐了。（假设，<code>parse.tab.o</code>由 <code>parse.tab.c</code>生成，和 <code>scan.o</code>由 <code>scan.c</code>生成，而 <code>foo</code>由 <code>parse.tab.o</code>和 <code>scan.o</code>链接生成，而且 <code>foo</code>和其 <code>.o</code>文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<h3 id="9-5-3-自动化变量"><a href="#9-5-3-自动化变量" class="headerlink" title="9.5.3 自动化变量"></a>9.5.3 自动化变量</h3><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<ul>
<li><code>$@</code><br>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，<code>$@</code>就是匹配于目标中模式定义的集合。</li>
<li><code>$%</code><br>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code>，那么，<code>$%</code>就是 <code>bar.o</code>，<code>$@</code>就是 <code>foo.a</code>。如果目标不是函数库文件（<code>Unix</code>下是 <code>.a</code>，<code>Windows</code>下是 <code>.lib</code>），那么，其值为空</li>
<li><code>$&lt;</code><br>依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code>）定义的，那么 <code>$&lt;</code>将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li>
<li><code>$?</code><br>所有比目标新的依赖目标的集合。以空格分隔。</li>
<li><code>$^</code><br>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</li>
<li><code>$+</code><br>这个变量很像 <code>$^</code>，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li><code>$*</code><br>这个变量表示目标模式中 <code>%</code>及其之前的部分。如果目标是 <code>dir/a.foo.b</code>，并且目标的模式是 <code>a.%.b</code>，那么，<code>$*</code>的值就是 <code>dir/a.foo</code>。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 <code>$*</code>也就不能被推导出，但是，如果目标文件的后缀是 <code>make</code>所识别的，那么 <code>$*</code>就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code>，因为 <code>.c</code>是make所能识别的后缀名，所以，<code>$*</code>的值就是 <code>foo</code>。这个特性是 <code>GNU make</code>的，很有可能不兼容于其它版本的 <code>make</code>，所以，你应该尽量避免使用 <code>$*</code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是 <code>make</code>所不能识别的，那么 <code>$*&quot;</code>就是空值。</li>
</ul>
<p>当你希望只对更新过的依赖文件进行操作时，<code>$?&quot;</code>在显式规则中很有用，例如，假设有一个函数库文件叫 <code>lib</code>，其由其它几个 <code>object</code>文件更新。那么把 <code>object</code>文件打包的比较有效率的 <code>Makefile</code>规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">lib : foo.o bar.o lose.o win.o</span><br><span class="line">        ar r lib <span class="variable">$?</span></span><br></pre></td></tr></table></figure>
<p>在上述所列出来的自动量变量中。四个变量（<code>$@</code>、<code>$&lt;</code>、<code>$%</code>、<code>$*</code>）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 <code>D</code>或 <code>F</code>字样。这是 <code>GNU make</code>中老版本的特性，在新版本中，我们使用函数 <code>dir</code>或 <code>notdir</code>就可以做到了。<code>D</code>的含义就是 <code>Directory</code>，就是目录，<code>F</code>的含义就是 <code>File</code>，就是文件。</p>
<p>下面是对于上面的七个变量分别加上 <code>D</code>或是 <code>F</code>的含义：</p>
<ul>
<li><code>$(@D)</code><br>表示 <code>$@</code>的目录部分（不以斜杠作为结尾），如果 <code>$@</code>值是 <code>dir/foo.o</code>，那么 <code>$(@D)</code>就是 <code>dir</code>，而如果 <code>$@</code>中没有包含斜杠的话，其值就是 <code>.</code>（当前目录）。</li>
<li><code>$(@F)</code><br>表示 <code>$@</code>的文件部分，如果 <code>$@</code>值是 <code>dir/foo.o</code>，那么 <code>$(@F)</code>就是 <code>foo.o</code>，<code>$(@F)</code>相当于函数 <code>$(notdir $@)</code>。</li>
<li><code>$(*D)</code></li>
<li><code>$(*F)</code><br>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code>返回 <code>dir</code>，而 <code>$(*F)</code>返回 <code>foo</code></li>
<li><code>$(%D)</code></li>
<li><code>$(%F)</code><br>分别表示了函数包文件成员的目录部分和文件部分。这对于形同 <code>archive(member)</code>形式的目标中的 <code>member</code>中包含了不同的目录很有用。</li>
<li><code>$(&lt;D)</code></li>
<li><code>$(&lt;F)</code><br>分别表示依赖文件的目录部分和文件部分。</li>
<li><code>$(^D)</code></li>
<li><code>$(^F)</code><br>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</li>
<li><code>$(+D)</code></li>
<li><code>$(+F)</code><br>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</li>
<li><code>$(?D)</code></li>
<li><code>$(?F)</code><br>分别表示被更新的依赖文件的目录部分和文件部分。</li>
</ul>
<p>最后想提醒一下的是，对于 <code>$&lt;</code>，为了避免产生不必要的麻烦，我们最好给后 面 的 那 个 特 定 字 符 都 加 上 圆 括 号 ， 比 如 ， ‘ 后面的那个特定字符都加上圆括号，比如，<code>后面的那个特定字符都加上圆括号，比如，‘(&lt;)</code>就要比 <code>$&lt;</code>要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>
<h3 id="9-5-4-模式的匹配"><a href="#9-5-4-模式的匹配" class="headerlink" title="9.5.4 模式的匹配"></a>9.5.4 模式的匹配</h3><p>一般来说，一个目标的模式有一个有前缀或是后缀的 <code>%</code>，或是没有前后缀，直接就是一个 <code>%</code>。因为 <code>%</code>代表一个或多个字符，所以在定义好了的模式中，我们把 <code>%</code>所匹配的内容叫做 <code>茎</code>，例如 <code>%.c</code>所匹配的文件 <code>test.c</code>中 <code>test</code>就是 <code>茎</code>。因为在目标和依赖目标中同时有 <code>%</code>时，依赖目标的 <code>茎</code>会传给目标，当做目标中的 <code>茎</code>。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行 <code>茎</code>的传递时，我们需要知道这个步骤。例如有一个模式 <code>e%t</code>，文件 <code>src/eat</code>匹配于该模式，于是 <code>src/a</code>就是其 <code>茎</code>，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 <code>c%r</code>，那么，目标就是 <code>src/car</code>。（<code>茎</code>被传递）</p>
<h3 id="9-5-5-重载内建隐含规则"><a href="#9-5-5-重载内建隐含规则" class="headerlink" title="9.5.5 重载内建隐含规则"></a>9.5.5 重载内建隐含规则</h3><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -D<span class="variable">$(date)</span></span><br></pre></td></tr></table></figure>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.s</span><br></pre></td></tr></table></figure>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h2 id="9-6-老式风格的”后缀规则”"><a href="#9-6-老式风格的”后缀规则”" class="headerlink" title="9.6 老式风格的”后缀规则”"></a>9.6 老式风格的”后缀规则”</h2><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的 <code>Makefile</code>兼容，<code>GNU make</code>同样兼容于这些东西。后缀规则有两种方式：“双后缀”和”单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 <code>.c.o</code>相当于 <code>%o : %c</code>。单后缀规则只定义一个后缀，也就是源文件的后缀。如 <code>.c</code>相当于 <code>% : %.c</code>。</p>
<p>后缀规则中所定义的后缀应该是 <code>make</code>所认识的，如果一个后缀是 <code>make</code>所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被 <code>make</code>所认识，那就是双后缀规则。例如：<code>.c</code>和 <code>.o</code>都是 <code>make</code>所知道。因而，如果你定义了一个规则是 <code>.c.o</code>那么其就是双后缀规则，意义就是 <code>.c</code>是源文件的后缀，<code>.o</code>是目标文件的后缀。如下示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子，就是说，文件 <code>.c.o</code>依赖于文件 <code>foo.h</code>，而不是我们想要的这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让 <code>make</code>知道一些特定的后缀，我们可以使用伪目标 <code>.SUFFIXES</code>来定义或是删除，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.SUFFIXES: .hack .win</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把后缀 <code>.hack</code>和 <code>.win</code>加入后缀列表中的末尾。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.SUFFIXES:              # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h   # 定义自己的后缀</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p><code>make</code>的参数 <code>-r</code>或 <code>-no-builtin-rules</code>也会使用得默认的后缀列表为空。而变量 <code>SUFFIXE</code>被用来定义默认的后缀列表，你可以用 <code>.SUFFIXES</code>来改变后缀列表，但请不要改变变量 <code>SUFFIXE</code>的值。</p>
<h2 id="9-7-隐含规则搜索算法"><a href="#9-7-隐含规则搜索算法" class="headerlink" title="9.7 隐含规则搜索算法"></a>9.7 隐含规则搜索算法</h2><p>比如我们有一个目标叫 <code>T</code>。下面是搜索目标 <code>T</code>的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在 <code>Makefile</code>被载入内存时，会被转换成模式规则。如果目标是 <code>archive(member)</code>的函数库文件模式，那么这个算法会被运行两次，第一次是找目标 <code>T</code>，如果没有找到的话，那么进入第二次，第二次会把 <code>member</code>当作 <code>T</code>来搜索。</p>
<ul>
<li>把 <code>T</code>的目录部分分离出来。叫 <code>D</code>，而剩余部分叫 <code>N</code>。（如：如果 <code>T</code>是 <code>src/foo.o</code>，那么，<code>D</code>就是 <code>src/</code>，<code>N</code>就是 <code>foo.o</code>）</li>
<li>创建所有匹配于 <code>T</code>或是 <code>N</code>的模式规则列表。</li>
<li>如果在模式规则列表中有匹配所有文件的模式，如 <code>%</code>，那么从列表中移除其它的模式。</li>
<li>移除列表中没有命令的规则。</li>
<li>对于第一个在列表中的模式规则：<br>1）推导其”茎”<code>S</code>，<code>S</code>应该是 <code>T</code>或是 <code>N</code>匹配于模式中 <code>%</code>非空的部分。<br>2）计算依赖文件。把依赖文件中的 <code>%</code>都替换成 <code>茎S</code>。如果目标模式中没有包含斜框字符，而把 <code>D</code>加在第一个依赖文件的开头。<br>3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）<br>4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>
<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br>1）如果规则是终止规则，那就忽略它，继续下一条模式规则。<br>2）计算依赖文件。（同第5步）<br>3）测试所有的依赖文件是否存在或是理当存在。<br>4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br>5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>
<li>如果没有隐含规则可以使用，查看 <code>.DEFAULT</code>规则，如果有，采用，把 <code>.DEFAULT</code>的命令给 <code>T</code>使用。</li>
</ul>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h1 id="十、使用make更新函数库文件"><a href="#十、使用make更新函数库文件" class="headerlink" title="十、使用make更新函数库文件"></a><strong>十、使用make更新函数库文件</strong></h1><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>
<h2 id="10-1-函数库文件的成员"><a href="#10-1-函数库文件的成员" class="headerlink" title="10.1 函数库文件的成员"></a><strong>10.1 函数库文件的成员</strong></h2><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">archive(member)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(hack.o) : hack.o</span><br><span class="line">      ar cr foolib hack.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要指定多个member，那就以空格分开，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(hack.o kludge.o)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(hack.o) foolib(kludge.o)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你还可以使用Shell的文件通配符来定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(*.o)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-2-函数库成员的隐含规则"><a href="#10-2-函数库成员的隐含规则" class="headerlink" title="10.2 函数库成员的隐含规则"></a><strong>10.2 函数库成员的隐含规则</strong></h2><p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o”的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cc -c bar.c -o bar.o</span><br><span class="line">ar r foo.a bar.o</span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure>
<p>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>
<h2 id="10-3-函数库文件的后缀规则"><a href="#10-3-函数库文件的后缀规则" class="headerlink" title="10.3 函数库文件的后缀规则"></a><strong>10.3 函数库文件的后缀规则</strong></h2><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.a:</span></span><br><span class="line">      <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">      <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">      <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure>
<p>其等效于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">(%.o) : %.c</span><br><span class="line">      <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">      <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">      <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure>
<h2 id="10-4-注意事项"><a href="#10-4-注意事项" class="headerlink" title="10.4 注意事项"></a><strong>10.4 注意事项</strong></h2><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p>
<p>但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>
<h1 id="后序"><a href="#后序" class="headerlink" title="后序"></a><strong>后序</strong></h1><p>终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测”函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）”杀伤力”。</p>
<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp……等等，等等，来完成诸如”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N”奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的”@@@N、###N”等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的”扩展C”语言（即在C语言中用”EXEC　SQL”的样子执行SQL语句，在用cc/gcc编译之前，需要使用”扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>
<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入”!make”时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>
<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。</p>
<p>最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。QQ是：753640</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面经</title>
    <url>/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="一、网络协议层次"><a href="#一、网络协议层次" class="headerlink" title="一、网络协议层次"></a>一、网络协议层次</h1><p>网络模型分层，OSI参考模型与TCP/IP模型各有优缺点，所以学习的时候通常综合两者优点：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701439941030.png" alt="1701439941030"></p>
<p>如何理解网络模型的分层？我们先用Wireshark软件抓取一下网络通讯时的数据包，看看通讯时到底传输了什么东西，下图是我访问网站时抓取到的数据包：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701435107059.png" alt="1701435107059"></p>
<p>根据数据包的结构可以把数据包分为这样几个部分，正好可以与网络模型相对应：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701439951221.png" alt="1701439951221"></p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699173738490.png" alt="1699173738490"></p>
<p><strong>ISO七层模型</strong>是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<ul>
<li>应用层：网络服务与最终用户的一个接口，常见的协议有： <strong>HTTP FTP  SMTP SNMP DNS</strong> .</li>
<li>表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</li>
<li>会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有 <strong>TCP UDP</strong> .</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有 <strong>ICMP IGMP IP等</strong> .</li>
<li>数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
<h2 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h2><p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701501310919.png" alt="1701501310919"></p>
<p> <strong>五层模型</strong> ：应用层、传输层、网络层、数据链路层、物理层。</p>
<ul>
<li><strong>应用层</strong> ：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。</li>
<li><strong>传输层</strong> ：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</li>
<li><strong>网络层</strong> ：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</li>
<li><strong>数据链路层</strong> ：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</li>
<li><strong>物理层</strong> ：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>DNS</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440054899.png" alt="1701440054899"></p>
<p>FTP<br>SMTP<br>POP3<br>HTTP</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>UDP交付的是不可靠的信息，仅仅添加了端口信息和校验信息，校验还是可选的，其它的什么都没做。</p>
<p>TCP为了交付可靠的信息，设计了一套复杂的机制。</p>
<p>TCP链接管理：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440289775.png" alt="1701440289775"></p>
<p>TCP可靠传输：<br>TCP会对数据进行确认，确认号是期望收到对方下一个报文段的数据的第一个字节的序号。</p>
<p>两种事件会导致报文段重传：</p>
<ol>
<li><strong>超时重传</strong>，TCP使用略大于加权平均时间RTTs作为超时时间。</li>
<li><strong>冗余确认</strong>，当连续收到3个冗余的确认时，认为该报文段丢失，重传该报文段。</li>
</ol>
<p>TCP流量控制：</p>
<p>选择重传协议：发送窗口大小&gt;1,接收窗口&gt;1</p>
<p>TCP拥塞控制：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440315047.png" alt="1701440315047"></p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440320297.png" alt="1701440320297"></p>
<h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><p>IPv4</p>
<p>子网掩码、CIDR、超网</p>
<p>ARP协议</p>
<p>DHCP协议</p>
<p>ICMP协议</p>
<p>IPv6</p>
<h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><p>距离向量路由算法 RIP<br>RIP属于应用层的协议<br>RIP允许一条路由最多包含15个路由器。<br>仅和邻居路由器交流信息。<br>每30秒交换一次信息，180秒没收到信息，判定邻居没了。<br>坏消息传的慢，好消息传的快</p>
<p>链路状态路由算法 OSPF<br>使用洪泛法向自治系统内的所有路由器发送信息。类似广播。<br>链路状态发生变化时才用洪泛法交换信息。</p>
<p>外部网关协议 BGP<br>与BGP发言人交换信息。<br>发生变化时交换信息。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>流量控制与可靠传输机制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>停止-等待协议</th>
<th>发送窗口大小=1,接收窗口=1</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>后退N帧协议</strong></td>
<td><strong>发送窗口大小&gt;1,接收窗口=1</strong></td>
</tr>
<tr>
<td><strong>选择重传协议</strong></td>
<td><strong>发送窗口大小&gt;1,接收窗口&gt;1</strong></td>
</tr>
</tbody>
</table>
</div>
<p>介质访问控制：<br>现在每个电脑都单独一个冲突域，所以介质访问控制感觉无用武之地了。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440759281.png" alt="1701440759281"></p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440839192.png" alt="1701440839192"></p>
<p>第一副图，是2相位的，此时1个码元等于1个比特。<br>第二幅图，是4相位的，此时1个码元等于2个比特。</p>
<p>由此我们可以得出相位与一个码元的比特数关系：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701440892889.png" alt="1701440892889"></p>
<p>波特率是传输码元的速度，单位是B/s。<br>比特率是传输比特的速度，单位是b/s。</p>
<p>一个码元能携带2bit数据，那么比特率 = 2倍的波特率！<br>一个码元能携带4bit数据，那么比特率 = 4倍的波特率！</p>
<h2 id="TCP-IP层次对应协议"><a href="#TCP-IP层次对应协议" class="headerlink" title="TCP/IP层次对应协议"></a>TCP/IP层次对应协议</h2><ul>
<li>应用层：HTTP，DNS(域名解析协议)，FTP(文件传输协议)</li>
<li>传输层：UDP,TCP</li>
<li>网络层：IP(网际协议)，ICMP(互联网控制报文协议），IGMP（互联网组管理协议），RIP</li>
</ul>
<h1 id="二、TCP和UDP"><a href="#二、TCP和UDP" class="headerlink" title="二、TCP和UDP"></a>二、TCP和UDP</h1><h2 id="2-1-TCP和UDP区别"><a href="#2-1-TCP和UDP区别" class="headerlink" title="2.1 TCP和UDP区别"></a>2.1 TCP和UDP区别</h2><h3 id="UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景"><a href="#UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景" class="headerlink" title="UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景"></a>UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景</h3><ul>
<li>无连接，发送数据之前不需要建立连接。</li>
<li>尽最大努力交付，不保证可靠交付，不使用拥塞控制。</li>
<li>面向报文，适合多媒体通信。</li>
<li>支持一对一，一对多，多对一，多对多的交互通信。</li>
<li>首部开销小，8个字节。</li>
</ul>
<h3 id="TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议，-POP3、SMTP等邮件传输的协议"><a href="#TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议，-POP3、SMTP等邮件传输的协议" class="headerlink" title="TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议， POP3、SMTP等邮件传输的协议"></a>TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议， POP3、SMTP等邮件传输的协议</h3><ul>
<li>面向连接。</li>
<li>每一条TCP有且只有两个端点，为一对一关系。</li>
<li>提供可靠交付。</li>
<li>全双工通信，全双工为即可传输又可接收。</li>
<li>面向字节流。</li>
</ul>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699176497527.png" alt="1699176497527"></p>
<ul>
<li><strong>16位端口号</strong> ：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li>
<li><strong>32位序号</strong> ：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</li>
<li><strong>32位确认号</strong> ：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</li>
<li><strong>4位头部长度</strong> ：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</li>
<li><strong>6位标志位</strong> ：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li>
<li><strong>16位窗口大小</strong> ：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16位校验和</strong> ：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</li>
<li><strong>16位紧急指针</strong> ：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<h2 id="2-2-TCP为什么可靠"><a href="#2-2-TCP为什么可靠" class="headerlink" title="2.2 TCP为什么可靠"></a>2.2 TCP为什么可靠</h2><ul>
<li>乱序重排</li>
<li>应答确认</li>
<li>报文重传</li>
<li>流量控制（接收方受不了）</li>
<li>拥塞控制（网路受不了）</li>
</ul>
<h3 id="2-2-1-乱序重排、应答确认"><a href="#2-2-1-乱序重排、应答确认" class="headerlink" title="2.2.1 乱序重排、应答确认"></a>2.2.1 乱序重排、应答确认</h3><p>都跟<strong>序号</strong>有关。由于网络或“多线程”等因素，接收方收到的数据段很可能是乱序的，不过，因为每个TCP封装都有序号，接收方重组起来非常容易。</p>
<p>发送方每发送一个数据段，如果都等着收到接收方的确认后再发下一个，这效率太低了。我们在解释Acknowledgement Number确认号时，曾举过一个栗子，发送方的数据有1000字节，接收方收到后的确认号填写1001，是告诉发送方前面的都收到了，下次从序号1001开始发。那么，如果发送方发送了多个数据段，共5000字节，接收方只需发一个确认号为5001的报文，是不是就可以呢？</p>
<p>没错，TCP就是这么干的！这就大大提高了效率。至于一次收多少字节再发确认，由接收方window决定。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699174036778.png" alt="1699174036778"></p>
<h3 id="2-2-2-报文重传"><a href="#2-2-2-报文重传" class="headerlink" title="2.2.2 报文重传"></a>2.2.2 报文重传</h3><p>一种是 <strong>超时重传</strong> ，发送方收不到确认的时候用。我们都知道网速并不是稳定的，传输时的每个报文的延时也不一样。TCP会根据报文的往返时间（RTT）自动调整超时重传时间（RTO）。发送方每发一个报文段都会开始计时，如果时间超过RTO还没收到这个报文段的确认，就重传该报文段。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699174097320.png" alt="1699174097320"></p>
<p>另一种方法是 <strong>快速重传</strong> ，发送的数据在路上丢失的时候用。</p>
<p>我们看下图：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699174127387.png" alt="1699174127387"></p>
<p>接收方收到序号1后，回复确认号2，希望下次收到序号2的报文段，但却乱序收到比序号2大的3、4、5报文段，于是连续发出确认号为2的报文段。如果发送方连续三次收到重复的确认号，立即重发该报文段，而不管是否超时。</p>
<h3 id="2-2-3-流量控制（滑动窗口解决）"><a href="#2-2-3-流量控制（滑动窗口解决）" class="headerlink" title="2.2.3 流量控制（滑动窗口解决）"></a>2.2.3 流量控制（滑动窗口解决）</h3><p>首先要明白一点，应用程序不论发送还是接收数据，都会先把数据放入缓冲区，再从缓冲区中发出或读取数据。就像秘书，先把事情整理归纳好，再一次性向你汇报。</p>
<p>这个缓冲区大小，反映了应用程序一次能处理数据的能力。如果接收方应用程序处理速度比发送方的发送速度慢，就会造成接收方缓冲区“溢出”。实际上，发送方发送速度和接收方处理速度很难一致。</p>
<p>这就需要window来调整了。</p>
<p>TCP在三次握手建立连接时，会协商双方缓冲区window大小。如果因为接收方处理速度较慢，接收方会通过window告知发送方，实现动态调整，避免“溢出”。</p>
<blockquote>
<p><strong>TCP滑动窗口分为接受窗口，发送窗口</strong><br>滑动窗口协议是<strong>传输层进行流控</strong>的一种措施， <strong>接收方通过通告发送方自己的窗口大小</strong> ，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p>
<p>对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息：</p>
<p><strong>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，**</strong>接收方是不会发送序号为n+2的ACK的。**举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</p>
<p>二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理</p>
<p>重点：发送方根据收到ACK当中的期望收到的下一个字节的序号n以及窗口m，还有当前已经发送的字节序号x，算出还可以发送的字节数。</p>
</blockquote>
<h3 id="2-2-4-拥塞控制（拥塞窗口）"><a href="#2-2-4-拥塞控制（拥塞窗口）" class="headerlink" title="2.2.4 拥塞控制（拥塞窗口）"></a><strong>2.2.4 拥塞控制（拥塞窗口）</strong></h3><p>拥塞控制是 <strong>作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况</strong> 。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟<strong>流量控制</strong>又有什么区别呢？流量控制是作用于接收者的，根据 <strong>接收端的实际接收能力控制发送速度</strong> ，防止分组丢失的。</p>
<p>我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701594728488.png" alt="1701594728488"></p>
<p>发送方维护一个<strong>拥塞窗口cwnd（congestion window）</strong> 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？</p>
<p>一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP的描述就是：</p>
<blockquote>
<p>★</p>
<p>只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
</blockquote>
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<p>swnd发送窗口 = min(cwnd拥塞窗口, rwnd接收窗口)</p>
<h4 id="2-2-4-1-慢开始"><a href="#2-2-4-1-慢开始" class="headerlink" title="2.2.4.1 慢开始"></a>2.2.4.1 慢开始</h4><p>假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2。即收到多少确认报文就增加多少。所以拥塞窗口是<strong>以指数型增长的（1,2,4,8…）</strong>。一直到cwnd等于<strong>ssthresh阈值</strong>时启动<strong>拥塞控制</strong>算法。如下图，慢开始增长速度并不慢，只是开始时向网络注入数据报文较少。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699174543142.png" alt="1699174543142"></p>
<h4 id="2-2-4-2-拥塞避免"><a href="#2-2-4-2-拥塞避免" class="headerlink" title="2.2.4.2 拥塞避免"></a>2.2.4.2 拥塞避免</h4><p>进入拥塞避免阶段时， <strong>cwnd每次只能加1</strong> 。当出现报文丢失时，丢失的报文的重传计时器超时后会被判断出现拥塞，此时需要更改cwnd和ssthresh。</p>
<p>出现拥塞：</p>
<blockquote>
<p>1、ssthresh更新为出现拥塞时cwnd数值的一半；</p>
<p>2、cwnd赋值为1；</p>
<p>3、重新执行<strong>慢开始</strong>算法。</p>
</blockquote>
<p>如下图所示，初始ssthresh为16，当cwnd小于ssthresh成指数型增长，当cwnd &gt; ssthresh时，cwnd逐次增加1。当其值为24时，出现丢包，此时判断为拥塞，将ssthresh调整为出现拥塞时的一般，即12。之后cwnd赋值为1，重新执行慢开始算法。由下图仍可见，拥塞避免并不是完全避免拥塞，而是将拥塞窗口的增长变为线性的，使网络不容易出现拥塞。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699174678186.png" alt="1699174678186"></p>
<p><strong>以上的两个算法存在不足之处，当个别报文在网络中丢失时，可能实际上网络并未发生拥塞。这将导致发送端超时重传，并误以为网络发送拥塞。由于每次拥塞控制都会将cwnd设置为1，这严重降低了传输效率。由此，新增了快速重传算法和快速恢复算法。</strong></p>
<h4 id="2-2-4-3-快重传"><a href="#2-2-4-3-快重传" class="headerlink" title="2.2.4.3 快重传"></a>2.2.4.3 快重传</h4><p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699174740174.png" alt="1699174740174"></p>
<h4 id="2-2-4-4-快恢复（区别丢失个别报文还是网络拥塞，防止误判）"><a href="#2-2-4-4-快恢复（区别丢失个别报文还是网络拥塞，防止误判）" class="headerlink" title="2.2.4.4 快恢复（区别丢失个别报文还是网络拥塞，防止误判）"></a>2.2.4.4 快恢复（区别丢失个别报文还是网络拥塞，防止误判）</h4><p>如下，发送端连续接收端<strong>三个重复确认报文</strong>后可以确认只是丢失了个别报文（ <strong>确认报文可以传回，网络没有拥塞</strong> ），此时不需要启动慢开始算法。此时 <strong>将ssthresh和cwnd赋值为此时的cwnd的一半</strong> ，然后执行拥塞避免算法。具体机制如下图所示。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1699175640464.png" alt="1699175640464"></p>
<p>当然也有的快速回复算法，将cwnd的值增大3，即cwnd = ssthresh + 3（ssthresh为连续三次受到确认号时的cwnd值的一半）。因为接收端缓存中已经存在了三个数据报文，这三个报文不会再占用网络资源，所以拥塞窗口可以适当增大。这么做也是为了尽可能提高吞吐量。</p>
<h2 id="2-3-三次握手"><a href="#2-3-三次握手" class="headerlink" title="2.3 三次握手"></a>2.3 三次握手</h2><p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是 <code>CLOSED</code>。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20221106/698656726_1667694705933/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%BE%E8%A7%A3.png" alt></p>
<ol>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位 <code>SYN=1</code>，序列号 <code>seq=x</code>。第一次握手前客户端的状态为 <code>CLOSE</code>，第一次握手后客户端的状态为 <code>SYN-SENT</code>。此时服务端的状态为 <code>LISTEN</code>。</li>
<li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位 <code>SYN=1</code>，<code>ACK=1</code>，序列号 <code>seq=y</code>，确认号 <code>ack=x+1</code>。第二次握手前服务端的状态为 <code>LISTEN</code>，第二次握手后服务端的状态为 <code>SYN-RCVD</code>，此时客户端的状态为 <code>SYN-SENT</code>。（其中 <code>SYN=1</code>表示要和客户端建立一个连接，<code>ACK=1</code>表示确认序号有效）</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位 <code>ACK=1</code>，序列号 <code>seq=x+1</code>，确认号 <code>ack=y+1</code>。第三次握手前客户端的状态为 <code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为 <code>ESTABLISHED</code>。<strong>此时连接建立完成。</strong></li>
</ol>
<h3 id="2-3-1-两次握手可以吗？"><a href="#2-3-1-两次握手可以吗？" class="headerlink" title="2.3.1 两次握手可以吗？"></a>2.3.1 两次握手可以吗？</h3><p>第三次握手主要为了<strong>防止已失效的连接请求报文段</strong>突然又传输到了服务端，导致产生问题。</p>
<ul>
<li>比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。</li>
<li>连接成功，等待数据传输完毕后，就释放了连接。</li>
<li>然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。</li>
<li>如果不采用三次握手，只要B发出确认，就建立新的连接了，<strong>此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。</strong></li>
</ul>
<h2 id="2-4-四次挥手"><a href="#2-4-四次挥手" class="headerlink" title="2.4 四次挥手"></a>2.4 四次挥手</h2><p><img src="https://uploadfiles.nowcoder.com/files/20221106/698656726_1667694706020/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B0.png" alt></p>
<ol>
<li>A的应用进程先向其TCP发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭TCP连接，进入 <code>FIN-WAIT-1</code>（终止等待1）状态，等待B的确认。</li>
<li>B收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B进入 <code>CLOSE-WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li>
<li>A收到B的确认后，进入 <code>FIN-WAIT-2</code>（终止等待2）状态，等待B发出的连接释放报文段。</li>
<li>B发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B进入 <code>LAST-ACK</code>（最后确认）状态，等待A的确认。</li>
<li>A收到B的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A进入 <code>TIME-WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间 <code>2MSL</code>（最大报文段生存时间）后，A才进入 <code>CLOSED</code>状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。</li>
</ol>
<h3 id="2-4-1-第四次挥手为什么要等待2MSL？"><a href="#2-4-1-第四次挥手为什么要等待2MSL？" class="headerlink" title="2.4.1 第四次挥手为什么要等待2MSL？"></a>2.4.1 第四次挥手为什么要等待2MSL？</h3><ul>
<li><strong>保证A发送的最后一个ACK报文段能够到达B</strong> 。这个 <code>ACK</code>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在 <code>2MSL</code>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到 <code>CLOSED</code>状态，若A在 <code>TIME-WAIT</code>状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到 <code>CLOSED</code>状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong> 。A在发送完最后一个 <code>ACK</code>报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h3 id="2-4-2-为什么是四次挥手？"><a href="#2-4-2-为什么是四次挥手？" class="headerlink" title="2.4.2 为什么是四次挥手？"></a>2.4.2 为什么是四次挥手？</h3><p>因为当Server端收到Client端的 <code>SYN</code>连接请求报文后，可以直接发送 <code>SYN+ACK</code>报文。 <strong>但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET</strong> ，所以Server端先回复一个 <code>ACK</code>报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。</p>
<h1 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h1><h2 id="3-1-HTTP常用的状态码及其含义"><a href="#3-1-HTTP常用的状态码及其含义" class="headerlink" title="3.1 HTTP常用的状态码及其含义"></a>3.1 HTTP常用的状态码及其含义</h2><p><strong>思路:</strong> 这道面试题主要考察候选人，是否掌握HTTP状态码这个基础知识点。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701499614783.png" alt="1701499614783"></p>
<p><strong>日常开发中的这几个状态码的含义：</strong></p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/f%3A/Git_repository/note/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/1701499597174.png" alt="1701499597174"></p>
<h2 id="3-2-HTTP-常用的请求方式，区别和用途"><a href="#3-2-HTTP-常用的请求方式，区别和用途" class="headerlink" title="3.2 HTTP 常用的请求方式，区别和用途"></a>3.2 HTTP 常用的请求方式，区别和用途</h2><p><strong>思路:</strong> 这道题主要考察候选人，是否掌握<strong>HTTP请求方式</strong>这个基础知识点，我们用得比较多就是<strong>GET和POST</strong>啦。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701499651142.png" alt="1701499651142"></p>
<h2 id="3-3-HTTP端口及对应的服务"><a href="#3-3-HTTP端口及对应的服务" class="headerlink" title="3.3 HTTP端口及对应的服务"></a>3.3 HTTP端口及对应的服务</h2><p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701499656454.png" alt="1701499656454"></p>
<h2 id="3-4-如何理解HTTP协议是无状态的"><a href="#3-4-如何理解HTTP协议是无状态的" class="headerlink" title="3.4 如何理解HTTP协议是无状态的"></a>3.4 如何理解HTTP协议是无状态的</h2><p><strong>思路:</strong> 这道题主要考察候选人，是否理解Http协议，它为什么是无状态的呢？如何使它有状态呢？</p>
<p>如何理解无状态这个词呢？</p>
<blockquote>
<p>★</p>
<p>当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议。</p>
</blockquote>
<p>可以通过一个生活中的例子，来更好理解并记住它：</p>
<p><strong>有状态场景：</strong></p>
<ul>
<li>小红：今天吃啥子？</li>
<li>小明：罗非鱼~</li>
<li>小红：味道怎么样呀？</li>
<li>小明：还不错，好香。</li>
</ul>
<p><strong>无状态的场景：</strong></p>
<ul>
<li>小红：今天吃啥子？</li>
<li>小明：罗非鱼~</li>
<li>小红：味道怎么样呀？</li>
<li><p>小明：？啊？你说啥？什么鬼？什么味道怎么样？</p>
<p><strong>Http加了Cookie的话</strong> ：</p>
</li>
<li><p>小红：今天吃啥子？</p>
</li>
<li>小明：罗非鱼~</li>
<li>小红：你今天吃的罗非鱼，味道怎么样呀？</li>
<li>小明：还不错，好香。</li>
</ul>
<h2 id="3-5-从浏览器地址栏输入url到显示主页的过程"><a href="#3-5-从浏览器地址栏输入url到显示主页的过程" class="headerlink" title="3.5 从浏览器地址栏输入url到显示主页的过程"></a>3.5 从浏览器地址栏输入url到显示主页的过程</h2><p><strong>思路:</strong> 这道题主要考察的知识点是HTTP的请求过程， <strong>DNS解析，TCP三次握手，四次挥手这几个要点</strong> ，我们都可以讲下。</p>
<ol>
<li>DNS解析，查找域名对应的IP地址。</li>
<li>与服务器通过三次握手，建立TCP连接</li>
<li>向服务器发送HTTP请求</li>
<li>服务器处理请求，返回网页内容</li>
<li>浏览器解析并渲染页面</li>
<li>TCP四次挥手，连接结束</li>
</ol>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701500068673.png" alt="1701500068673"></p>
<h2 id="3-6-说下HTTP-1-0，1-1，2-0的区别"><a href="#3-6-说下HTTP-1-0，1-1，2-0的区别" class="headerlink" title="3.6 说下HTTP/1.0，1.1，2.0的区别"></a>3.6 说下HTTP/1.0，1.1，2.0的区别</h2><p><strong>思路:</strong> 这道题主要考察的知识点是HTTP几个版本的区别，我们记住<strong>HTTP/1.0</strong>默认是短连接，可以强制开启，HTTP/1.1默认长连接，HTTP/2.0采用<strong>多路复用</strong>就差不多啦。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a><strong>HTTP/1.0</strong></h3><ul>
<li>默认使用 <strong>短连接</strong> ，每次请求都需要建立一个TCP连接。它可以设置 <code>Connection: keep-alive</code> 这个字段，强制开启长连接。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a><strong>HTTP/1.1</strong></h3><ul>
<li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用。</li>
<li>分块传输编码，即服务端没产生一块数据，就发送一块，用”流模式”取代”缓存模式”。</li>
<li>管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a><strong>HTTP/2.0</strong></h3><ul>
<li>二进制协议，1.1版本的头信息是文本（ASCII编码），数据体可以是文本或者二进制；2.0中，头信息和数据体都是二进制。</li>
<li>完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</li>
<li>报头压缩，HTTP协议不带有状态，每次请求都必须附上所有信息。Http/2.0引入了头信息压缩机制，使用gzip或compress压缩后再发送。</li>
<li>服务端推送，允许服务器未经请求，主动向客户端发送资源。</li>
</ul>
<h2 id="3-7-POST和GET有哪些区别？"><a href="#3-7-POST和GET有哪些区别？" class="headerlink" title="3.7 POST和GET有哪些区别？"></a>3.7 POST和GET有哪些区别？</h2><p><strong>思路:</strong> 这道题主要考察的知识点是POST和GET的区别，可以从<strong>数据包、编码方式、请求参数、收藏为书签、历史记录、安全性</strong>等几方面去回答哈。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701500075739.png" alt="1701500075739"></p>
<h2 id="3-8-在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"><a href="#3-8-在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？" class="headerlink" title="3.8 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"></a>3.8 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</h2><p>这个问题记住 <code>keep-alive</code>就好，也就是说，在HTTP中响应体的<strong>Connection</strong>字段指定为 <code>keep-alive</code>即可</p>
<h2 id="3-9-HTTP-如何实现长连接？在什么时候会超时？"><a href="#3-9-HTTP-如何实现长连接？在什么时候会超时？" class="headerlink" title="3.9 HTTP 如何实现长连接？在什么时候会超时？"></a>3.9 HTTP 如何实现长连接？在什么时候会超时？</h2><p><strong>思路:</strong> 这道题实际上是考察TCP长连接的知识点，HTTP的长连接实质是指TCP的长连接。至于什么时候超时，我们记住这几个参数如 <strong>tcp_keepalive_time</strong> 、<strong>tcp_keepalive_probes</strong>就好啦</p>
<h3 id="什么是HTTP的长连接？"><a href="#什么是HTTP的长连接？" class="headerlink" title="什么是HTTP的长连接？"></a><strong>什么是HTTP的长连接？</strong></h3><ol>
<li>HTTP分为长连接和短连接， <strong>本质上说的是TCP的长短连接</strong> 。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才具有真正的长连接和短连接这一说法哈。</li>
<li>TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS/CSS。</li>
</ol>
<p><strong>如何设置长连接？</strong></p>
<p>通过在头部（请求和响应头）设置<strong>Connection</strong>字段指定为 <code>keep-alive</code>，HTTP/1.0协议支持，但是是默认关闭的，从HTTP/1.1以后，连接默认都是长连接。</p>
<p><strong>在什么时候会超时呢？</strong></p>
<blockquote>
<p>★</p>
<p>HTTP一般会有httpd守护进程，里面可以设置 <strong>keep-alive timeout</strong> ，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间</p>
<ul>
<li>TCP 的<strong>keep-alive</strong>包含三个参数，支持在系统内核的net.ipv4里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong> ，则会发生侦测包，如果没有收到对方的ACK，那么会每隔 tcp_keepalive_intvl再发一次，直到发送了 <strong>tcp_keepalive_probes</strong> ，就会丢弃该连接。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. tcp_keepalive_intvl = 15</span><br><span class="line">2. tcp_keepalive_probes = 5</span><br><span class="line">3. tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure>
<h2 id="3-10-HTTP-与-HTTPS-的区别。"><a href="#3-10-HTTP-与-HTTPS-的区别。" class="headerlink" title="3.10 HTTP 与 HTTPS 的区别。"></a>3.10 HTTP 与 HTTPS 的区别。</h2><p><strong>思路:</strong> 这道题实际上考察的知识点是HTTP与HTTPS的区别，这个知识点非常重要，可以<strong>从安全性、数据是否加密、默认端口</strong>等这几个方面去回答哈。其实，当你理解HTTPS的整个流程，就可以很好回答这个问题啦。</p>
<p> <strong>我的答案如下</strong> ：</p>
<p>HTTP，即超文本传输协议，是一个基于TCP/IP通信协议来传递明文数据的协议。HTTP会存在这 <strong>几个问题</strong> ：</p>
<ul>
<li>请求信息是明文传输，容易被窃听截取。</li>
<li>没有验证对方身份，存在被冒充的风险</li>
<li>数据的完整性未校验，容易被中间人篡改</li>
</ul>
<p>为了解决Http存在的问题，Https出现啦。</p>
<p><strong>Https是什么？</strong></p>
<p> <strong>HTTPS= HTTP+SSL/TLS</strong> ，可以理解Https是身披SSL(Secure Socket Layer，安全套接层)的HTTP。</p>
<p>它们主要区别如下：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701500712179.png" alt="1701500712179"></p>
<h2 id="3-11-Https流程是怎样的？"><a href="#3-11-Https流程是怎样的？" class="headerlink" title="3.11 Https流程是怎样的？"></a>3.11 Https流程是怎样的？</h2><p><strong>思路:</strong> 这道题实际上考察的知识点是HTTPS的工作流程，大家需要回答这几个要点， <strong>公私钥、数字证书、加密、对称加密、非对称加密</strong> 。</p>
<ul>
<li>HTTPS = HTTP + SSL/TLS，也就是用SSL/TLS对数据进行加密和解密，Http进行传输。</li>
<li>SSL，即Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。</li>
<li>TLS，即Transport Layer Security(安全传输层协议)，它是SSL3.0的后续版本。</li>
</ul>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701500983984.png" alt="1701500983984"></p>
<h3 id="Https工作流程"><a href="#Https工作流程" class="headerlink" title="Https工作流程"></a>Https工作流程</h3><ol>
<li>客户端发起Https请求，连接到服务器的443端口。</li>
<li>服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</li>
<li>服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</li>
<li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</li>
<li>客户端将公钥加密后的密钥发送到服务器。</li>
<li>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</li>
<li>服务器将加密后的密文返回到客户端。</li>
<li>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</li>
</ol>
<h2 id="3-12-Http请求的过程与原理"><a href="#3-12-Http请求的过程与原理" class="headerlink" title="3.12 Http请求的过程与原理"></a>3.12 Http请求的过程与原理</h2><p><strong>思路:</strong> HTTP请求，一个非常非常基础的知识点，一定需要掌握的。其实觉得跟浏览器地址栏输入url到显示主页这道题有点类似。</p>
<p> <strong>我的答案如下</strong> ：</p>
<p>HTTP是一个基于TCP/IP协议来传递数据的超文本传输协议，传输的数据类型有HTML,图片等。以访问百度有例子，看下一次Http的请求过程吧</p>
<h3 id="Http请求过程"><a href="#Http请求过程" class="headerlink" title="Http请求过程"></a>Http请求过程</h3><ol>
<li>客户端进行DNS域名解析，得到对应的IP地址</li>
<li>根据这个IP，找到对应的服务器建立连接（三次握手）</li>
<li>建立TCP连接后发起HTTP请求（一个完整的http请求报文）</li>
<li>服务器响应HTTP请求，客户端得到html代码</li>
<li>客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。</li>
<li>服务器关闭TCP连接（四次挥手）</li>
</ol>
<h2 id="3-13-说说HTTP的状态码，301和302的区别？"><a href="#3-13-说说HTTP的状态码，301和302的区别？" class="headerlink" title="3.13 说说HTTP的状态码，301和302的区别？"></a>3.13 说说HTTP的状态码，301和302的区别？</h2><p><strong>思路:</strong> 这道题考查的知识点，也是HTTP状态码，302和301都有重定向的含义，但是它们也是有区别的。</p>
<ul>
<li>301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</li>
<li>302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。</li>
</ul>
<p>网上有个很<strong>形象的例子</strong>比喻：</p>
<blockquote>
<p>★</p>
<p>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。</p>
</blockquote>
<h2 id="3-14-说说什么是数字签名？什么是数字证书？"><a href="#3-14-说说什么是数字签名？什么是数字证书？" class="headerlink" title="3.14 说说什么是数字签名？什么是数字证书？"></a>3.14 说说什么是数字签名？什么是数字证书？</h2><p><strong>思路:</strong> 这道题考查的知识点，不仅仅是数字签名，数字证书，很可能面试官也会问你https的原理的，因为https原理跟数字证书有关的哈，大家需要掌握https原理哦。</p>
<p>数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。它的出现，是为了避免身份被篡改冒充的。比如Https的数字证书，就是为了避免公钥被中间人冒充篡改：</p>
<p><img src="https://static.mianbaoban-assets.eet-china.com/xinyu-images/MBXY-CR-203531ea8afd45f9e5977a413fdf0d39.png" alt="img"></p>
<p><strong>数字证书构成</strong></p>
<ul>
<li>公钥和个人等信息，经过Hash摘要算法加密，形成消息摘要；将消息摘要拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密，形成 <strong>数字签名</strong> 。</li>
<li>公钥和个人信息、数字签名共同构成 <strong>数字证书</strong> 。</li>
</ul>
<h2 id="3-15-对称加密与非对称加密有什么区别"><a href="#3-15-对称加密与非对称加密有什么区别" class="headerlink" title="3.15 对称加密与非对称加密有什么区别"></a>3.15 对称加密与非对称加密有什么区别</h2><p><strong>思路:</strong> 这道题考察的知识点是对称加密与非对称加密算法，什么是对称加密，什么是非对称加密呢？</p>
<p>对称加密：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES等。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701501033640.png" alt="1701501033640"><br>                                                    对称加密</p>
<p>非对称加密：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有RSA。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701501048176.png" alt="1701501048176"><br>                                                    非对称加密</p>
<h2 id="3-16-说说DNS的解析过程？"><a href="#3-16-说说DNS的解析过程？" class="headerlink" title="3.16 说说DNS的解析过程？"></a>3.16 说说DNS的解析过程？</h2><p><strong>思路:</strong> 这道题考察的知识点是 <strong>DNS域名解析</strong> ，http请求的过程，是涉及到DNS域名解析的，这道面试题也挺经典的，大家可以看下《图解HTTP》那本书哈。</p>
<blockquote>
<p>★</p>
<p>DNS，英文全称是 <strong>domain name system</strong> ，域名解析系统，是Internet上作为域名和IP相互映射的一个分布式数据库。它的作用很明确，就是可以根据域名查出对应的IP地址。在浏览器缓存、本地DNS服务器、根域名服务器都是怎么查找的，大家回答的时候都可以说下哈。</p>
</blockquote>
<p>DNS的解析过程如下图：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701501212312.png" alt="1701501212312"></p>
<p>假设你要查询<strong>www.baidu.com</strong>的IP地址:</p>
<blockquote>
<p>★</p>
<p>首先会查找浏览器的缓存,看看是否能找到<strong>www.baidu.com</strong>对应的IP地址，找到就直接返回；否则进行下一步。</p>
<ul>
<li>将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器返回负责 <code>.com</code>的顶级域名服务器的IP地址的列表。</li>
<li>本地DNS服务器再向其中一个负责 <code>.com</code>的顶级域名服务器发送一个请求，返回负责 <code>.baidu</code>的权威域名服务器的IP地址列表。</li>
<li>本地DNS服务器再向其中一个权威域名服务器发送一个请求，返回<strong>www.baidu.com</strong>所对应的IP地址。</li>
</ul>
</blockquote>
<h1 id="四、网络攻击"><a href="#四、网络攻击" class="headerlink" title="四、网络攻击"></a>四、网络攻击</h1><h2 id="4-1-什么是CSRF攻击，如何避免"><a href="#4-1-什么是CSRF攻击，如何避免" class="headerlink" title="4.1 什么是CSRF攻击，如何避免"></a>4.1 什么是CSRF攻击，如何避免</h2><p><strong>思路:</strong> 这道题考察的知识点是 <strong>CSRF攻击</strong> ，它是属于网络安全这块的知识点，还有<strong>Xss攻击、SQL注入、DDoS</strong>等这些常见的网络攻击，我们都需要知道攻击的流程哈。</p>
<p><strong>什么是CSRF 攻击？</strong></p>
<blockquote>
<p>★</p>
<p>CSRF，跨站请求伪造（英文全称是Cross-site request forgery），是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>
</blockquote>
<p><strong>CSRF是如何攻击的呢？</strong></p>
<p>来看一个来自百度百科的例子哈：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701501228139.png" alt="1701501228139"></p>
<ol>
<li>Tom 登陆银行，没有退出，浏览器包含了Tom在银行的身份认证信息。</li>
<li>黑客Jerry将伪造的转账请求，包含在在帖子</li>
<li>Tom在银行网站保持登陆的情况下，浏览帖子</li>
<li>将伪造的转账请求连同身份认证信息，发送到银行网站</li>
<li>银行网站看到身份认证信息，以为就是Tom的合法操作，最后造成Tom资金损失。</li>
</ol>
<p><strong>怎么解决CSRF攻击呢？</strong></p>
<ul>
<li>检查Referer字段。</li>
<li>添加校验token。</li>
</ul>
<h2 id="4-2-什么是DoS、DDoS、DRDoS攻击？"><a href="#4-2-什么是DoS、DDoS、DRDoS攻击？" class="headerlink" title="4.2 什么是DoS、DDoS、DRDoS攻击？"></a>4.2 什么是DoS、DDoS、DRDoS攻击？</h2><p><strong>思路:</strong> 这是涉及网络安全的一个知识点，DDos还会挺常见的，如SYN Flood。</p>
<blockquote>
<p>★</p>
<p><strong>DOS</strong> : (Denial of Service),翻译过来就是拒绝服务,一切能引起DOS行为的攻击都被称为DOS攻击。最常见的DoS攻击就有 <strong>计算机网络宽带攻击</strong> 、 <strong>连通性攻击</strong></p>
<ul>
<li><strong>DDoS</strong> : (Distributed Denial of Service),翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的DDos有<strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong>等。</li>
<li><strong>DRDoS</strong> : (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，从而形成拒绝服务攻击。</li>
</ul>
</blockquote>
<h2 id="4-3-什么是XSS攻击，如何避免"><a href="#4-3-什么是XSS攻击，如何避免" class="headerlink" title="4.3 什么是XSS攻击，如何避免?"></a>4.3 什么是XSS攻击，如何避免?</h2><p><strong>思路:</strong> XSS攻击也是比较常见，XSS，叫 <strong>跨站脚本攻击（Cross-Site Scripting）</strong> ，因为会与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，因此有人将跨站脚本攻击缩写为XSS。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。XSS攻击一般分三种类型：<strong>存储型 、反射型 、DOM型XSS</strong></p>
<h3 id="4-3-1-XSS是如何攻击的呢？"><a href="#4-3-1-XSS是如何攻击的呢？" class="headerlink" title="4.3.1 XSS是如何攻击的呢？"></a>4.3.1 XSS是如何攻击的呢？</h3><p>拿反射型举个例子吧，流程图如下：</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701502530418.png" alt="1701502530418"></p>
<h3 id="4-3-2-如何解决XSS攻击问题？"><a href="#4-3-2-如何解决XSS攻击问题？" class="headerlink" title="4.3.2 如何解决XSS攻击问题？"></a>4.3.2 如何解决XSS攻击问题？</h3><ul>
<li>对输入进行过滤，过滤标签等，只允许合法值。</li>
<li>HTML转义</li>
<li>对于链接跳转，如 <code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以script开头的非法链接。</li>
<li>限制输入长度</li>
</ul>
<h2 id="4-4-SQL注入"><a href="#4-4-SQL注入" class="headerlink" title="4.4 SQL注入"></a>4.4 SQL注入</h2><p><strong>思路:</strong> SQL注入是最经典的安全问题。无论你是前端开发还是后端开发，都必须掌握的。</p>
<blockquote>
<p>★</p>
<p>SQL注入是一种代码注入技术，一般被应用于攻击web应用程序。它通过在web应用接口传入一些特殊参数字符，来欺骗应用服务器，执行恶意的SQL命令，以达到非法获取系统信息的目的。它目前是黑客对数据库进行攻击的最常用手段之一。</p>
</blockquote>
<h3 id="4-4-1-SQL注入是如何攻击的？"><a href="#4-4-1-SQL注入是如何攻击的？" class="headerlink" title="4.4.1 SQL注入是如何攻击的？"></a>4.4.1 SQL注入是如何攻击的？</h3><p>举个常见的 <strong>业务场景</strong> ：在web表单搜索框输入员工名字，然后后台查询出对应名字的员工。</p>
<p><img src="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/image/1701502729696.png" alt="1701502729696"></p>
<p>这种场景下，一般都是前端页面,把一个名字参数name传到后台，然后后台通过SQL把结果查询出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name = &quot;田螺&quot;; //前端传过来的</span><br><span class="line"></span><br><span class="line">SQL= &quot;select * from staff where name=&quot; + name;  //根据前端传过来的name参数，查询数据库员工表staff</span><br></pre></td></tr></table></figure>
<p>因为SQL是直接拼接的，如果我们完全信任前端传的参数的话。假如前端传这么一个参数时 <code>&#39;&#39; or &#39;1&#39;=&#39;1&#39;</code>，SQL就变成酱紫的啦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from staff where name=&#x27;&#x27; or &#x27;1&#x27;=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>
<p>这个SQL会把所有的员工信息全都查出来了，酱紫就请求用户已经越权啦。请求者可以获取所有员工的信息，信息已经暴露了啦。</p>
<h3 id="4-4-2-如何预防SQL注入问题"><a href="#4-4-2-如何预防SQL注入问题" class="headerlink" title="4.4.2 如何预防SQL注入问题"></a>4.4.2 如何预防SQL注入问题</h3><p><strong>1). 使用#{}而不是 ${}</strong></p>
<p>在MyBatis中,使用 <code>#&#123;&#125;</code>而不是 <code>$&#123;&#125;</code>，可以很大程度防止sql注入。</p>
<ul>
<li>因为 <code>#&#123;&#125;</code>是一个参数占位符，对于字符串类型，会自动加上””，其他类型不加。由于Mybatis采用 <strong>预编译</strong> ，其后的参数不会再进行SQL编译，所以一定程度上防止SQL注入。</li>
<li><code>$&#123;&#125;</code>是一个简单的字符串替换，字符串是什么，就会解析成什么，存在SQL注入风险</li>
</ul>
<p><strong>2). 不要暴露一些不必要的日志或者安全信息，比如避免直接响应一些sql异常信息。</strong></p>
<p>如果SQL发生异常了，不要把这些信息暴露响应给用户，可以自定义异常进行响应</p>
<p><strong>3). 不相信任何外部输入参数，过滤参数中含有的一些数据库关键词关键词</strong></p>
<p>可以加个参数校验过滤的方法，过滤 <code>union，or</code>等数据库关键词</p>
<p><strong>4). 适当的权限控制</strong></p>
<p>在你查询信息时，先校验下当前用户是否有这个权限。比如说，实现代码的时候，可以让用户多传一个企业Id什么的，或者获取当前用户的session信息等，在查询前，先校验一下当前用户是否是这个企业下的等等，是的话才有这个查询员工的权限。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm新建工程</title>
    <url>/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、新建工程"><a href="#一、新建工程" class="headerlink" title="一、新建工程"></a>一、新建工程</h1><h2 id="1-点击新建工程"><a href="#1-点击新建工程" class="headerlink" title="1.点击新建工程"></a>1.点击新建工程</h2><p><img src="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/1703337095672.png" alt="1703337095672"></p>
<h2 id="2-设置工程信息"><a href="#2-设置工程信息" class="headerlink" title="2.设置工程信息"></a>2.设置工程信息</h2><p><img src="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/1703337259813.png" alt="1703337259813"></p>
<h2 id="3-新建python文件"><a href="#3-新建python文件" class="headerlink" title="3.新建python文件"></a>3.新建python文件</h2><p><img src="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/1703337409402.png" alt="1703337409402"></p>
<p>设置python文件名</p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/f%3A/Git_repository/note/OpenCV/OpenCV%20%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/1703337492529.png" alt="1703337492529"></p>
<h2 id="4-设置python配置信息"><a href="#4-设置python配置信息" class="headerlink" title="4.设置python配置信息"></a>4.设置python配置信息</h2><p><img src="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/1703337721295.png" alt="1703337721295"></p>
<p>添加脚本路径</p>
<p><img src="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/1703337953102.png" alt="1703337953102"></p>
<h1 id="二、编写程序"><a href="#二、编写程序" class="headerlink" title="二、编写程序"></a>二、编写程序</h1><p><img src="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/image/1703338050213.png" alt="1703338050213"></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV 初级教程</tag>
      </tags>
  </entry>
</search>
