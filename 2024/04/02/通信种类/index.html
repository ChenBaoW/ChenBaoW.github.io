<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>通信种类 | 爱是无一</title><meta name="author" content="BW"><meta name="copyright" content="BW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、串口通信串口通信属于全双工，串行通信，有同步和异步通信。USART：通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换，既可以同步通信也可以异步通信。UART：通用异步收发器(Universal Asynchronous Receiver and">
<meta property="og:type" content="article">
<meta property="og:title" content="通信种类">
<meta property="og:url" content="https://chenbaow.github.io/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/index.html">
<meta property="og:site_name" content="爱是无一">
<meta property="og:description" content="一、串口通信串口通信属于全双工，串行通信，有同步和异步通信。USART：通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换，既可以同步通信也可以异步通信。UART：通用异步收发器(Universal Asynchronous Receiver and">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenbaow.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-04-02T14:20:00.000Z">
<meta property="article:modified_time" content="2024-04-02T14:34:25.830Z">
<meta property="article:author" content="BW">
<meta property="article:tag" content="嵌入式通讯协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenbaow.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chenbaow.github.io/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: BW","link":"链接: ","source":"来源: 爱是无一","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '通信种类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-02 22:34:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><div id="myscoll"></div><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/stars.png')"><nav id="nav"><span id="blog-info"><a href="/" title="爱是无一"><span class="site-name">爱是无一</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">通信种类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-02T14:20:00.000Z" title="发表于 2024-04-02 22:20:00">2024-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-02T14:34:25.830Z" title="更新于 2024-04-02 22:34:25">2024-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="通信种类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、串口通信"><a href="#一、串口通信" class="headerlink" title="一、串口通信"></a>一、串口通信</h1><p>串口通信属于全双工，串行通信，有同步和异步通信。<br>USART：通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换，既可以同步通信也可以异步通信。<br>UART：通用异步收发器(Universal Asynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能（时钟同步），只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p>
<h2 id="1-1-UART"><a href="#1-1-UART" class="headerlink" title="1.1 UART"></a>1.1 UART</h2><p>8051、STM32等MCU芯片的内部都集成了UART，两个MCU进行串口通信时，可将一个MCU的TX、RX引脚分别与另一个MCU的RX、TX引脚相连</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699363964154.png" alt="1699363964154"></p>
<p>UART进行串口通信使用TTL电平。5V工作电压的MCU，使用0 ~ 0.5V表示逻辑0，2.5V ~ 5V表示逻辑1；3.3V工作电压的MCU，使用0 ~ 0.5V表示逻辑0，2.5V ~ 3.3V表示逻辑1。</p>
<p>UART串口通信是异步，全双工，串行通信，所以通信双方必须事先约定好通信参数，这些通信参数包括：波特率、数据位、校验位、停止位。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699363975769.png" alt="1699363975769"></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364814032.png" alt="1699364814032"></p>
<h3 id="1-起始位、数据位、奇偶校验位、停止位"><a href="#1-起始位、数据位、奇偶校验位、停止位" class="headerlink" title="1.起始位、数据位、奇偶校验位、停止位"></a><strong>1.起始位、数据位、奇偶校验位、停止位</strong></h3><p>串口通信时，收发是一个周期一个周期进行的，每个周期传输n个二进制位。这一个周期就叫做一个通信单元，一个通信单元由：起始位+数据位+奇偶校验位+停止位组成的。</p>
<p>起始位：表示发送方要开始发送一个通信单元，起始位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。</p>
<p>数据位：是一个通信单元中发送的有效信息位，是本次通信真正要发送的有效数据，串口通信一次发送多少位有效数据是可以设定的（可选的有6、7、8、9，一般都是选择8位数据位，因为一般通过串口发送的文字信息都是ASCII码编码，而ASCII码中一个字符刚好编码为8位）。</p>
<p>校验位：是用来校验数据位，以防止数据位出错的。</p>
<p>停止位：是发送方用来表示本通信单元结束标志的，停止位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。常见的有1位停止位、1.5位停止位、2位停止位等，一般使用的是1位停止位。</p>
<h3 id="2-波特率"><a href="#2-波特率" class="headerlink" title="2.波特率"></a><strong>2.波特率</strong></h3><p>波特率，指的是串口通信的速率，也就是每秒钟可以传输多少个二进制位，单位为bit/s。譬如，每秒钟可以传输9600个二进制位，它传输所用的时间</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364286832.png" alt="1699364286832"></p>
<p>也就是传输一个二进制位需要的时间是1/9600秒，也就是104us。</p>
<p>串口通信的波特率不能随意设定，而应该是在一些值中去选择。一般最常见的波特率是9600或115200（低端单片机如51常用9600，高端单片机和嵌入式SOC常用</p>
<p>115200）。波特率不能随意指定，主要是因为：通信双方必须事先设定相同的波特率才能成功通信，如果发送方和接收方按照不同的波特率通信则根本收不到。</p>
<h2 id="1-2-RS232通信"><a href="#1-2-RS232通信" class="headerlink" title="1.2 RS232通信"></a>1.2 RS232通信</h2><p>RS232标准使用+5 V ～ +15 V表示逻辑0，-5V ～ -15 V表示逻辑1。相比TTL电平，RS232电平提高了串口通信的抗干扰能力，增大了串口通信的距离。台式PC一般都带有RS232标准接口，MCU按RS232标准进行串口通信时，需加max232电平转换芯片。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364589028.png" alt="1699364589028"></p>
<h2 id="1-3-RS485通信"><a href="#1-3-RS485通信" class="headerlink" title="1.3 RS485通信"></a>1.3 RS485通信</h2><p>RS485标准使用差分电平表示逻辑0或1，当A与B的电压差为+2v ~ +6v 时表示逻辑1，当A与B的电压差为-2v ~ -6v时表示逻辑0。RS485为半双工通信，即通信节点不能同时进行数据的接收和发送。相比RS232电平，RS485电平使串口通信的抗干扰能力更强，通信距离更远。MCU按RS485标准进行串口通信时，需加max485电平转换芯片。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364633791.png" alt="1699364633791"></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364752080.png" alt="1699364752080"></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699367010762.png" alt="1699367010762"></p>
<h1 id="二、I2C总线（Inter-Integrated-Circuit）"><a href="#二、I2C总线（Inter-Integrated-Circuit）" class="headerlink" title="二、I2C总线（Inter Integrated Circuit）"></a><strong>二、I2C总线（Inter Integrated Circuit）</strong></h1><p>I2C总线是一种同步、双向、半双工的两线式串行接口总线。这里，半双工的含义是指在任意给定的时刻，只有一个方向上是可以通信的。I2C总线最早由Philips半导体公司于20世纪80年代研发面市。I2C最初的设计目标是为微处理器/微控制器系统与电视机外围芯片之间的连接提供简单的方法。</p>
<h2 id="2-1-物理接口"><a href="#2-1-物理接口" class="headerlink" title="2.1 物理接口"></a>2.1 物理接口</h2><h3 id="2-1-1-接线"><a href="#2-1-1-接线" class="headerlink" title="2.1.1 接线"></a>2.1.1 接线</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699365266267.png" alt="1699365266267"></p>
<p>I2C总线由两条总线组成：串行时钟线SCL和串行数据线SDA。</p>
<ul>
<li>SCL线——负责产生同步时钟脉冲。</li>
<li>SDA线——负责在设备间传输串行数据。</li>
</ul>
<h3 id="2-1-2-物理接口示意图"><a href="#2-1-2-物理接口示意图" class="headerlink" title="2.1.2 物理接口示意图"></a>2.1.2 物理接口示意图</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699365946231.png" alt="1699365946231"></p>
<p>I2C的连线总是要通过电阻上拉至输入电压，I2C的连线工作于三种速度：<strong>高速，快速，慢速</strong>。</p>
<p>I2C总线是共享的总线系统，因此可以将多个I2C设备连接到该系统上。连接到I2C总线上的设备既可以用作主设备，也可以用作从设备。主设备负责控制通信，通过对数据传输进行初始化/终止化，来发送数据并产生所需的同步时钟脉冲。从设备则是等待来自主设备的命令，并响应命令接收。主设备和从设备都可以作为发送设备或接收设备。无论主设备是作为发送设备还是接收设备，同步时钟信号都只能由主设备产生。在相同的总线上，I2C支持多个主设备的同时存在。图1-1显示了I2C总线上主设备和从设备的连接关系。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699366167296.png" alt="1699366167296"></p>
<h2 id="2-2-i2c简易时序图"><a href="#2-2-i2c简易时序图" class="headerlink" title="2.2 i2c简易时序图"></a>2.2 i2c简易时序图</h2><ul>
<li>启动条件<br>当SCL为高电平时，SDA从高电平向低电平切换</li>
<li>停止条件<br>当SCL是高电平时，SDA由低电平向高电平切换</li>
<li>地址帧<br>每个从属设备唯一的7位或10位序列，用于主从设备之间的地址识别。</li>
<li>读/写位<br>一位，如果主机是向从机发送数据则为低电平，请求数据则为高电平</li>
<li>ACK/NACK<br>消息中的每个帧后均有一个ACK/NACK位。如果成功接收到地址帧或数据帧，接收设备会返回一个ACK位用于表示确认。</li>
</ul>
<h3 id="2-2-1-启动信号与停止信号的时序图"><a href="#2-2-1-启动信号与停止信号的时序图" class="headerlink" title="2.2.1 启动信号与停止信号的时序图"></a>2.2.1 启动信号与停止信号的时序图</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699366574897.png" alt="1699366574897"></p>
<h3 id="2-2-2-数据位发送"><a href="#2-2-2-数据位发送" class="headerlink" title="2.2.2 数据位发送"></a>2.2.2 数据位发送</h3><p>当SCL为高电平时读取的SDA信号为有效信号，SCL低电平为数据无效，所以通常用来SDA的高低电平的转换。</p>
<p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。进行数据传送时，<strong>在SCL呈现高电平期间，SDA上的电平必须保持稳定，低电平为数据0，高电平为数据1</strong>。<strong>只有在SCL为低电平期间，才允许SDA上的电平改变状态</strong>。逻辑0的电平为低电压，而逻辑1则为高电平。时序如下图所示</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699366722339.png" alt="1699366722339"></p>
<h2 id="2-3-工作原理"><a href="#2-3-工作原理" class="headerlink" title="2.3 工作原理"></a>2.3 工作原理</h2><p>I2C的数据传输是以多个msg的形式进行。每个msg包括：从机二进制地址帧、以及一个或者多个数据帧、开始条件和停止条件，读/写位和数据帧之间的ACK/NACK位：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699365343036.png" alt="1699365343036"></p>
<h2 id="2-4-总线连接"><a href="#2-4-总线连接" class="headerlink" title="2.4 总线连接"></a>2.4 总线连接</h2><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364921358.png" alt="1699364921358"></p>
<p>当总线空闲时，SDA 和SCL 都处于高电平状态，当主机要和某个从机通讯时，会先发送一个开始条件，然后发送从机地址和读写控制位，接下来传输数据（主机发送或者接收数据），数据传输结束时主机会发送停止条件。传输的每个字节为8 位，高位在前，低位在后。</p>
<p>　　　　• 开始条件： SCL 为高电平时，主机将SDA 拉低，表示数据传输即将开始。</p>
<p>　　　　• 从机地址： 主机发送的第一个字节为从机地址，高7 位为地址，<strong>最低位为R/W 读写控制位，1 表示读操作，0 表示写操作</strong>。一般从机地址有7 位地址模式和10 位地址模式两种，如果是10 位地址模式，第一个字节的头7 位是11110XX 的组合，其中最后两位（XX）是10 位地址的两个最高位，第二个字节为10 位从机地址的剩下8 位，如下图所示：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699364966732.png" alt="1699364966732"></p>
<p>• 应答信号： 每传输完成一个字节的数据，接收方就需要回复一个ACK（acknowledge）。写数据时由从机发送ACK，读数据时由主机发送ACK。当主机读到最后一个字节数据时，可发送NACK（Notacknowledge）然后跟停止条件。</p>
<p>　　　　• 数据： 从机地址发送完后可能会发送一些指令，依从机而定，然后开始传输数据，由主机或者从机发送，每个数据为8 位，数据的字节数没有限制。</p>
<p>　　　　• 重复开始条件： 在一次通信过程中，主机可能需要和不同的从机传输数据或者需要切换读写操作时，主机可以再发送一个开始条件。</p>
<p>　　　　• 停止条件： 在SDA 为低电平时，主机将SCL 拉高并保持高电平，然后在将SDA 拉高，表示传输结束。</p>
<h2 id="2-5-传输步骤"><a href="#2-5-传输步骤" class="headerlink" title="2.5 传输步骤"></a>2.5 传输步骤</h2><ol>
<li>在SCL线为高电平时，主机通过将SDA线从高电平切换到低电平来启动总线通信。</li>
<li>主机向总线发送要与之通信的从机的7位或10位地址，以及读/写位</li>
<li>每个从机将主机发送的地址与其自己的地址进行比较。如果地址匹配，则从机通过将SDA线拉低一位返回一个ACK位。如果主机的地址与从机的地址不匹配，则从机将SDA线拉高。</li>
<li>主机发送或接收数据帧；</li>
<li>传输完每个数据帧后，接收设备将另一个ACK位返回给发送方，以确认已成功接收到该帧；</li>
<li>随后主机将SCL切换为高电平，然后再将SDA切换为高电平，从而向从机发送停止条件。</li>
</ol>
<h2 id="2-6-I2C优点"><a href="#2-6-I2C优点" class="headerlink" title="2.6 I2C优点"></a>2.6 I2C优点</h2><p>1.仅仅使用两根线</p>
<p>2.支持多个主机和从机</p>
<p>3.硬件比UART更简单</p>
<h2 id="2-7-I2C缺点"><a href="#2-7-I2C缺点" class="headerlink" title="2.7 I2C缺点"></a>2.7 I2C缺点</h2><p><strong>1.数据传输比SPI慢</strong></p>
<p><strong>2.数据帧大小限制为8位</strong></p>
<h1 id="三、SPI总线（Serial-Peripheral-Interface）"><a href="#三、SPI总线（Serial-Peripheral-Interface）" class="headerlink" title="三、SPI总线（Serial Peripheral Interface）"></a>三、<strong>SPI总线（Serial Peripheral Interface）</strong></h1><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola（摩托罗拉）公司推出的一种同步串行接口技术，是一种高速的，全双工，同步的通信总线。SPI的特点就是传输熟读很快。</p>
<h2 id="3-1-硬件接口"><a href="#3-1-硬件接口" class="headerlink" title="3.1 硬件接口"></a>3.1 硬件接口</h2><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699367194316.png" alt="1699367194316"></p>
<p>（1）主设备出、从设备入（Master Out Slave In，MOSI）：由主设备向从设备传输数据的信号线，也称为从设备输入（Slave Input/Slave Data In，SI/SDI）。</p>
<p>（2）主设备入、从设备出（Master In Slave Out，MISO）：由从设备向主设备传输数据的信号线，也称为从设备输出（Slave Output/Slave Data Out，SO/SDO）。</p>
<p>（3）串行时钟（Serial Clock，SCLK）：传输时钟信号的信号线。</p>
<p>（4）从设备选择（Slave Select，SS）：用于选择从设备的信号线，低电平有效。</p>
<p>下图显示了单个主机和单个从机之间的典型SPI连接。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425195202.png" alt="1699425195202"></p>
<h2 id="3-2-通信原理"><a href="#3-2-通信原理" class="headerlink" title="3.2 通信原理"></a>3.2 通信原理</h2><h3 id="3-2-1-采用主-从模式-Master-Slave-的控制方式"><a href="#3-2-1-采用主-从模式-Master-Slave-的控制方式" class="headerlink" title="3.2.1 采用主-从模式(Master-Slave) 的控制方式"></a>3.2.1 采用主-从模式(Master-Slave) 的控制方式</h3><p>SPI 规定了两个 SPI 设备之间通信必须由主设备 (Master) 来控制次设备 (Slave). 一个 Master 设备可以通过提供 Clock 以及对 Slave 设备进行片选 (Slave Select) 来控制多个 Slave 设备, SPI 协议还规定 Slave 设备的 Clock 由 Master 设备通过 SCK 管脚提供给 Slave 设备, Slave 设备本身不能产生或控制 Clock, 没有 Clock 则 Slave 设备不能正常工作。</p>
<h3 id="3-2-2-采用同步方式-Synchronous-传输数据"><a href="#3-2-2-采用同步方式-Synchronous-传输数据" class="headerlink" title="3.2.2 采用同步方式(Synchronous)传输数据"></a>3.2.2 采用同步方式(Synchronous)传输数据</h3><p>Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse), 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过时钟极性 (CPOL) 和 时钟相位 (CPHA) 控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的.</p>
<h3 id="3-2-3-数据交换-Data-Exchanges"><a href="#3-2-3-数据交换-Data-Exchanges" class="headerlink" title="3.2.3 数据交换(Data Exchanges)"></a>3.2.3 数据交换(Data Exchanges)</h3><p>SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个 “发送者(Transmitter)” 或者 “接收者(Receiver)”. 在每个 Clock 周期内, SPI 设备都会发送并接收一个 bit 大小的数据, 相当于该设备有一个 bit 大小的数据被交换了。</p>
<p>一个 Slave 设备要想能够接收到 Master 发过来的控制信号, 必须在此之前能够被 Master 设备进行访问 (Access). 所以, Master 设备必须首先通过 SS/CS pin 对 Slave 设备进行片选, 把想要访问的 Slave 设备选上。</p>
<p>在数据传输的过程中, 每次接收到的数据必须在下一次数据传输之前被采样. 如果之前接收到的数据没有被读取, 那么这些已经接收完成的数据将有可能会被丢弃, 导致 SPI 物理模块最终失效. 因此, 在程序中一般都会在 SPI 传输完数据后, 去读取 SPI 设备里的数据, 即使这些数据(Dummy Data)在我们的程序里是无用的.</p>
<h2 id="3-3-SPI协议总结"><a href="#3-3-SPI协议总结" class="headerlink" title="3.3 SPI协议总结"></a>3.3 SPI协议总结</h2><ol>
<li>三根线（SDO,SDI,SCLK）1对1传输可以省CS.</li>
<li>全双工：这里的全双工可串口还不同，不能同时收发。SCLK由主机控制，从机不能主动给主机发数据。感觉类似半工。</li>
<li>数据发送位数没有要求，而且可以中断发送然后续上。</li>
<li>一个上降沿+上升沿为1个数据。</li>
<li>没有应答机制，也没有硬件校验机制。</li>
<li>可以1主多从，靠CS片选使能。</li>
<li>同步通信。</li>
<li>速度可达几Mbps</li>
</ol>
<p>SPI 协议定义了通信的起始信号、停止信号、数据有效性、时钟同步等。它的通讯时序如下：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426049687.png" alt="1699426049687"></p>
<p>这是一个主机的通信时序，信号线 NSS、SCK、MOSI 都是由主机控制，MISO 是由从机进行控制。其中 MOSI 和 MISO 上的数据仅在 NSS 为低时才有效，并且每个SCK 时钟周期只交换一位数据。</p>
<p>他的每一部分组成分别如下：</p>
<p>（1）起始信号</p>
<p>SPI通信时序图中的①为通信的起始信号，由主机控制NSS从高电平到低电平，从而选择要进行通信的从机，再通过主机产生时钟信号SCK，启动一次数据的传输。如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426093533.png" alt="1699426093533"></p>
<p>（2）停止信号</p>
<p>SPI通信时序图中的⑥为通信的起始信号，由主机控制NSS从低电平到高电平，从而结束一次数据的传输。如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426118135.png" alt="1699426118135"></p>
<p>（3）数据有效性</p>
<p>SPI 在 SCK 时钟的同步下进行数据的准备和采样，如通信时序图的②③④⑤所示。在 NSS 为低的情况时，在 SCK 的上升沿时 MISO 和 MOSI 进行数据准备，SCK 的下降沿时读取 MISO 和 MOSI 上的数据。在 NSS 为高时，MISO 和MOSI 上的数据无效。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426132247.png" alt="1699426132247"></p>
<p>（4）时钟的同步</p>
<p>SPI 的数据传输是需要 SCK 时钟信号严格同步的，每一个 SCK 周期只传输一位数据，这一个周期里要完成数据的准备和采样，且数据的输入和输出是同时进行的。如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426147469.png" alt="1699426147469"></p>
<p>SPI中数据是MSB(高位) 先行或 LSB(低位)先行，在协议中是没有硬性规定，只需通信双方保持统一即可。</p>
<p>注意：SPI 一次数据传输可以是 8 位或 16 位为单位，每次传输的单位数不受限制。</p>
<h2 id="3-4-传输过程"><a href="#3-4-传输过程" class="headerlink" title="3.4 传输过程"></a>3.4 传输过程</h2><ul>
<li>主机先将 <code>NSS</code>信号拉低，这样保证开始接收数据；</li>
<li>当<strong>接收端</strong>检测到时钟的边沿信号时，它将立即读取<strong>数据线</strong>上的信号，这样就得到了一位数据（1 <code>bit</code>）;<br>由于时钟是随数据一起发送的，因此指定 <strong>数据的传输速度并不重要</strong> ，尽管设备将具有可以运行的最高速度（稍后我们将讨论选择合适的时钟边沿和速度）。</li>
<li><strong>主机</strong>发送到<strong>从机</strong>时：主机产生相应的时钟信号，然后数据<strong>一位一位</strong>地将从 <code>MOSI</code>信号线上进行发送到从机；</li>
<li><strong>主机</strong>接收<strong>从机</strong>数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过 <code>MISO</code>信号线发送；</li>
</ul>
<p>具体如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425109015.png" alt="1699425109015"></p>
<blockquote>
<p>注意，SPI是“全双工”（具有单独的发送和接收线路），因此可以在同一时间发送和接收数据，另外SPI的接收硬件可以是一个简单的移位寄存器。这比异步串行通信所需的完整UART要简单得多，并且更加便宜；</p>
</blockquote>
<h2 id="3-5-SPI时钟"><a href="#3-5-SPI时钟" class="headerlink" title="3.5 SPI时钟"></a>3.5 SPI时钟</h2><h3 id="3-5-1-时钟极性-CKP-Clock-Polarity"><a href="#3-5-1-时钟极性-CKP-Clock-Polarity" class="headerlink" title="3.5.1 时钟极性 CKP/Clock Polarity"></a>3.5.1 时钟极性 CKP/Clock Polarity</h3><p>除了配置串行时钟速率（频率）外，SPI主设备还需要配置 <strong>时钟极性</strong> 。</p>
<p>根据硬件制造商的命名规则不同，时钟极性通常写为<strong>CKP</strong>或 <strong>CPOL</strong> 。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据；</p>
<p><strong>CKP</strong>可以配置为1或0。这意味着您可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。您必须参考设备的数据手册才能正确设置CKP和CKE。</p>
<ul>
<li><code>CKP = 0</code>：时钟空闲 <code>IDLE</code>为低电平 <code>0</code>；</li>
<li><code>CKP = 1</code>：时钟空闲 <code>IDLE</code>为高电平 <code>1</code>；</li>
</ul>
<h3 id="3-5-2-时钟相位-CKE-Clock-Phase-Edge"><a href="#3-5-2-时钟相位-CKE-Clock-Phase-Edge" class="headerlink" title="3.5.2 时钟相位 CKE /Clock Phase (Edge)"></a><strong>3.5.2 时钟相位 CKE /Clock Phase (Edge)</strong></h3><p>除配置串行时钟速率和极性外，SPI主设备还应配置时钟相位（或边沿）。根据硬件制造商的不同，时钟相位通常写为<strong>CKE</strong>或 <strong>CPHA</strong> ；</p>
<p>顾名思义，时钟相位/边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；</p>
<ul>
<li><code>CKE = 0</code>：在时钟信号 <code>SCK</code>的第一个跳变沿采样；</li>
<li><code>CKE = 1</code>：在时钟信号 <code>SCK</code>的第二个跳变沿采样；</li>
</ul>
<h3 id="3-5-3-时钟配置总结"><a href="#3-5-3-时钟配置总结" class="headerlink" title="3.5.3 时钟配置总结"></a><strong>3.5.3 时钟配置总结</strong></h3><p>综上几种情况，下图总结了所有时钟配置组合，并突出显示了实际采样数据的时刻；</p>
<blockquote>
<p>其中黑色线为采样数据的时刻；<br>蓝色线为SCK时钟信号；</p>
</blockquote>
<p>具体如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425267948.png" alt="1699425267948"></p>
<h3 id="3-5-4-模式编号"><a href="#3-5-4-模式编号" class="headerlink" title="3.5.4 模式编号"></a><strong>3.5.4 模式编号</strong></h3><p>SPI的时钟极性和相位的配置通常称为  <strong>SPI模式</strong> ，所有可能的模式都遵循以下约定；具体如下表所示；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>SPI Mode</th>
<th>CPOL</th>
<th>CPHA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 [00]</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 [01]</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 [10]</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3 [11]</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，我们还应该仔细检查微控制器数据手册中包含的模式表，以确保一切正常。</p>
<h2 id="3-6-总线结构"><a href="#3-6-总线结构" class="headerlink" title="3.6 总线结构"></a>3.6 总线结构</h2><h3 id="3-6-1-单从机模式"><a href="#3-6-1-单从机模式" class="headerlink" title="3.6.1 单从机模式"></a>3.6.1 单从机模式</h3><p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425967885.png" alt="1699425967885"></p>
<h3 id="3-6-2-多从机模式"><a href="#3-6-2-多从机模式" class="headerlink" title="3.6.2 多从机模式"></a>3.6.2 <strong>多从机模式</strong></h3><p>前面说到SPI总线必须有一个主机，可以有多个从机，那么具体连接到SPI总线的方法有以下两种：</p>
<h4 id="多NSS"><a href="#多NSS" class="headerlink" title="多NSS"></a><strong>多NSS</strong></h4><ol>
<li>通常，每个从机都需要一条单独的SS线。</li>
<li>如果要和特定的从机进行通讯，可以将相应的 <code>NSS</code>信号线拉低，并保持其他 <code>NSS</code>信号线的状态为高电平；如果同时将两个 <code>NSS</code>信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条 <code>MISO</code>线上传输数据，最终导致接收数据乱码。</li>
</ol>
<p>具体连接方式如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425587349.png" alt="1699425587349"></p>
<h4 id="菊花链"><a href="#菊花链" class="headerlink" title="菊花链"></a><strong>菊花链</strong></h4><p>在数字通信世界中，在设备信号（总线信号或中断信号）以串行的方式从一 个设备依次传到下一个设备，不断循环直到数据到达目标设备的方式被称为 <strong>菊花链</strong> 。</p>
<ol>
<li>菊花链的最大缺点是因为是信号串行传输，所以一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了；</li>
<li>另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况；</li>
</ol>
<p>具体的连接如下图所示；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425637860.png" alt="1699425637860"></p>
<blockquote>
<p>其中红线加粗为数据的流向；</p>
</blockquote>
<p>所以最终的数据流向图可以表示为：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699425667413.png" alt="1699425667413"></p>
<blockquote>
<p>SCK为时钟信号，8clks表示8个边沿信号；<br>其中D为数据，X为无效数据；</p>
</blockquote>
<p>所以不难发现，菊花链模式充分使用了SPI其移位寄存器的功能，整个链充当通信移位寄存器，每个从机在下一个时钟周期将输入数据复制到输出。</p>
<h2 id="3-7-优缺点"><a href="#3-7-优缺点" class="headerlink" title="3.7 优缺点"></a><strong>3.7 优缺点</strong></h2><h3 id="SPI通讯的优势"><a href="#SPI通讯的优势" class="headerlink" title="SPI通讯的优势"></a><strong>SPI通讯的优势</strong></h3><p>使SPI作为串行通信接口脱颖而出的原因很多；</p>
<ul>
<li>全双工串行通信；</li>
<li>高速数据传输速率。</li>
<li>简单的软件配置；</li>
<li>极其灵活的数据传输，不限于8位，它可以是任意大小的字；</li>
<li>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器/晶振（与UART不同）。不需要收发器（与CAN不同）。</li>
</ul>
<h3 id="SPI的缺点"><a href="#SPI的缺点" class="headerlink" title="SPI的缺点"></a><strong>SPI的缺点</strong></h3><ul>
<li>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；</li>
<li>通常仅支持一个主设备；</li>
<li>需要更多的引脚（与I2C不同）；</li>
<li>没有定义硬件级别的错误检查协议；</li>
<li>与RS-232和CAN总线相比，只能支持非常短的距离；</li>
</ul>
<h1 id="四、Can"><a href="#四、Can" class="headerlink" title="四、Can"></a>四、Can</h1><h2 id="4-1-CAN基础知识"><a href="#4-1-CAN基础知识" class="headerlink" title="4.1 CAN基础知识"></a>4.1 CAN基础知识</h2><h3 id="4-1-1-CAN的一些基本概念"><a href="#4-1-1-CAN的一些基本概念" class="headerlink" title="4.1.1 CAN的一些基本概念"></a>4.1.1 CAN的一些基本概念</h3><p>什么是CAN总线</p>
<p>CAN 是 Controller Area Network 的缩写，是 ISO 国际标准化的串行通信协议。通俗来讲，CAN总线就是一种传输数据的线，用于在不同的ECU之间传输数据。<br>CAN总线有两个ISO国际标准：ISO11898 和 ISO11519。其中：</p>
<p>ISO11898 定义了通信速率为 125 kbps～1 Mbps 的高速 CAN 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米。<br>ISO11519 定义了通信速率为 10～125 kbps 的低速 CAN 通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米。</p>
<blockquote>
<p>Tips: &lt;总线的传输速率&gt;：又称为总线的通信速率，指的是位速率。或称为比特率（和波特率不是一回事），表示的是：单位时间内，通信线路上传输的二进制位的数量，其基本单位是 bps 或者 b/s (bit per second)。</p>
</blockquote>
<h3 id="4-1-2-Can物理层"><a href="#4-1-2-Can物理层" class="headerlink" title="4.1.2 Can物理层"></a>4.1.2 Can物理层</h3><p>与I2C、SPI等具有时钟信号的同步通讯方式不同，CAN通讯并不是以时钟信号来进行同步的，它是一种异步通讯，只具有CAN_High和CAN_Low两条信号线，共同构成一组差分信号线，<strong>以差分信号的形式进行通讯。</strong></p>
<h3 id="4-1-3-总线网络"><a href="#4-1-3-总线网络" class="headerlink" title="4.1.3 总线网络"></a><strong>4.1.3 总线网络</strong></h3><p>CAN物理层的形式主要有两种：</p>
<p>高速模式（125k～1m）</p>
<p>低速模式（10k～125k）</p>
<p>下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426788263.png" alt="1699426788263"></p>
<p>如图中所示，CAN总线包括CAN_H 和 CAN_L 两根线。节点通过<strong>CAN控制器</strong>和<strong>CAN收发器</strong>连接到CAN总线上。</p>
<h3 id="4-1-4-can信号表示"><a href="#4-1-4-can信号表示" class="headerlink" title="4.1.4 can信号表示"></a>4.1.4 can信号表示</h3><p>在CAN总线上，利用CAN_H和CAN_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为<strong>显性电平</strong>和 <strong>隐性电平</strong> 。其中<strong>显性电平</strong>为逻辑 <strong>0</strong> ，<strong>隐性电平</strong>为逻辑 <strong>1</strong> 。</p>
<p>ISO11898标准（125kbps ~ 1Mbps）和ISO11519标准（10kbps ~ 125kbps）中CAN信号的表示分别如下所示：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426829639.png" alt="1699426829639"></p>
<h3 id="4-1-5-can信号传输"><a href="#4-1-5-can信号传输" class="headerlink" title="4.1.5 can信号传输"></a>4.1.5 can信号传输</h3><p><strong>发送过程：</strong></p>
<p>CAN控制器将CPU传来的信号转换为逻辑电平（即<strong>逻辑0-显性电平</strong>或者 <strong>逻辑1-隐性电平</strong> ）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426937008.png" alt="1699426937008"></p>
<p><strong>接收过程：</strong></p>
<p>CAN接收器将CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到CAN控制器，CAN控制器再把该逻辑电平转化为相应的信号发送到CPU上。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699426950445.png" alt="1699426950445"></p>
<p>概括的讲：</p>
<ul>
<li>发送方通过 <strong>使总线电平发生变化</strong> ，将其信息传递到CAN总线上。</li>
<li>接收方通过监听总线电平，将总线上的消息读入自己的接收器。</li>
</ul>
<h2 id="4-2-can通信的特点"><a href="#4-2-can通信的特点" class="headerlink" title="4.2 can通信的特点"></a>4.2 can通信的特点</h2><h3 id="4-2-1-多主工作方式"><a href="#4-2-1-多主工作方式" class="headerlink" title="4.2.1 多主工作方式"></a>4.2.1 <strong><strong>多主工作方式</strong></strong></h3><p>所谓多主工作方式，指的是：总线上的所有节点没有主从之分，大家都处于平等的地位。反应在数据传输上，即是：在总线空闲状态，任意节点都可以向总线上发送消息。</p>
<blockquote>
<p><strong>&lt;总线空闲状态&gt;</strong> ：</p>
<p>Tips:</p>
<p>当总线上的上出现 <strong>连续的11位隐性电平</strong> ，那么总线就处于空闲状态。也就是说对于任意一个节点而言，只要它监听到总线上连续出现了11位隐性电平，那么该节点就会认为总线当前处于空闲状态，它就会立即向总线上发送自己的报文。 至于为什么连续出现11位隐性电平，就可以判定+总线处于空闲状态，这个问题可以结合CAN协议的帧结构来进行理解。</p>
</blockquote>
<p>在多主工作方式下：</p>
<ul>
<li><p>最先向总线发送消息的节点获得总线的发送权；</p>
</li>
<li><p>当多个节点同时向总线发送消息时，所发送消息的优先权高的那个节点获得总线的发送权。</p>
<blockquote>
<p>例如：Node_A和Node_B同时向总线发送各自的消息Msg_1和Msg_2，如果Msg_1的优先级比Msg_2高，那么Node_A就获得了总线的发送权。</p>
</blockquote>
</li>
</ul>
<h3 id="4-2-2-非破坏性位仲裁机制"><a href="#4-2-2-非破坏性位仲裁机制" class="headerlink" title="4.2.2 非破坏性位仲裁机制"></a><strong><strong>4.2.2 非破坏性位仲裁机制</strong></strong></h3><p>在CAN协议中，所有的消息都以固定的帧格式发送。当多个节点同时向总线发送消息时，对各个消息的标识符（即ID号）进行 <strong>逐位仲裁</strong> ，如果某个节点发送的消息仲裁获胜，那么这个节点将获取总线的发送权，仲裁失败的节点则立即停止发送并转变为监听（接收）状态。</p>
<blockquote>
<p>例如：Node_A和Node_B同时向总线发送各自的消息Msg_1和Msg_2，那么对Msg_1的ID号ID_1和Msg_2的ID号ID_2进行逐位仲裁，如果仲裁结果是：ID_1的优先级比ID_2高，那么Msg_1在仲裁中获胜，于是发出Msg_1这条报文的节点Node_A就获得了总线的发送权。同时，Msg_2在仲裁中失败，于是Node_B就转换到监听总线电平的状态。</p>
</blockquote>
<p>这种仲裁机制既 <strong>不会造成已发送数据的延迟</strong> ，也<strong>不会破坏已经发送的数据</strong>，所以称为非破坏性仲裁机制。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40528417/article/details/79534483">https://blog.csdn.net/weixin_40528417/article/details/79534483</a></p>
<h3 id="4-2-3-系统的柔性"><a href="#4-2-3-系统的柔性" class="headerlink" title="4.2.3 系统的柔性"></a><strong><strong>4.2.3 系统的柔性</strong></strong></h3><p>CAN总线上的节点 <strong>没有“地址”的概念</strong> ，因此在总线上增加节点时，不会对总线上已有节点的软硬件及应用层造成影响。</p>
<h3 id="4-2-4-通信速度"><a href="#4-2-4-通信速度" class="headerlink" title="4.2.4 通信速度"></a><strong><strong>4.2.4 通信速度</strong></strong></h3><p>在同一条CAN线上，所有节点的通信速度（位速率）必须相同，如果两条不同通信速度总线上的节点想要实现信息交互，必须通过网关。</p>
<blockquote>
<p>例如：汽车上一般有两条CAN总线：500kbps的驱动系统CAN总线和125kbps的舒适系统CAN总线，如果驱动系统CAN总线上的发动机节点要把自己的转速信息发送给舒适系统CAN总线上的转速表节点，那么这两条总线必须通过网关相连。</p>
</blockquote>
<h3 id="4-2-5-数据传输方式"><a href="#4-2-5-数据传输方式" class="headerlink" title="4.2.5 数据传输方式"></a><strong><strong>4.2.5 数据传输方式</strong></strong></h3><p>CAN总线可以实现一对一，一对多以及广播的数据传输方式，这依赖于验收滤波技术。</p>
<h3 id="4-2-6-远程数据请求"><a href="#4-2-6-远程数据请求" class="headerlink" title="4.2.6 远程数据请求"></a><strong><strong>4.2.6 远程数据请求</strong></strong></h3><p>某个节点Node_A可以通过发送“遥控帧”到总线上的方式，请求某个节点Node_B来发送由该遥控帧所指定的报文。</p>
<h3 id="4-2-7-错误检测、错误通知、错误恢复功能"><a href="#4-2-7-错误检测、错误通知、错误恢复功能" class="headerlink" title="4.2.7 错误检测、错误通知、错误恢复功能"></a><strong><strong>4.2.7 错误检测、错误通知、错误恢复功能</strong></strong></h3><ul>
<li>所有的节点都可以检测出错误（错误检测功能）；</li>
<li>检测出错误的节点会立即通知总线上其它所有的节点（错误通知功能）；</li>
<li>正在发送消息的节点，如果检测到错误，会立即停止当前的发送，并在同时不断地重复发送此消息，直到该消息发送成功为止（错误恢复功能）。</li>
</ul>
<h3 id="4-2-8-故障封闭"><a href="#4-2-8-故障封闭" class="headerlink" title="4.2.8 故障封闭"></a><strong><strong>4.2.8 故障封闭</strong></strong></h3><p>节点能够判断错误的类型，判断是暂时性的数据错误（如噪声干扰）还是持续性的数据错误（如节点内部故障），如果判断是严重的持续性错误，那么节点就会切断自己与总线的联系，从而避免影响总线上其他节点的正常工作。</p>
<h2 id="4-3-CAN通信网络结构"><a href="#4-3-CAN通信网络结构" class="headerlink" title="4.3 CAN通信网络结构"></a><strong><strong>4.3 CAN通信网络结构</strong></strong></h2><h3 id="4-3-1-OSI基本参照模型"><a href="#4-3-1-OSI基本参照模型" class="headerlink" title="4.3.1 OSI基本参照模型"></a>4.3.1 OSI基本参照模型</h3><p>实际上，CAN总线网络底层只采用了OSI基本参照模型中的 <strong>数据链路层、传输层</strong> 。而在CAN网络高层仅采用了OSI基本参照模型的<strong>应用层。</strong></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699427783878.png" alt="1699427783878"></p>
<h3 id="4-3-2-CAN协议网络层次"><a href="#4-3-2-CAN协议网络层次" class="headerlink" title="4.3.2 CAN协议网络层次"></a>4.3.2 CAN协议网络层次</h3><p>在CAN协议中，ISO标准只对数据链路层和物理层做了规定。对于数据链路层和物理层的一部分，ISO11898和ISO11519-2的规定是相同，但是在物理层的PMD子层和MDI子层是不同的。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699427842349.png" alt="1699427842349"></p>
<p>在CAN总线，每一层网络中定义的事项如下：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699427852421.png" alt="1699427852421"></p>
<h2 id="4-4-CAN协议数据帧与遥控帧"><a href="#4-4-CAN协议数据帧与遥控帧" class="headerlink" title="4.4 CAN协议数据帧与遥控帧"></a>4.4 CAN协议数据帧与遥控帧</h2><h3 id="4-4-1-CAN-协议中的帧"><a href="#4-4-1-CAN-协议中的帧" class="headerlink" title="4.4.1 CAN 协议中的帧"></a>4.4.1 CAN 协议中的帧</h3><p>在了解<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CAN%E6%80%BB%E7%BA%BF&amp;spm=1001.2101.3001.7020">CAN总线</a>的通信机制之前，首先需要了解CAN协议中五种类型的帧结构：</p>
<ul>
<li>数据帧</li>
<li>遥控帧</li>
<li>错误帧</li>
<li>过载帧</li>
<li>帧间隔</li>
</ul>
<h3 id="4-4-2-数据帧与遥控帧"><a href="#4-4-2-数据帧与遥控帧" class="headerlink" title="4.4.2 数据帧与遥控帧"></a>4.4.2 数据帧与遥控帧</h3><p>在CAN协议中，数据帧和遥控帧有着诸多相同之处，所以，在这里，我们将数据帧和遥控帧放在一起来讲。</p>
<p>顾名思义，所谓数据帧，就是包含了我们要传输的<strong>数据</strong>的帧，其作用当然也就是承载发送节点要传递给接收节点的数据。</p>
<p>而遥控帧的作用可以描述为：请求其它节点发出与本遥控帧具有相同ID号的数据帧。</p>
<blockquote>
<p>比如：在某一个时刻，节点Node_A向总线发送了一个ID号为ID_2的遥控帧，那么就意味着Node_A请求总线上的其他节点发送ID号为ID_2的数据帧。</p>
<p>节点Node_B能够发出ID号为ID_2的数据帧，那么Node_B就会在收到Node_A发出的遥控帧之后，立刻向总线上发送ID号为ID_2的数据帧。</p>
</blockquote>
<p><strong><em>数据帧</em></strong><br> 的帧结构如下图所示，包含七个段： <strong>帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束</strong> 。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428188563.png" alt="1699428188563"></p>
<p><strong><em>遥控帧</em></strong><br> 相比于数据帧，从帧结构上来看，只是 <strong>少了数据段</strong> ，包含六个段：<strong>帧起始、仲裁段、控制段、CRC段、ACK段、帧结束。</strong></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428208177.png" alt="1699428208177"></p>
<p>数据帧和遥控帧都分为<strong>标准帧（CAN2.0A）</strong>和<strong>扩展帧（CAN2.0B）</strong>两种结构。</p>
<p>遥控帧相比于数据帧除了<strong>缺少数据段</strong>之外， <strong>遥控帧的RTR位恒为隐性1，数据帧的RTR位恒为显性0</strong> 。</p>
<h4 id="4-4-2-1-帧起始"><a href="#4-4-2-1-帧起始" class="headerlink" title="4.4.2.1 帧起始"></a><strong><strong>4.4.2.1 帧起始</strong></strong></h4><p>帧的最开始的一位是 <strong>帧起始</strong> ，也叫SOF（Start Of Frame）， <strong>SOF恒为显性位</strong> ，即逻辑 0 。帧起始表示CAN_H 和 CAN_L上有了电位差，也就是说，一旦总线上有了SOF就表示总线上开始有报文了。</p>
<h4 id="4-4-2-2-仲裁段"><a href="#4-4-2-2-仲裁段" class="headerlink" title="4.4.2.2 仲裁段"></a><strong><strong>4.4.2.2 仲裁段</strong></strong></h4><p> <strong>仲裁段是用来判定一帧报文优先级的依据，仲裁段中的ID号也是实现报文过滤机制的基础</strong> 。仲裁段由以下几个部分组成，</p>
<p>数据帧仲裁段：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428441065.png" alt="1699428441065"></p>
<p>遥控帧仲裁段：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428453749.png" alt="1699428453749"></p>
<p>可以看到相比于数据帧仲裁段RTR位恒为显性0，遥控帧仲裁段的RTR位恒为隐性1。</p>
<h5 id="4-4-2-2-1仲裁过程"><a href="#4-4-2-2-1仲裁过程" class="headerlink" title="4.4.2.2.1仲裁过程"></a><strong><strong>4.4.2.2.1仲裁过程</strong></strong></h5><p>在CAN总线通信中，有一种 <strong>回读机制</strong> ：指的是节点在向总线上发送报文的过程中，同时也对总线上的二进制位进行“回读”。通过这种机制，节点就可以判断出<strong>本节点发出的二进制位</strong>与<strong>总线上当前的二进制位</strong>是否一致。</p>
<p>还有一种叫做 <strong>线与机制</strong> ：指的是在总线上， <strong>显性位能够覆盖隐性位</strong> 。</p>
<blockquote>
<p>举个例子：在某一个时刻，节点Node_A向总线发送了一个显性位0，Node_B向总线发送了一个隐性位1，那么在该时刻，总线上的电平为显性0。</p>
</blockquote>
<p>下面将以<strong>标准数据帧</strong>的一个例子来分析CAN总线的 <strong>非破坏性逐位仲裁机制</strong> 。</p>
<p>一条CAN总线上有Node_A 和 Node_B两个节点，在<strong>总线空闲</strong>时，总线上为 <strong>隐性电平</strong> ，就在这个时候Node_A 和 Node_B 这两个节点同时向总线上发送数据，如下图：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428640425.png" alt="1699428640425"></p>
<p>从图中可以看出，在Node_A 和 Node_B 传输数据前，总线处于空闲状态，为隐性电平1，这也就意味着，此时总线上的任意节点都可以向总线发送数据。</p>
<p>在某一时刻，Node_A 和Node_B两个节点同时向总线上发送数据。按照</p>
<p> <strong>线与机制</strong> ，总线上的电位为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>节点/ID号</th>
<th>ID10</th>
<th>ID9</th>
<th>ID8</th>
<th>ID7</th>
<th>ID6</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node-A</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
<tr>
<td>Node-B</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>总线</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>在Node_A和Node_B两个节点向总线发送数据时，他们同时回读总线上的电平。从图中我们可以看到，Node_A 和Node_B的ID10 、ID9、ID8电位相同，因此这两个节点从总线上听到的电位与他们自己发出的电位也相同，这个时候还没有分出胜负。</p>
<p>当Node_B回读总线上的 ID7 这一位时，发现总线上的电平跟它自己发送到总线上的不一样，此时，Node_B知道自己在争夺总线的仲裁中失败了，那么它主动地转换为接收状态，不再发出信息。</p>
<p>于是在此之后，总线上的电平和Node_A发出的电平一致，也就是说，Node_A占据了总线的发送权。</p>
<p>通过上面的分析我们可以看到，在整个仲裁过程中：</p>
<ul>
<li>在Node_A获取总线的发送权之后，Node_A接着发送自己的Msg_A，因此在竞争总线的过程中不会对Msg_A的传输造成延时；</li>
<li>在两个节点竞争总线的过程中，不会破坏Msg_A;</li>
</ul>
<p>正是由于上面的两点，才称之为<strong>非破坏性仲裁机制。</strong></p>
<blockquote>
<p>Tips:</p>
<p>通过上面仲裁过程的分析，我们可以解释CAN总线通信的三个特点：</p>
<p>1）多主控制方式：只要总线空闲，总线上的任意节点都可以向总线上发送数据，直到节点在仲裁中一个个失败，最后只留下一个节点获得总线的发送权。</p>
<p>2）非破坏性仲裁机制：仲裁段逐位总裁，依靠<strong>回读机制、线与机制</strong>得以实现。</p>
<p>3）半双工通信：所谓半双工通信，指的是节点不能在自己发送报文的时候，同时接收其他节点发送来的报文。这是显然的，一个节点正在发送报文时，已经占据了总线的发送权，其他节点肯定不能向总线上发送报文。</p>
</blockquote>
<p>看一个CAN报文发送的实例，CAN总线上有四个节点：Node_A、Node_B、Node_C、Node_D。发送的报文的ID号分别为5、7、3、6.</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428658091.png" alt="1699428658091"></p>
<h5 id="4-4-2-2-2-仲裁段中的RTR，SRR和IDE位"><a href="#4-4-2-2-2-仲裁段中的RTR，SRR和IDE位" class="headerlink" title="4.4.2.2.2 仲裁段中的RTR，SRR和IDE位"></a><strong><strong>4.4.2.2.2 仲裁段中的RTR，SRR和IDE位</strong></strong></h5><p>通过上面标准数据帧的仲裁过程分析，我们已经理解了CAN总线的仲裁机制。但同时也注意到仲裁段除了ID号之外，还有其他的位。</p>
<p><strong><strong>1）RTR位：</strong></strong></p>
<p>Tranmission Request Bit （远程发送请求位）。<strong>在数据帧中，RTR位恒为显性位0，在遥控帧中，恒为隐性1。</strong></p>
<blockquote>
<p>Tips: 这么做的原因是保证数据帧优先级高于遥控帧。比如：在某一时刻t，节点Node_A发出了ID号为ID_2遥控帧报文来请求总线上的其它节点发出ID号为ID_2的数据帧报文。但是就在同一时刻t，节点Node_B发出了ID号为ID_2的数据帧报文。这个时候怎么办呢，显然依靠ID号不能仲裁出这两帧报文（一个遥控帧，一个数据帧，ID号相同）谁能占据总线的发送权，这种情况下，RTR位就起作用了，由于RTR在数据帧中恒为显性0，在遥控帧中恒为隐性1，所以在ID号相同的情况下，一定是数据帧仲裁获胜。这就解释了 <strong>RTR位的作用：在ID号相同的情况下，保证数据帧的优先级高于遥控帧。</strong></p>
</blockquote>
<p><strong><strong>2）SRR位</strong></strong></p>
<p>Substitutes for Remote Requests Bit（替代远程请求位）， <strong>在扩展帧（数据帧或遥控帧）中，SRR恒为隐性位1</strong> ，并且可以发现，扩展帧的隐性SRR位正好对应标准帧的显性RTR位，这就解释了  <strong>SRR位的作用：在前11位ID号相同的情况下，标准数据帧的优先级高于扩展数据帧</strong> ；</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428855183.png" alt="1699428855183"></p>
<p><strong><strong>3）IDE位</strong></strong></p>
<p>全称：Identifier Extension Bit（标识符扩展位）。 <strong>在扩展帧中恒为隐性1，在标准帧中，IDE位于控制段，且恒为显性0</strong> 。且扩展帧IDE位和标准帧IDE位位置对应，这就保证了：  <strong>在前11位ID号相同的情况下，标准遥控帧的优先级一定高于扩展遥控帧</strong> 。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428869501.png" alt="1699428869501"></p>
<p><strong>总结：</strong> 在ID号前11位相同的情况下：</p>
<ul>
<li>RTR：保证数据帧优先级高于遥控帧；</li>
<li>SRR ：保证标准数据帧的优先级高于扩展数据帧。</li>
<li>IDE ：保证标准遥控帧的优先级高于扩展遥控帧。</li>
</ul>
<h5 id="4-4-2-2-3-报文过滤"><a href="#4-4-2-2-3-报文过滤" class="headerlink" title="4.4.2.2.3 报文过滤"></a><strong><strong>4.4.2.2.3 报文过滤</strong></strong></h5><p>在CAN总线中<strong>没有地址</strong>的概念，CAN总线是通过<strong>报文ID</strong>来实现收发数据的。CAN节点上都会有一个 <strong>验收滤波ID表</strong> ，其位于CAN节点的验收滤波器中，如果总线上的报文的ID号在某个节点的验收滤波ID表中，那么这一帧报文就能通过该节点验收滤波器的验收，该节点就会接收这一帧报文。</p>
<blockquote>
<p>比如：Node_A发送了一帧ID号为ID_1的报文Msg_1，Node_B的验收滤波ID表中恰好有ID_1，于是乎Msg_1就会被Node_B接收。</p>
<p>Tips:</p>
<p>报文过滤机制体现了CAN通信的两条特点： 1）一对一、组播和广播 2）系统的柔性：正是因为CAN总线上收发报文是基于报文ID实现的，所以总线上添加节点时不会对总线上已有的节点造成影响。</p>
</blockquote>
<h4 id="4-4-2-3-控制段"><a href="#4-4-2-3-控制段" class="headerlink" title="4.4.2.3 控制段"></a><strong><strong>4.4.2.3 控制段</strong></strong></h4><p>数据帧和遥控帧的控制段结构相同：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428891064.png" alt="1699428891064"></p>
<ul>
<li>标准帧中IDE位对应扩展帧中的IDE位，保证在前11位ID号相同的情况下，标准帧的优先级一定高于扩展帧；</li>
<li>然后是保留位r0和r1（扩展帧），保留位r0和r1必须以显性电平发送，但是接受方可以接受显性、隐性及其任意组合的电平；</li>
<li>最后是4个字节的 <strong>DLC</strong> （DLC3、DLC2、DLC1、DLC0）代表数据长度，指示了 <strong>数据段中的字节数</strong> 。对于没有数据段的遥控帧，DLC表示该遥控帧对应的数据帧的数据段的字节数。</li>
</ul>
<h4 id="4-4-2-4-数据段"><a href="#4-4-2-4-数据段" class="headerlink" title="4.4.2.4 数据段"></a><strong><strong>4.4.2.4 数据段</strong></strong></h4><p>数据段可以包含0~8个字节的数据，从MSB（最高位）开始输出。</p>
<h4 id="4-4-2-5-CRC段"><a href="#4-4-2-5-CRC段" class="headerlink" title="4.4.2.5 CRC段"></a><strong><strong>4.4.2.5 CRC段</strong></strong></h4><p>CRC段包含CRC校验序列和CRC界定符</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428900186.png" alt="1699428900186"></p>
<p><strong>CRC校验序列</strong>是根据多项式生成的CRC值， <strong>其计算范围包括：帧起始、仲裁段、控制段和数据段。CRC界定符恒为隐性1</strong> 。</p>
<h4 id="4-4-2-6-ACK段"><a href="#4-4-2-6-ACK段" class="headerlink" title="4.4.2.6 ACK段"></a><strong><strong>4.4.2.6 ACK段</strong></strong></h4><p>ACK段包含<strong>ACK槽</strong>和<strong>ACK界定符</strong>两个位。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428911314.png" alt="1699428911314"></p>
<ul>
<li><strong>发送节点</strong>在ACK段发送 <strong>两个隐性位</strong> ，即发送方发出的报文中ACK槽为隐性1；</li>
<li><strong>接收节点</strong>在接收到正确的报文之后会在ACK槽发送显性位0，通知发送节点正常接收结束。所谓接收到正确的报文指的是接收到的报文没有填充错误、格式错误、CRC错误。</li>
</ul>
<blockquote>
<p>Tips: 我们以标准数据帧为例来分析 <strong>ACK段的工作方式</strong> ：如图所示，Node_A为发送节点，Node_B为接收节点。Node_A在ACK段发送两个隐性位1。Node_B正确接收到这一报文后，在ACK段的ACK槽中填充了一个显性位0。注意，这个时候 <strong>Node_A回读到的总线上的额电平为显性0</strong> ，于是这个时候，Node_A就知道自己发出去的报文至少有一个节点正确接收了。</p>
</blockquote>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1699428924845.png" alt="1699428924845"></p>
<h4 id="4-4-2-7-帧结束"><a href="#4-4-2-7-帧结束" class="headerlink" title="4.4.2.7 帧结束"></a><strong>4.4.2.7 帧结束</strong></h4><p>帧结束段表示该帧报文的结束，由7个隐性位构成。</p>
<h2 id="4-5-CAN协议错误帧"><a href="#4-5-CAN协议错误帧" class="headerlink" title="4.5 CAN协议错误帧"></a>4.5 CAN协议错误帧</h2><h3 id="4-5-1-错误帧的帧结构"><a href="#4-5-1-错误帧的帧结构" class="headerlink" title="4.5.1 错误帧的帧结构"></a><strong><strong>4.5.1 错误帧的帧结构</strong></strong></h3><p>在发送和接收报文时，总线上的节点如果检测出了错误，那么该节点就会发送错误帧，通知总线上的节点，自己出错了。错误帧由<strong>错误标志</strong>和<strong>错误界定符</strong>两个部分组成。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347241667.png" alt="1701347241667"></p>
<ul>
<li>主动错误标志：6个连续的显性位；</li>
<li>被动错误标志：6个连续的隐性位；</li>
<li>错误界定符：8个连续的隐性位。</li>
</ul>
<p>可以看到在错误标志之后还有0~6位的错误标志重叠，这一段最低有0个位，最多有6个位，关于这一段是怎么形成的，将在下文中解释。</p>
<h3 id="4-5-2-错误检测"><a href="#4-5-2-错误检测" class="headerlink" title="4.5.2 错误检测"></a><strong><strong>4.5.2 错误检测</strong></strong></h3><h4 id="4-5-2-1-位填充原则"><a href="#4-5-2-1-位填充原则" class="headerlink" title="4.5.2.1 位填充原则"></a><strong><strong>4.5.2.1 位填充原则</strong></strong></h4><p>在了解<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CAN%E6%80%BB%E7%BA%BF&amp;spm=1001.2101.3001.7020">CAN总线</a>中的错误检测之前，首先需要了解什么是位填充。CAN协议中规定，当<strong>相同极性的电平持续五位</strong>时，则 <strong>添加一个极性相反的位</strong> 。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347301950.png" alt="1701347301950"></p>
<ul>
<li>对于<strong>发送节点</strong>而言：在发送<strong>数据帧</strong>和<strong>遥控帧</strong>时，对于<strong>SOF~CRC(除去CRC界定符)</strong> 之间的位流，相同极性的电平如果持续5位，那么在下一个位插入一个与之前5位反型的电平；</li>
<li>对于<strong>接收节点</strong>而言：在接收<strong>数据帧</strong>和<strong>遥控帧</strong>时，对于<strong>SOF~CRC(除去CRC界定符)</strong>之间的位流，相同极性的电平如果持续5位，那么需要删除下一位再接收。</li>
</ul>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347321170.png" alt="1701347321170"></p>
<blockquote>
<p>Tips: 注意：填充位的添加和删除是由发送节点和接收节点完成的，CAN-BUS只负责传输，不会操纵信号。</p>
</blockquote>
<h4 id="4-5-2-2-错误的种类"><a href="#4-5-2-2-错误的种类" class="headerlink" title="4.5.2.2 错误的种类"></a><strong><strong>4.5.2.2 错误的种类</strong></strong></h4><p>在CAN总线通信中，一共有五种错误：</p>
<ul>
<li>位错误</li>
<li>ACK错误</li>
<li>填充错误</li>
<li>CRC错误</li>
<li>格式错误</li>
</ul>
<h5 id="4-5-2-2-1-位错误（Bit-Check-Error）"><a href="#4-5-2-2-1-位错误（Bit-Check-Error）" class="headerlink" title="4.5.2.2.1 位错误（Bit Check Error）"></a><strong><strong>4.5.2.2.1 位错误（Bit Check Error）</strong></strong></h5><p>节点将自己发送到总线上的电平与同时从总线上回读到的电平进行比较，如果发现二者不一致，那么这个节点就会检测出一个位错误。</p>
<p>实际上所谓“发出的电平与从总线上回读的电平不一致”，指的就是<strong>节点向总线发出隐性位，却从总线上回读到显性位</strong>或者<strong>节点向总线发出显性位，却从总线上回读到隐性位</strong>这两种情况。</p>
<blockquote>
<p>Tips: 有三种例外情况不属于位错误：</p>
<ul>
<li>在 <strong>仲裁区</strong> ，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示该节点仲裁失败；</li>
<li>在 <strong>ACK槽</strong> ，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示，该节点当前发送的这一帧报文至少被一个其它节点正确接收；</li>
<li><strong>该节点发送被动错误标志</strong> ，节点Node_A向总线发送连续六个隐性位（被动错误标志）却回读到显性位，不认为是位错误。因为被动错误标志是六个连续的隐性位，所以在总线上按照线与机制，有可能这六个连续隐性位被其它节点发送的显性电平“吃掉”；</li>
</ul>
</blockquote>
<h5 id="4-5-2-2-2-ACK错误（Acknowledgment-Error）"><a href="#4-5-2-2-2-ACK错误（Acknowledgment-Error）" class="headerlink" title="4.5.2.2.2 ACK错误（Acknowledgment Error）"></a><strong><strong>4.5.2.2.2 ACK错误（Acknowledgment Error）</strong></strong></h5><p>按照CAN协议的规定，在一帧报文（数据帧或者遥控帧）发出之后，如果接收节点Node_B成功接收了该帧报文，那么接收节点Node_B就要在该帧报文ACK槽对应的时间段内向总线上发送一个显性位来应答发送节点Node_A。这样发送节点Node_A就会在ACK槽时间段内从总线上回读到一个显性位。因此：</p>
<p>当发送节点Node_A在 <strong>ACK槽时间段内没有回读到显性位</strong> ，那么发送节点Node_A就会检测到一个ACK应答错误。这表示没有一个节点成功接收该帧报文。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347344846.png" alt="1701347344846"></p>
<h5 id="4-5-2-2-3-填充错误（Fill-Error）"><a href="#4-5-2-2-3-填充错误（Fill-Error）" class="headerlink" title="4.5.2.2.3 填充错误（Fill Error）"></a><strong><strong>4.5.2.2.3 填充错误（Fill Error）</strong></strong></h5><p>在需要执行<strong>位填充原则</strong>的帧段（数据帧遥控帧的SOF~CRC序列），检测到 <strong>连续六个同性位</strong> ，则检测到一个填充错误。</p>
<h5 id="4-5-2-2-4-CRC错误"><a href="#4-5-2-2-4-CRC错误" class="headerlink" title="4.5.2.2.4 CRC错误"></a><strong><strong>4.5.2.2.4 CRC错误</strong></strong></h5><p>发送节点Node_A在发送数据帧或者遥控帧时，会计算出该帧报文的CRC序列。接收节点Node_B在接收报文时也会执行相同的CRC算法，如果接收节点Node_B计算出的CRC序列值与发送节点Node_A发来的CRC序列值不一致，那么接收节点就检测到一个CRC错误。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347357789.png" alt="1701347357789"></p>
<h5 id="4-5-2-2-5-格式错误"><a href="#4-5-2-2-5-格式错误" class="headerlink" title="4.5.2.2.5 格式错误"></a><strong><strong>4.5.2.2.5 格式错误</strong></strong></h5><p>在一帧报文发送时，如果在必须发送预定值的区域内检测到了非法值，那么就检测到一个格式错误。</p>
<p>CAN报文中，有预定值的区域包括：</p>
<ul>
<li>数据帧和遥控帧的 <strong>CRC界定符、ACK界定符、EOF</strong> ；</li>
<li><strong>错误帧界定符</strong></li>
<li><strong>过载帧界定符</strong></li>
</ul>
<h3 id="4-5-3-错误通知"><a href="#4-5-3-错误通知" class="headerlink" title="4.5.3 错误通知"></a><strong><strong>4.5.3 错误通知</strong></strong></h3><p>上一节中，讲到CAN通信中有五种错误，并且介绍了在什么情况下能够检测到这几种错误，在检测到错误之后，检测到错误的节点就要发送错误帧到总线上来通知总线上的其他节点。错误帧有的带有 <strong>主动错误标志</strong> ，有的带有 <strong>被动错误标志</strong> ，而且错误标志重叠部分的字节数也不一样，那么问题就来了：</p>
<ul>
<li>什么情况下发送带有主动错误标志的错误帧；</li>
<li>什么情况下发送带有被动错误标志的错误帧；</li>
<li>在哪个时间点发送错误帧；</li>
<li>错误标志重叠部分是怎样形成的；</li>
</ul>
<h3 id="4-5-3-1-节点错误状态"><a href="#4-5-3-1-节点错误状态" class="headerlink" title="4.5.3.1 节点错误状态"></a><strong><strong>4.5.3.1 节点错误状态</strong></strong></h3><p>按照CAN协议的规定，CAN总线上的节点始终处于以下三种状态之一。</p>
<ul>
<li>主动错误状态</li>
<li>被动错误状态</li>
<li>总关闭状态</li>
</ul>
<p>当满足一定的条件时，节点可以从一种状态转换为另外一种状态。</p>
<blockquote>
<p>Tips: 需要注意的是：</p>
<ul>
<li>处于 <strong>主动错误状态</strong> ，表示该节点具备发出<strong>主动错误标志</strong>的能力;</li>
<li>处于 <strong>被动错误状态</strong> ，表示节点具备发出<strong>被动错误标志</strong>的能力。</li>
</ul>
</blockquote>
<p>1）主动错误状态</p>
<ul>
<li>节点处于主动错误状态 <strong>可以正常通信</strong> ；</li>
<li>处于主动错误状态的节点（可能是接收节点也可能是发送节点）在检测出错误时， <strong>发出主动错误标志</strong> 。</li>
</ul>
<p>2）被动错误状态</p>
<ul>
<li>节点处于被动错误状态 <strong>可以正常通信</strong> ；</li>
<li>处于被动错误状态的节点（可能是接收节点也可能是发送节点）在检测出错误时， <strong>发出被动错误标志</strong> 。</li>
</ul>
<blockquote>
<p>Tips: 注意：这里说处于主动错误状态或被动错误状态的节点仍然可以正常通信，这里的<strong>正常通信</strong>指的是：节点仍然能够从总线上接收报文，也能够竞争总线获胜后向总线上发送报文。但是不代表接收的报文一定正确也不代表一定能正确的发送报文。</p>
</blockquote>
<p>3）总线关闭状态</p>
<ul>
<li>节点处于总线关闭状态，那么该节点<strong>不能收发</strong>报文；</li>
<li>处于总线关闭状态的节点，只能一直等待，在满足一定条件的时候，再次进入到 <strong>主动错误状态</strong> 。</li>
</ul>
<h3 id="4-5-3-2-错误状态的转换"><a href="#4-5-3-2-错误状态的转换" class="headerlink" title="4.5.3.2 错误状态的转换"></a><strong><strong>4.5.3.2 错误状态的转换</strong></strong></h3><p>现在我们知道：</p>
<ul>
<li>处于主动错误状态的节点在检测到错误时会发送带有主动错误标志的错误帧；</li>
<li>处于被动错误状态的节点在检测到错误时会发送带有被动错误标志的错误帧。</li>
</ul>
<p>那么一个CAN节点在什么情况下处于主动错误状态，什么情况下处于被动错误状态呢？</p>
<p>根据CAN协议的规定，在CAN节点内，有两个计数器： <strong>发送错误计数器（TEC）和接收错误计数器（REC）</strong> 。</p>
<blockquote>
<p>Tips: 需要注意的是：这两个计数器计的不是收发报文的数量，也不是收发错误帧的数量。TEC和RCE计数值的变化，是根据下表的规定来进行的</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347372565.png" alt="1701347372565"></p>
</blockquote>
<p>CAN节点错误状态的转换，就是基于这两个计数器来进行的。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347382135.png" alt="1701347382135"></p>
<p>可以看出，节点错误状态的转换就是一个<strong>“量变”到“质变”的过程：</strong></p>
<h4 id="1-主动错误状态"><a href="#1-主动错误状态" class="headerlink" title="1) 主动错误状态"></a><strong>1) 主动错误状态</strong></h4><p><strong>最开始TCE和REC都小于127时，就处于主动错误状态。</strong></p>
<p>在这一状态下，节点检测到一个错误就会发送带有<strong>主动错误标志</strong>的 <strong>错误帧</strong> ，因为主动错误标志是 <strong>连续六个显性位</strong> ，所以这个时候主动错误标志将会“覆盖”掉总线上其它节点的发送，而之前在CAN总线上传输的报文就被这“六个连续显性位”破坏掉了。</p>
<p> <strong>如果发出主动错误帧的节点是发送节点</strong> ，这个情况下就相当于：刚刚发送的那一帧报文我发错了，现在我破坏掉它（发送主动错误帧），你们不管收到什么都不算数；</p>
<p> <strong>如果发出主动错误帧的节点是接收节点</strong> ，这个情况就相当于：刚刚我收报文的时候发现了错误，不管你们有没有发现这个错误，我现在主动站出来告诉大家这个错误，并把这一帧报文破坏掉（发送主动错误帧），刚才你们收到的东西不管对错都不算数了。</p>
<blockquote>
<p>Tips: 处于主动错误状态，说明这个节点目前是比较可靠的，出现错误的原因可能不是它本身的问题，即刚刚检测到的错误可能不仅仅只有它自己遇到，正是因为这一点，整个总线才相信它报告的错误，允许它破坏掉发送中的报文，也就是将这一次的发送作废。</p>
</blockquote>
<h4 id="2）被动错误状态"><a href="#2）被动错误状态" class="headerlink" title="2）被动错误状态"></a><strong><strong>2）被动错误状态</strong></strong></h4><p>在这一状态下，节点Node_A检测到一个错误就会发送带有被动错误标志的错误帧，因为被动错误标志是连续六个隐性位，所以这个时候总线上正在传输的报文位流不会受到该被动错误帧的影响，其它的节点该发送的发送，该接收的接收，没人搭理这个发送被动错误帧的节点Node_A。</p>
<p>如果发出被动错误帧的节点Node_A为报文的发送节点，那么在发送被动错误帧之后，刚刚正在发送的报文被破坏，并且Node_A不能在错误帧之后随着<strong>连续发送</strong>刚刚发送失败的那个报文。随之而来的是 <strong>帧间隔</strong> ，并且连带着8位隐性位的 <strong>“延迟传送”</strong>段；这样总线电平就呈现出连续11位隐性位，总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争。此时如果Node_A能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。这种机制的目的正是为了让其它正常节点（处于主动错误）优先使用总线。</p>
<blockquote>
<p>Tips: 处于 <strong>被动错误状态</strong> ，说明这个节点目前是不太可靠的，出现错误的原因可能是它本身的问题，即刚刚检测到的错误可能仅仅只有它自己遇到，正是因为这一点，整个总线才不信任它报告的错误，从而只允许它发送六个连续的隐性位，这样它才不会拖累别人。</p>
</blockquote>
<h4 id="3）总线关闭状态"><a href="#3）总线关闭状态" class="headerlink" title="3）总线关闭状态"></a><strong><strong>3）总线关闭状态</strong></strong></h4><p>如果一个处于被动错误状态的节点，仍然多次发送被动错误帧，那么势必导致 <strong>TEC ＞ 255</strong> ，这样就处于 <strong>总线关闭状态</strong> 。</p>
<p>在总线关闭状态下的节点Node_A不能向总线上发送报文，也不能从总线上接收报文，整个节点脱离总线。等到检测到128次11个连续的隐性位时，TEC和REC置0，重新回到主动错误状态。</p>
<p>按照我的理解这个所谓“检测到128次11个连续隐性位”其实就是让这个节点隔离一段时间冷静下，因为它一旦处于总线关闭状态，就不会和总线有任何的联系，这个时候只要它计算时间等于达到传送128次11个连续隐性位所用的时间，就可以重新连到总线上。</p>
<blockquote>
<p>Tips: 处于总线关闭状态说明，这个节点目前挂掉了，总线先把它踢开，这样它才不会拖累别人，等到它冷静一段时间之后再回到总线上。</p>
</blockquote>
<h3 id="4-5-3-3-错误帧的发送"><a href="#4-5-3-3-错误帧的发送" class="headerlink" title="4.5.3.3 错误帧的发送"></a><strong><strong>4.5.3.3 错误帧的发送</strong></strong></h3><p>在检测到错误之后，什么时候发送错误帧呢？</p>
<p>按照CAN协议的规定：</p>
<ul>
<li>位错误、填充错误、格式错误、ACK错误。 <strong>在错误产生的那一位的下一位开始发送错误帧</strong> 。</li>
<li>CRC错误 <strong>紧随ACK界定符后的位发送错误帧</strong> 。</li>
</ul>
<p>例子1：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347403665.png" alt="1701347403665"></p>
<p>（1）发送节点Node_A发送一个显性位，但是却从总线上听到一个隐形位，于是Node_A节点就会检测到一个位错误；</p>
<p>（2）Node_A检测到位错误之后，立即在下一位开始发送主动错误帧：6个连续显性位的主动错误标志+8个连续隐性位的错误界定符；</p>
<p>（3）对应Node_A发出的主动错误标志，总线上电平为6个连续显性位；</p>
<p>（4）接收节点Node_B和Node_C从总线上听到连续6个显性位，那么就会检测到一个填充错误，于是这两个节点都会发送主动错误帧；</p>
<p>（5）对应Node_B和Node_C发出的主动错误标志，总线电平又有6个连续显性电平，对应Node_B和Node_C发出的错误界定符，总线电平有8个连续的隐性电平。</p>
<p>（6）在间歇场之后，Node_A节点重新发送刚刚出错的报文。</p>
<p>例子2：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347408782.png" alt="1701347408782"></p>
<p>从上图中可以看出错误帧之中，错误标志重叠部分是怎样形成的，这个例子中，位错误的错误标志与填充错误的错误标志重叠两位，剩下的部分还有四位：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347420579.png" alt="1701347420579"></p>
<h2 id="4-6-CAN协议过载帧和帧间隔"><a href="#4-6-CAN协议过载帧和帧间隔" class="headerlink" title="4.6 CAN协议过载帧和帧间隔"></a><strong><strong>4.6 CAN协议过载帧和帧间隔</strong></strong></h2><h3 id="4-6-1-过载帧"><a href="#4-6-1-过载帧" class="headerlink" title="4.6.1 过载帧"></a><strong><strong>4.6.1 过载帧</strong></strong></h3><p>过载帧是<strong>接收节点</strong>向总线上其它节点报告自身<strong>接收能力达到极限</strong>的帧。上面这句话可以这样理解：接收节点Node_A接收报文的能力达到极限了，于是Node_A就会发出过载帧来告诉总线上的其它节点（包括发送节点），我接收节点Node_A已经没有能力处理你们发来的报文了。</p>
<p>过载帧包括：<strong>过载标志</strong>和<strong>过载界定符</strong>两个部分</p>
<ul>
<li><strong>过载标志</strong> ：连续6个显性位；</li>
<li><strong>过载界定符</strong> ：连续8个隐性位。</li>
<li>与错误帧类似，过载帧中有 <strong>过载帧重叠部分</strong> ，且形成过载重叠标志的原因与形成错误帧中的错误重叠标志的原因是相同的</li>
</ul>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347603850.png" alt="1701347603850"></p>
<p>对于过载帧的帧结构我们可以这样理解：接收节点Node_A达到接收极限时，就会发出过载帧到总线上，显然，过载标志的6个连续显性位会屏蔽掉总线上其它节点的发送，也就是说这个时候Node_A通过发送过载帧的方式来破坏其它节点的发送，这样在Node_A发送过载帧期间，其它节点就不能成功发送报文，于是就相当于把其它节点的发送推迟了，也就是说Node_A在其发送过载帧的这段时间得以“休息”。</p>
<p>有三种情况会引起过载帧：</p>
<ul>
<li>接收节点自身原因。接收节点由于某种原因需要延迟接收下一个数据帧或者遥控帧。</li>
<li>在帧间隔的间歇段的第一位和第二位检测到一个显性位（正常的间歇段都是隐性位）<br>帧间隔的间隔段本应是三个连续的隐性位，如果接收节点Node_A在间隔段检测到显性位，那么就意味着此时有报文发向接收节点Node_A，但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</li>
<li>CAN节点在<strong>错误界定符</strong>或<strong>过载界定符</strong>的第八位(最后一位)听到一个 <strong>显性位0</strong> ，节点会发送一个过载帧，且错误计数器不会增加。<br>接收节点Node_A在错误界定符和过载界定符的最后一位听到显性位，也意味着有报文发向Node_A，但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</li>
</ul>
<h3 id="4-6-2-帧间隔"><a href="#4-6-2-帧间隔" class="headerlink" title="4.6.2 帧间隔"></a><strong><strong>4.6.2 帧间隔</strong></strong></h3><p>帧间隔是用来隔离数据帧（或者遥控帧）的，也就是说，数据帧（或者遥控帧）通过插入<strong>帧间隔</strong>可以将本帧与先行帧（数据帧、遥控帧、错误帧、过载帧）分隔开来。</p>
<blockquote>
<p>Tips: 过载帧和错误帧的前面不能插入帧间隔。</p>
</blockquote>
<p>帧间隔有两种不同的形式：</p>
<p>主动错误状态的帧间隔：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347621761.png" alt="1701347621761"></p>
<p>被动错误状态的帧间隔：</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701347626515.png" alt="1701347626515"></p>
<p> <strong>间隔段</strong> ：连续三个隐性位；间隔段期间，所有节点不允许发送数据这或遥控帧，只要在这期间监听到显性位，接收节点就会发送过载帧。</p>
<p> <strong>空闲段</strong> ：连续隐性位，个数不一定，0个或者多个都可以。总线空闲的时间是任意长的，只要总线空闲，节点就可以竞争总线。</p>
<p> <strong>暂停段</strong> ：只有处于被动错误状态的节点在发送帧间隔的时候，才会在帧间隔中插入8个连续隐性位的暂停段。</p>
<p>暂停段，又叫做延迟传送段，为什么节点处于被动状态时会有这样一段呢。原因如下:首先，考虑主动错误状态的节点Node_A，发送主动错误标志之后，随之就要重新发送刚刚发送失败的报文，但是为了间隔开与前面刚刚发送的错误帧，<strong>总线在错误帧之后就会插入３个隐形位的帧间隔，在这３个隐形位期间，其它的节点不足以判定总线空闲（需要连续11个隐性位才能判定），所以Node_A仍然占据着总线的控制权，于是在帧间隔之后，Node_A能够接着发送报文。</strong>现在Node_A转入到被动错误状态了，说明它已经不是很可靠了，这个时候如果没有延迟传送段，在Node_A发出被动错误标志之后，它仍然能够在3位的帧间隔之后立即重新发送报文，这是不符合我们对被动错误状态的处理要求的当然也是不符合CAN协议的，于是乎对于发送出被动错误标志的节点，总线在帧间隔中加入了８个连续隐性位的延迟传送段，这样的3+8=11个连续隐性位。就能让Node_A在这个帧间隔期间失去对总线的控制权，从而优先保证其它正常(处于主动错误状态)节点能够使用总线，而不必等着一个已经不可靠的Node_A占据总线。</p>
<h2 id="4-7-CAN通信的位定时与同步"><a href="#4-7-CAN通信的位定时与同步" class="headerlink" title="4.7 CAN通信的位定时与同步"></a><strong><strong>4.7 CAN通信的位定时与同步</strong></strong></h2><h3 id="4-7-1-位定时"><a href="#4-7-1-位定时" class="headerlink" title="4.7.1 位定时"></a><strong><strong>4.7.1 位定时</strong></strong></h3><h4 id="4-7-1-1-比特率和波特率"><a href="#4-7-1-1-比特率和波特率" class="headerlink" title="4.7.1.1 比特率和波特率"></a><strong><strong>4.7.1.1 比特率和波特率</strong></strong></h4><p>1）</p>
<p> <strong>位速率</strong> :又叫做 <strong>比特率（bit rata）</strong> 、 <strong>信息传输率</strong> ，表示的是单位时间内，总线上传输的 <strong>信息量</strong> ，即 <strong>每秒能够传输的二进制位的数量</strong> ，单位是bit per second。</p>
<p>2）</p>
<p> <strong>波特率</strong> ：又叫做 <strong>传码率</strong> 、 <strong>信号传输率</strong> ，表示的是单位时间内传输的码元的数量，当两相调制时，一个码元用一个二进制位表示，此时波特率在数值上和比特率是一样的，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CAN%E6%80%BB%E7%BA%BF&amp;spm=1001.2101.3001.7020">CAN总线</a>正是两项调制这种情况。</p>
<blockquote>
<p>Tips: <strong>比特率</strong>和<strong>波特率</strong>并不是一回事儿，这一定一定要牢记。</p>
</blockquote>
<h4 id="4-7-1-2-位时间"><a href="#4-7-1-2-位时间" class="headerlink" title="4.7.1.2 位时间"></a><strong><strong>4.7.1.2 位时间</strong></strong></h4><h5 id="4-7-1-2-1-位时间的概念"><a href="#4-7-1-2-1-位时间的概念" class="headerlink" title="4.7.1.2.1 位时间的概念"></a><strong><strong>4.7.1.2.1 位时间的概念</strong></strong></h5><p> <strong>位时间</strong> ：表示的是一个二进制位在总线上传输时所需要的时间。</p>
<p>所以：位速率 = 1 / 位时间</p>
<p>首先了解以下CAN总线系统中的两个时钟：<strong>晶振时钟周期</strong>和<strong>CAN时钟周期</strong></p>
<ul>
<li><strong>晶振时钟周期</strong> ：是由单片机振荡器的晶振频率决定的，指的是 <strong>振荡器每震荡一次所消耗的时间长度</strong> ，也是整个系统中最小的时间单位。</li>
<li><strong>CAN时钟周期</strong> ：CAN时钟是由系统时钟分频而来的一个时间长度值，实际上就是 <strong>一个时间份额Tq</strong> 。可以按照下面的公式计算：</li>
</ul>
<script type="math/tex; mode=display">
CAN时钟周期=2×晶振时钟周期×BRP</script><p>  <img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348103686.png" alt="1701348103686"></p>
<p>其中BRP叫做波特率预分频值（baudrate prescaler）。</p>
<h5 id="4-7-1-2-2-位时间的分段"><a href="#4-7-1-2-2-位时间的分段" class="headerlink" title="4.7.1.2.2 位时间的分段"></a><strong>4.7.1.2.2 位时间的分段</strong></h5><p>如上文所述，在CAN的位定时中，一个CAN时钟周期称为一个<strong>时间量子</strong> —  <strong>Tq</strong> 。<br>如下图所示：位时间分为四个段： <strong>同步段、传播段、相位缓冲段1、相位缓冲段2</strong> ，总共8~25个时间量子（Tq）。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348213567.png" alt="1701348213567"></p>
<p>1） <strong>同步段</strong> （Synchronization Segment）：</p>
<ul>
<li>长度固定，1个时间量子Tq；</li>
<li>一个位的传输从同步段开始；</li>
<li>同步段用于同步总线上的各个节点，一个位的跳边沿在此时间段内。</li>
</ul>
<p>2） <strong>传播段</strong> （Propagation Segment）：</p>
<ul>
<li>传播段用于补偿报文在总线和节点上传输时所产生的时间延迟；</li>
<li>传播段时长 ≥ 2 × 报文在总线和节点上传输时产生的时间延迟 ；</li>
<li>传播段时长可编程（1~8个时间量子Tq）。</li>
</ul>
<p>3） <strong>相位缓冲段1</strong> （Phase Buffer Segment1）：</p>
<ul>
<li>用于补偿节点间的晶振误差；</li>
<li>允许通过重同步对该段加长；</li>
<li>在这个时间段的末端进行总线状态的采样；</li>
<li>长度可编程（1~8个时间量子Tq）</li>
</ul>
<p>4） <strong>相位缓冲段2</strong> （Phase Buffer Segment2）：</p>
<ul>
<li>用于补偿节点间的晶振误差；</li>
<li>允许通过重同步对该段缩短；</li>
<li>长度可编程（1~8个时间量子Tq）</li>
</ul>
<p>于是</p>
<script type="math/tex; mode=display">
tBit=tSS+tPS+tPBS1+tPBS2</script><p>tBit:位时间</p>
<p>tSS:同步段时间</p>
<p>tPS:传播段时间</p>
<p>tPBS1:时间段1</p>
<p>tPBS2:时间段2</p>
<h3 id="4-7-2-CAN的同步机制"><a href="#4-7-2-CAN的同步机制" class="headerlink" title="4.7.2 CAN的同步机制"></a><strong><strong>4.7.2 CAN的同步机制</strong></strong></h3><p>在CAN通信中，有两种同步机制：<strong>硬同步</strong>与 <strong>重同步</strong> 。</p>
<h4 id="4-7-2-1-同步的规则"><a href="#4-7-2-1-同步的规则" class="headerlink" title="4.7.2.1 同步的规则"></a><strong><strong>4.7.2.1 同步的规则</strong></strong></h4><p>☆<strong>一个位时间</strong>内只允许 <strong>一种同步方式</strong> ，要么硬同步要么重同步；</p>
<p>☆ 任何一个从“隐性”到“显性”的<strong>下降沿</strong>都可以用于同步；</p>
<p>☆<strong>硬同步</strong>发生在报文的 <strong>SOF位</strong> ，所有接收节点调整各自当前位的同步段，使其位于发送的SOF位内；</p>
<p>☆<strong>重同步</strong>发生在一个报文 <strong>SOF位之外的其它段</strong> ，当下降沿落在了同步段之外时发生重同步；</p>
<p>☆ 在SOF到仲裁场发送的时间段内，如果有多个节点同时发送报文，那么这些发送节点对跳变沿不进行重同步</p>
<h4 id="4-7-2-2-硬同步"><a href="#4-7-2-2-硬同步" class="headerlink" title="4.7.2.2 硬同步"></a><strong><strong>4.7.2.2 硬同步</strong></strong></h4><p>硬同步发生在 <strong>SOF位</strong> ，所有<strong>接收节点</strong>调整各自 <strong>当前位的同步段</strong> ，<strong>调整宽度不限</strong></p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348277220.png" alt="1701348277220"></p>
<p>（1）发送节点Node_A在发送SOF位时，SOF位的下降沿在SS段；</p>
<p>（2）这个时候接收节点Node_B发现自己当前位的SS段和发送节点SOF位的SS段不同步。也就是说当Node_A产生SOF位SS段时，Node_B的当前位的SS段已经在5个Tq之前产生了；</p>
<p>（3）于是接收节点Node_B强行将自己当前位的SS段拉到与SOF位的SS段同步。</p>
<h4 id="4-7-2-3-重同步"><a href="#4-7-2-3-重同步" class="headerlink" title="4.7.2.3 重同步"></a><strong><strong>4.7.2.3 重同步</strong></strong></h4><p>重同步发生在一个报文SOF位之外的其它位场内，当接收节点Node_B当前位的下降沿落在了发送节点Node_A当前位的同步段之外时发生重同步。</p>
<p>重同步会导致<strong>相位缓冲段1的延长</strong>或者 <strong>相位缓冲段2的缩短</strong> ，从而保证采样点的准确。</p>
<h5 id="4-7-2-3-1-PBS1延长"><a href="#4-7-2-3-1-PBS1延长" class="headerlink" title="4.7.2.3.1 PBS1延长"></a><strong><strong>4.7.2.3.1 PBS1延长</strong></strong></h5><p>发的晚（慢），收的早（块），导致PBS1延长。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348305070.png" alt="1701348305070"></p>
<p>如上图所示：</p>
<p>（1）发送节点Node_A比接收节点Node_B的时间慢了，也就是说Node_A当前位的ss段产生的时候，Node_B 当前位的ss段已经在2个Tq之前产生了；</p>
<p>（2）所以这个时候接收节点Node_B就将PBS1延长2个Tq的时间；</p>
<p>（3）于是这个时候Node_A当前位的采样点就和Node_B的采样点同步了。</p>
<h5 id="4-7-2-3-2-PBS2缩短"><a href="#4-7-2-3-2-PBS2缩短" class="headerlink" title="4.7.2.3.2 PBS2缩短"></a><strong><strong>4.7.2.3.2 PBS2缩短</strong></strong></h5><p>发的早（快），收的晚（慢），导致PBS2缩短。</p>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348322758.png" alt="1701348322758"></p>
<p>如上图所示： </p>
<p>（1）发送节点Node_A当前位的SS段诞生2Tq时长之后，接收节点Node_B的当前位才产生SS段； </p>
<p>（2）于是，接收节点Node_B当前位的PBS2段缩短， </p>
<p>（3）这样就会导致接收节点Node_B的下一位能够提前2个Tq，从而Node_B的下一位采样点和Node_A下一位的采样点能够同步。</p>
<h5 id="4-7-2-3-3-同步跳转宽度"><a href="#4-7-2-3-3-同步跳转宽度" class="headerlink" title="4.7.2.3.3 同步跳转宽度"></a><strong><strong>4.7.2.3.3 同步跳转宽度</strong></strong></h5><p>在重同步时，有个 <strong>同步跳转宽度</strong> （SJW，Synchro Jump Width）的概念，表示的是 <strong>PBS1和PBS2重同步时允许跳转的最大宽度</strong> 。 同步跳转宽度必须满足以下几个条件：</p>
<ul>
<li>SJW必须小于PBS1和PBS2的最小值</li>
<li>SJW最大值不能超过4</li>
</ul>
<h3 id="4-7-3-位定时参数的确定"><a href="#4-7-3-位定时参数的确定" class="headerlink" title="4.7.3 位定时参数的确定"></a><strong><strong>4.7.3 位定时参数的确定</strong></strong></h3><p>位定时的参数主要涉及以下几个：</p>
<p>（1） <strong>位速率</strong> ：单位为bps、Kbps、Mbps</p>
<script type="math/tex; mode=display">
1Mbps=1000Kbps=1000000bps</script><p>（2）  <strong>位时间</strong> ：tBit，单位一般为纳秒(ns)</p>
<script type="math/tex; mode=display">
tBit=1/位速率</script><p>（3）  <strong>时间量子Tq</strong> ：</p>
<script type="math/tex; mode=display">
Tq=1/NBT</script><p>NBT 表示的是一个位时间tBit内包含Tq的个数。</p>
<p>（4）<strong>传输延迟时间tPTS</strong></p>
<p>CAN报文在CAN总线上的传输时，物理延迟包含两个部分：</p>
<ul>
<li>在CAN-BUS上传输造成的延迟</li>
<li>在节点上传输造成延迟</li>
</ul>
<p><img src="/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/image/1701348371887.png" alt="1701348371887"></p>
<p>按照CAN通信协议的规定，补偿给传播延迟的时间长度要至少等于实际实际传播延迟时长的2倍，即：</p>
<script type="math/tex; mode=display">
tPTS≥2×tdel=2×(tdel+tBus)</script><p> <strong>需要注意的是</strong> ：</p>
<blockquote>
<p>Tips: 在CAN总线通信系统中是以时间量子Tq来度量时间的，所以如果延迟补偿时间tPTS = 3.1Tq，那么这个时候要取：tPTS = 4Tq。</p>
</blockquote>
<p>（5）<strong>相位缓冲段</strong> 相位缓冲段的时间长度分为两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (NBT-1-tPTS_Tq)/2==偶数</span><br><span class="line">    PBS1_Tq = PBS2_Tq = (NBT-1-tPTS_Tq)/2</span><br><span class="line">else</span><br><span class="line">    PBS1_Tq = (NBT-1-tPTS_Tq)/2</span><br><span class="line">    PBS2_Tq = PBS1_Tq + 1</span><br></pre></td></tr></table></figure>
<p>(6) <strong>同步跳转宽度</strong></p>
<script type="math/tex; mode=display">
SJW=min(PBS1_Tq,4)</script><p>(7)<strong>验证晶振误差Df</strong></p>
<p>CAN总线的晶振误差必须同时满足下面三个条件：</p>
<script type="math/tex; mode=display">
Df<=SJW(2×10×NBT)</script><script type="math/tex; mode=display">
Df<=min(PBS1_Tq,PBS2_Tq)2×(13×NBT−PBS2_Tq)</script><script type="math/tex; mode=display">
Df≤1.58%</script><h3 id="4-7-4-例子"><a href="#4-7-4-例子" class="headerlink" title="4.7.4 例子"></a><strong><strong>4.7.4 例子</strong></strong></h3><p>以下面的例子来讲述位定时参数的确定方法：</p>
<p>MCU晶振16MHz，位速率1Mbps，总线长度20m，单位总线延迟5ns/m，物理接口的发送接收延迟150ns</p>
<p>（1）晶振时钟周期：T=1s/16MHz = 62.5ns</p>
<p>（2）位时间 ：tBit = 1/1Mbps = 1000ns</p>
<p>（3）BPR和NBT：考虑到 T = 125ns，tBit = 1000ns，所以BPR只能取值为1，才能满足NBT∈[8,25],于是预分频数BPR=1；</p>
<p>（4）CAN时钟周期Tq = 2 × 62.5 × 1 = 125ns</p>
<p>（5）NBT = 8</p>
<p>（6）传输延迟时间tPTS</p>
<script type="math/tex; mode=display">
tPTS=2×（20×5+150）=500ns</script><p>所以</p>
<script type="math/tex; mode=display">
tPTS_Tq=tPTSTq=500125=4</script><p>于是NBT=8个Tq的长度中需要有4个Tq用于补偿传播延迟，于是还剩下4个Tq，</p>
<p>SS同步段长度固定占据1个Tq，还剩3个Tq，于是PBS1分配一个Tq，PBS2分配2个Tq。</p>
<p>（7）同步跳转宽度</p>
<script type="math/tex; mode=display">
SJW=min{PBS1,4}=1</script><p>（8）晶振误差</p>
<script type="math/tex; mode=display">
Df<=SJW(2×10×NBT)=1(2×10×8)=0.00625</script><script type="math/tex; mode=display">
Df<=min(PBS1_Tq,PBS2_Tq)2×(13×NBT−PBS2_Tq)</script><script type="math/tex; mode=display">
=12×(13×8−2)=0.00490</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chenbaow.github.io">BW</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chenbaow.github.io/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/">https://chenbaow.github.io/2024/04/02/%E9%80%9A%E4%BF%A1%E7%A7%8D%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chenbaow.github.io" target="_blank">爱是无一</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/">嵌入式通讯协议</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/01/C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/" title="C常见知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C常见知识点</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/03/%E5%9F%BA%E7%A1%80%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/" title="基础通信知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基础通信知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/03/%E5%9F%BA%E7%A1%80%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86/" title="基础通信知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">基础通信知识</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">BW</div><div class="author-info__description">双手揣着幸福的肉肉</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ChenBaoW"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ChenBaoW" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/2683680357@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">日常学习总结</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">1.</span> <span class="toc-text">一、串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-UART"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 UART</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B5%B7%E5%A7%8B%E4%BD%8D%E3%80%81%E6%95%B0%E6%8D%AE%E4%BD%8D%E3%80%81%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D%E3%80%81%E5%81%9C%E6%AD%A2%E4%BD%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.起始位、数据位、奇偶校验位、停止位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.波特率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-RS232%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 RS232通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-RS485%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 RS485通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81I2C%E6%80%BB%E7%BA%BF%EF%BC%88Inter-Integrated-Circuit%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">二、I2C总线（Inter Integrated Circuit）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 物理接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%8E%A5%E7%BA%BF"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 接线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 物理接口示意图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-i2c%E7%AE%80%E6%98%93%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 i2c简易时序图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%90%AF%E5%8A%A8%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 启动信号与停止信号的时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%8F%91%E9%80%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 数据位发送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 总线连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%BC%A0%E8%BE%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 传输步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-I2C%E4%BC%98%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 I2C优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-I2C%E7%BC%BA%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 I2C缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81SPI%E6%80%BB%E7%BA%BF%EF%BC%88Serial-Peripheral-Interface%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">三、SPI总线（Serial Peripheral Interface）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 硬件接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 通信原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E9%87%87%E7%94%A8%E4%B8%BB-%E4%BB%8E%E6%A8%A1%E5%BC%8F-Master-Slave-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 采用主-从模式(Master-Slave) 的控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E9%87%87%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F-Synchronous-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 采用同步方式(Synchronous)传输数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2-Data-Exchanges"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 数据交换(Data Exchanges)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-SPI%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 SPI协议总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 传输过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-SPI%E6%97%B6%E9%92%9F"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 SPI时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E6%97%B6%E9%92%9F%E6%9E%81%E6%80%A7-CKP-Clock-Polarity"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 时钟极性 CKP&#x2F;Clock Polarity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E6%97%B6%E9%92%9F%E7%9B%B8%E4%BD%8D-CKE-Clock-Phase-Edge"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 时钟相位 CKE &#x2F;Clock Phase (Edge)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 时钟配置总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E6%A8%A1%E5%BC%8F%E7%BC%96%E5%8F%B7"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 模式编号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 总线结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%8D%95%E4%BB%8E%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1 单从机模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%A4%9A%E4%BB%8E%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.6.2 多从机模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9ANSS"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">多NSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%8A%E8%8A%B1%E9%93%BE"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">菊花链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E9%80%9A%E8%AE%AF%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">3.7.1.</span> <span class="toc-text">SPI通讯的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.7.2.</span> <span class="toc-text">SPI的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Can"><span class="toc-number">4.</span> <span class="toc-text">四、Can</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-CAN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 CAN基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-CAN%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 CAN的一些基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-Can%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 Can物理层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%80%BB%E7%BA%BF%E7%BD%91%E7%BB%9C"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 总线网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-can%E4%BF%A1%E5%8F%B7%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4 can信号表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-can%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93"><span class="toc-number">4.1.5.</span> <span class="toc-text">4.1.5 can信号传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-can%E9%80%9A%E4%BF%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 can通信的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%A4%9A%E4%B8%BB%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 多主工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E9%9D%9E%E7%A0%B4%E5%9D%8F%E6%80%A7%E4%BD%8D%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 非破坏性位仲裁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9F%94%E6%80%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 系统的柔性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E9%80%9A%E4%BF%A1%E9%80%9F%E5%BA%A6"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4 通信速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.5.</span> <span class="toc-text">4.2.5 数据传输方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82"><span class="toc-number">4.2.6.</span> <span class="toc-text">4.2.6 远程数据请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E3%80%81%E9%94%99%E8%AF%AF%E9%80%9A%E7%9F%A5%E3%80%81%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D%E5%8A%9F%E8%83%BD"><span class="toc-number">4.2.7.</span> <span class="toc-text">4.2.7 错误检测、错误通知、错误恢复功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-8-%E6%95%85%E9%9A%9C%E5%B0%81%E9%97%AD"><span class="toc-number">4.2.8.</span> <span class="toc-text">4.2.8 故障封闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-CAN%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 CAN通信网络结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-OSI%E5%9F%BA%E6%9C%AC%E5%8F%82%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 OSI基本参照模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-CAN%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 CAN协议网络层次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-CAN%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%B8%8E%E9%81%A5%E6%8E%A7%E5%B8%A7"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 CAN协议数据帧与遥控帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-CAN-%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%B8%A7"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 CAN 协议中的帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%B8%8E%E9%81%A5%E6%8E%A7%E5%B8%A7"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 数据帧与遥控帧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-1-%E5%B8%A7%E8%B5%B7%E5%A7%8B"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">4.4.2.1 帧起始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-2-%E4%BB%B2%E8%A3%81%E6%AE%B5"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">4.4.2.2 仲裁段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-2-1%E4%BB%B2%E8%A3%81%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.2.2.1.</span> <span class="toc-text">4.4.2.2.1仲裁过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-2-2-%E4%BB%B2%E8%A3%81%E6%AE%B5%E4%B8%AD%E7%9A%84RTR%EF%BC%8CSRR%E5%92%8CIDE%E4%BD%8D"><span class="toc-number">4.4.2.2.2.</span> <span class="toc-text">4.4.2.2.2 仲裁段中的RTR，SRR和IDE位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-2-3-%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A4"><span class="toc-number">4.4.2.2.3.</span> <span class="toc-text">4.4.2.2.3 报文过滤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-3-%E6%8E%A7%E5%88%B6%E6%AE%B5"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">4.4.2.3 控制段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-4-%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">4.4.2.4 数据段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-5-CRC%E6%AE%B5"><span class="toc-number">4.4.2.5.</span> <span class="toc-text">4.4.2.5 CRC段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-6-ACK%E6%AE%B5"><span class="toc-number">4.4.2.6.</span> <span class="toc-text">4.4.2.6 ACK段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-7-%E5%B8%A7%E7%BB%93%E6%9D%9F"><span class="toc-number">4.4.2.7.</span> <span class="toc-text">4.4.2.7 帧结束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-CAN%E5%8D%8F%E8%AE%AE%E9%94%99%E8%AF%AF%E5%B8%A7"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 CAN协议错误帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E9%94%99%E8%AF%AF%E5%B8%A7%E7%9A%84%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1 错误帧的帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2 错误检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-1-%E4%BD%8D%E5%A1%AB%E5%85%85%E5%8E%9F%E5%88%99"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">4.5.2.1 位填充原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-2-%E9%94%99%E8%AF%AF%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">4.5.2.2 错误的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-2-1-%E4%BD%8D%E9%94%99%E8%AF%AF%EF%BC%88Bit-Check-Error%EF%BC%89"><span class="toc-number">4.5.2.2.1.</span> <span class="toc-text">4.5.2.2.1 位错误（Bit Check Error）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-2-2-ACK%E9%94%99%E8%AF%AF%EF%BC%88Acknowledgment-Error%EF%BC%89"><span class="toc-number">4.5.2.2.2.</span> <span class="toc-text">4.5.2.2.2 ACK错误（Acknowledgment Error）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-2-3-%E5%A1%AB%E5%85%85%E9%94%99%E8%AF%AF%EF%BC%88Fill-Error%EF%BC%89"><span class="toc-number">4.5.2.2.3.</span> <span class="toc-text">4.5.2.2.3 填充错误（Fill Error）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-2-4-CRC%E9%94%99%E8%AF%AF"><span class="toc-number">4.5.2.2.4.</span> <span class="toc-text">4.5.2.2.4 CRC错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-2-5-%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF"><span class="toc-number">4.5.2.2.5.</span> <span class="toc-text">4.5.2.2.5 格式错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E9%94%99%E8%AF%AF%E9%80%9A%E7%9F%A5"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3 错误通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-1-%E8%8A%82%E7%82%B9%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.4.</span> <span class="toc-text">4.5.3.1 节点错误状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-2-%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.5.5.</span> <span class="toc-text">4.5.3.2 错误状态的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E5%8A%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">1) 主动错误状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%A2%AB%E5%8A%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">2）被动错误状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%80%BB%E7%BA%BF%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">3）总线关闭状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-3-%E9%94%99%E8%AF%AF%E5%B8%A7%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-number">4.5.6.</span> <span class="toc-text">4.5.3.3 错误帧的发送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-CAN%E5%8D%8F%E8%AE%AE%E8%BF%87%E8%BD%BD%E5%B8%A7%E5%92%8C%E5%B8%A7%E9%97%B4%E9%9A%94"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 CAN协议过载帧和帧间隔</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E8%BF%87%E8%BD%BD%E5%B8%A7"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1 过载帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E5%B8%A7%E9%97%B4%E9%9A%94"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2 帧间隔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-CAN%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BD%8D%E5%AE%9A%E6%97%B6%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 CAN通信的位定时与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E4%BD%8D%E5%AE%9A%E6%97%B6"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.7.1 位定时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-1-1-%E6%AF%94%E7%89%B9%E7%8E%87%E5%92%8C%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">4.7.1.1 比特率和波特率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-1-2-%E4%BD%8D%E6%97%B6%E9%97%B4"><span class="toc-number">4.7.1.2.</span> <span class="toc-text">4.7.1.2 位时间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-1-2-1-%E4%BD%8D%E6%97%B6%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.7.1.2.1.</span> <span class="toc-text">4.7.1.2.1 位时间的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-1-2-2-%E4%BD%8D%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">4.7.1.2.2.</span> <span class="toc-text">4.7.1.2.2 位时间的分段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-CAN%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.7.2.</span> <span class="toc-text">4.7.2 CAN的同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-1-%E5%90%8C%E6%AD%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">4.7.2.1 同步的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-2-%E7%A1%AC%E5%90%8C%E6%AD%A5"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">4.7.2.2 硬同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-3-%E9%87%8D%E5%90%8C%E6%AD%A5"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">4.7.2.3 重同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-2-3-1-PBS1%E5%BB%B6%E9%95%BF"><span class="toc-number">4.7.2.3.1.</span> <span class="toc-text">4.7.2.3.1 PBS1延长</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-2-3-2-PBS2%E7%BC%A9%E7%9F%AD"><span class="toc-number">4.7.2.3.2.</span> <span class="toc-text">4.7.2.3.2 PBS2缩短</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-2-3-3-%E5%90%8C%E6%AD%A5%E8%B7%B3%E8%BD%AC%E5%AE%BD%E5%BA%A6"><span class="toc-number">4.7.2.3.3.</span> <span class="toc-text">4.7.2.3.3 同步跳转宽度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E4%BD%8D%E5%AE%9A%E6%97%B6%E5%8F%82%E6%95%B0%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">4.7.3.</span> <span class="toc-text">4.7.3 位定时参数的确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E4%BE%8B%E5%AD%90"><span class="toc-number">4.7.4.</span> <span class="toc-text">4.7.4 例子</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/08/OpenCV%E5%9F%BA%E7%A1%80/" title="OpenCV基础">OpenCV基础</a><time datetime="2024-05-08T11:00:00.000Z" title="发表于 2024-05-08 19:00:00">2024-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/05/Python%E5%AE%89%E8%A3%85OpenCV/" title="Python安装OpenCV">Python安装OpenCV</a><time datetime="2024-05-05T09:00:00.000Z" title="发表于 2024-05-05 17:00:00">2024-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/03/Pycharm%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/" title="Pycharm新建工程">Pycharm新建工程</a><time datetime="2024-05-03T10:00:00.000Z" title="发表于 2024-05-03 18:00:00">2024-05-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" title="计算机网络面经">计算机网络面经</a><time datetime="2024-04-11T09:30:00.000Z" title="发表于 2024-04-11 17:30:00">2024-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/06/Makefile/" title="Makefile">Makefile</a><time datetime="2024-04-06T14:10:00.000Z" title="发表于 2024-04-06 22:10:00">2024-04-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By BW</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://aiswuyi-api.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://aiswuyi-api.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>